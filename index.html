<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpha-Learner Trading Platform v2.3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.5/babel.min.js"></script>
   
    <!-- âœ… VERSÃƒO CORRETA PARA NAVEGADOR -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        .app {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 250px;
            background: rgba(20, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 30px;
            text-align: center;
        }
        .nav-item {
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }
        .nav-item:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
        }
        .nav-item.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
        }
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
            gap: 15px;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00ff88;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .data-source-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        .data-source-real {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }
        .data-source-simulated {
            background: rgba(255, 165, 0, 0.2);
            border: 1px solid #ffa500;
            color: #ffa500;
        }
        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        .card h3 {
            color: #00ff88;
            margin-bottom: 16px;
            font-size: 18px;
        }
        .warning-box {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #ffc107;
        }
        .success-box {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #00ff88;
        }
        .error-box {
            background: rgba(255, 71, 87, 0.1);
            border: 1px solid rgba(255, 71, 87, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #ff4757;
        }
        .api-provider-card {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            transition: all 0.3s ease;
        }
        .api-provider-card:hover {
            border-color: rgba(0, 255, 136, 0.3);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.1);
        }
        .api-provider-card.connected {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.05);
        }
        .api-status-badge {
            margin-left: auto;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        .api-status-connected {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        .api-status-disconnected {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
        }
        .api-status-testing {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .signal-card {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.05) 100%);
            border: 1px solid #00ff88;
            border-radius: 16px;
            padding: 20px;
            position: relative;
            animation: slideIn 0.5s ease-out;
        }
        .signal-card.urgent {
            animation: pulse-urgent 1s infinite;
        }
        .signal-card.success {
            border-color: #00ff88;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 255, 136, 0.1) 100%);
        }
        .signal-card.error {
            border-color: #ff4757;
            background: linear-gradient(135deg, rgba(255, 71, 87, 0.2) 0%, rgba(255, 71, 87, 0.1) 100%);
        }
        @keyframes pulse-urgent {
            0%, 100% { 
                border-color: #ffd700;
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            }
            50% { 
                border-color: #ffed4e;
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            }
        }
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .signal-direction {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .signal-direction.buy {
            color: #00ff88;
        }
        .signal-direction.sell {
            color: #ff4757;
        }
        .signal-score {
            background: rgba(0, 255, 136, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .signal-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            display: inline-block;
            margin-left: 10px;
        }
        .signal-status.pending {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        .signal-status.success {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        .signal-status.error {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
        }
        .signal-status.expired {
            background: rgba(158, 158, 158, 0.2);
            color: #9e9e9e;
        }
        .signal-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
            font-size: 14px;
        }
        .signal-actions {
            display: flex;
            gap: 10px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        .btn-primary {
            background: #00ff88;
            color: #000;
        }
        .btn-primary:hover:not(:disabled) {
            background: #00cc6a;
            transform: translateY(-2px);
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }
        .btn-danger {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
            border: 1px solid #ff4757;
        }
        .btn-danger:hover:not(:disabled) {
            background: rgba(255, 71, 87, 0.3);
        }
        .btn-emergency {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: 2px solid #ff0000;
            font-weight: bold;
            font-size: 16px;
            padding: 15px 30px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        .btn-emergency:hover:not(:disabled) {
            background: rgba(255, 0, 0, 1);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 8px;
        }
        .metric-label {
            font-size: 14px;
            color: #a0a0a0;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-label {
            display: block;
            margin-bottom: 8px;
            color: #c0c0c0;
            font-weight: 500;
        }
        .form-input, .form-select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 16px;
        }
        .form-select {
            cursor: pointer;
        }
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.2);
        }
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .toggle-switch.active {
            background: #00ff88;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }
        .toggle-switch.active::after {
            transform: translateX(30px);
        }
        .weight-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .weight-bar {
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        .weight-fill {
            height: 100%;
            background: #00ff88;
            transition: width 0.3s ease;
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 136, 0.9);
            color: #000;
            padding: 16px 20px;
            border-radius: 8px;
            font-weight: 500;
            animation: slideInRight 0.5s ease-out;
            z-index: 1000;
            max-width: 400px;
        }
        @keyframes slideInRight {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .mode-btn {
            flex: 1;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        .mode-btn.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
        }
        .connection-status-line {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-top: 15px;
        }
        .spinner {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid #00ff88;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .robot-status-panel {
            background: rgba(255, 193, 7, 0.15);
            border: 2px solid #ffc107;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .position-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        .log-entry {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }
        .log-entry.info {
            background: rgba(0, 184, 217, 0.1);
            border-left: 3px solid #00b8d9;
        }
        .log-entry.success {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
        }
        .log-entry.warning {
            background: rgba(255, 193, 7, 0.1);
            border-left: 3px solid #ffc107;
        }
        .log-entry.error {
            background: rgba(255, 71, 87, 0.1);
            border-left: 3px solid #ff4757;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        // ========================================
// IMPORTAR SUPABASE CLIENT
// ========================================
import { supabaseStorage } from './supabase-client.js';

// Substituir todas as classes que usam localStorage
        const { useState, useEffect, useRef } = React;

        // ========================================
        // âœ… CONFIGURAÃ‡ÃƒO SUPABASE
        // ========================================
        
        // âš ï¸ SUBSTITUA PELOS SEUS VALORES DO PASSO 1.3
        const SUPABASE_URL = 'https://gvgxiketszcvskrwlrcp.supabase.co'; // â† COLE SEU URL AQUI
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd2Z3hpa2V0c3pjdnNrcndscmNwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkyNjQ4ODYsImV4cCI6MjA3NDg0MDg4Nn0.8H2Ys0mMKJQIydkrHzORK0mvkStgRR1lmpPutwE1rvE'; // â† COLE SUA KEY AQUI
        
        // Criar cliente Supabase
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        
        console.log('âœ… Supabase inicializado');
        
        // VariÃ¡veis globais para auditoria
        window.auditSystemRef = null;
        window.debugAudit = true;
        
        window.auditDiag = function() {
            console.log('====== DIAGNÃ“STICO RÃPIDO ======');
            console.log('AuditSystem:', window.auditSystemRef ? 'OK' : 'ERRO');
            if (window.auditSystemRef) {
                console.log('Total de logs:', window.auditSystemRef.auditLogs.length);
                console.log('Ãšltimo log:', window.auditSystemRef.auditLogs[window.auditSystemRef.auditLogs.length - 1]);
            }
            console.log('================================');
        };

        /* ========================================
           MÃ“DULO DE INTEGRAÃ‡ÃƒO DE APIs
           ======================================== */

        const API_PROVIDERS = {
            ALPHA_VANTAGE: {
                name: 'Alpha Vantage',
                icon: 'ðŸ“ˆ',
                requiresSecret: false,
                baseUrl: 'https://www.alphavantage.co/query',
                description: 'Dados de aÃ§Ãµes, forex e cripto (500 calls/dia grÃ¡tis)'
            },
            BINANCE: {
                name: 'Binance',
                icon: 'ðŸŸ¡',
                requiresSecret: true,
                baseUrl: 'https://api.binance.com/api/v3',
                description: 'Dados de criptomoedas em tempo real'
            },
            COINGECKO: {
                name: 'CoinGecko',
                icon: 'ðŸ¦Ž',
                requiresSecret: false,
                baseUrl: 'https://api.coingecko.com/api/v3',
                description: 'Dados de cripto (requer chave Demo API gratuita)'
            },
            POLYGON: {
                name: 'Polygon.io',
                icon: 'ðŸ”º',
                requiresSecret: false,
                baseUrl: 'https://api.polygon.io/v2',
                description: 'Dados de aÃ§Ãµes e forex premium'
            }
        };

        class APIConnectionManager {
            constructor() {
                this.connections = new Map();
                this.activeProvider = null;
                this.loadFromStorage();
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('api_connections');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.connections = new Map(Object.entries(data.connections || data));
                        this.activeProvider = data.activeProvider || null;
                    }
                } catch (error) {
                    console.log('Erro ao carregar conexÃµes:', error);
                }
            }

            saveToStorage() {
                try {
                    const data = {
                        connections: Object.fromEntries(this.connections),
                        activeProvider: this.activeProvider
                    };
                    localStorage.setItem('api_connections', JSON.stringify(data));
                } catch (error) {
                    console.log('Erro ao salvar conexÃµes:', error);
                }
            }

            addConnection(provider, apiKey, secretKey = null) {
                this.connections.set(provider, {
                    apiKey,
                    secretKey,
                    status: 'disconnected',
                    lastTested: null
                });
                this.saveToStorage();
            }

            removeConnection(provider) {
                this.connections.delete(provider);
                if (this.activeProvider === provider) {
                    this.activeProvider = null;
                }
                this.saveToStorage();
            }

            setActive(provider) {
                if (this.connections.has(provider)) {
                    this.activeProvider = provider;
                    this.saveToStorage();
                    return true;
                }
                return false;
            }

            getActiveConnection() {
                if (!this.activeProvider) return null;
                return {
                    provider: this.activeProvider,
                    ...this.connections.get(this.activeProvider)
                };
            }

            updateStatus(provider, status) {
                const conn = this.connections.get(provider);
                if (conn) {
                    conn.status = status;
                    conn.lastTested = new Date();
                    this.saveToStorage();
                }
            }
        }

        /* Continua na PARTE 2... */

        /* ========================================
           FUNÃ‡Ã•ES DE API
           ======================================== */

        async function fetchRealMarketData(provider, apiKey, symbol, timeframe, secretKey = null) {
            try {
                let url, response, data;

                switch(provider) {
                    case 'ALPHA_VANTAGE':
                        const avInterval = timeframe === 'M5' ? '5min' : '15min';
                        url = `${API_PROVIDERS.ALPHA_VANTAGE.baseUrl}?function=TIME_SERIES_INTRADAY&symbol=${symbol}&interval=${avInterval}&apikey=${apiKey}`;
                        response = await fetch(url);
                        data = await response.json();
                        
                        if (data['Error Message'] || data['Note']) {
                            throw new Error(data['Error Message'] || 'Limite de API atingido');
                        }
                        return parseAlphaVantageData(data, avInterval);

                    case 'BINANCE':
                        const interval = timeframe === 'M5' ? '5m' : '15m';
                        url = `${API_PROVIDERS.BINANCE.baseUrl}/klines?symbol=${symbol}&interval=${interval}&limit=200`;
                        response = await fetch(url);
                        data = await response.json();
                        
                        if (data.code) {
                            throw new Error(data.msg || 'Erro na API Binance');
                        }
                        return parseBinanceData(data);

                    case 'COINGECKO':
                        const symbolMap = {
                            'BTC': 'bitcoin', 'BTCUSDT': 'bitcoin',
                            'ETH': 'ethereum', 'ETHUSDT': 'ethereum',
                            'BNB': 'binancecoin', 'BNBUSDT': 'binancecoin'
                        };
                        
                        const coinId = symbolMap[symbol.toUpperCase()] || 'bitcoin';
                        url = `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=1`;
                        
                        response = await fetch(url);
                        if (response.ok) {
                            data = await response.json();
                            if (data.prices && data.prices.length > 0) {
                                return parseCoinGeckoData(data);
                            }
                        }
                        throw new Error('CoinGecko: Dados nÃ£o disponÃ­veis');

                    case 'POLYGON':
                        const multiplier = timeframe === 'M5' ? 5 : 15;
                        const to = new Date().toISOString().split('T')[0];
                        const from = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                        url = `${API_PROVIDERS.POLYGON.baseUrl}/aggs/ticker/${symbol}/range/${multiplier}/minute/${from}/${to}?apiKey=${apiKey}`;
                        response = await fetch(url);
                        data = await response.json();
                        
                        if (data.status === 'ERROR') {
                            throw new Error(data.error || 'Erro na API Polygon');
                        }
                        return parsePolygonData(data);

                    default:
                        throw new Error('Provider nÃ£o suportado');
                }
            } catch (error) {
                console.error('Erro ao buscar dados reais:', error);
                throw error;
            }
        }

        function parseAlphaVantageData(data, interval) {
            const timeSeriesKey = `Time Series (${interval})`;
            const timeSeries = data[timeSeriesKey];
            
            if (!timeSeries) {
                throw new Error('Dados nÃ£o encontrados');
            }

            const candles = [];
            for (const [timestamp, values] of Object.entries(timeSeries)) {
                candles.push({
                    timestamp: new Date(timestamp).getTime(),
                    open: parseFloat(values['1. open']),
                    high: parseFloat(values['2. high']),
                    low: parseFloat(values['3. low']),
                    close: parseFloat(values['4. close']),
                    volume: parseFloat(values['5. volume'])
                });
            }

            return candles.sort((a, b) => a.timestamp - b.timestamp).slice(-200);
        }

        function parseBinanceData(data) {
            return data.map(candle => ({
                timestamp: candle[0],
                open: parseFloat(candle[1]),
                high: parseFloat(candle[2]),
                low: parseFloat(candle[3]),
                close: parseFloat(candle[4]),
                volume: parseFloat(candle[5])
            }));
        }

        function parseCoinGeckoData(data) {
            return data.prices.slice(-200).map(point => {
                const price = point[1];
                return {
                    timestamp: point[0],
                    open: price,
                    high: price * 1.005,
                    low: price * 0.995,
                    close: price,
                    volume: 1000000
                };
            });
        }

        function parsePolygonData(data) {
            if (!data.results) throw new Error('Resultados nÃ£o encontrados');
            return data.results.map(candle => ({
                timestamp: candle.t,
                open: candle.o,
                high: candle.h,
                low: candle.l,
                close: candle.c,
                volume: candle.v
            }));
        }

        async function testAPIConnection(provider, apiKey, secretKey = null) {
            try {
                let testSymbol = 'BTCUSDT';
                if (provider === 'ALPHA_VANTAGE') testSymbol = 'IBM';
                else if (provider === 'COINGECKO') testSymbol = 'BTC';
                else if (provider === 'POLYGON') testSymbol = 'AAPL';
                
                await fetchRealMarketData(provider, apiKey, testSymbol, 'M5', secretKey);
                return { success: true, message: 'ConexÃ£o bem-sucedida!' };
            } catch (error) {
                return { 
                    success: false, 
                    message: `Falha na conexÃ£o: ${error.message}` 
                };
            }
        }

        /* ========================================
           SISTEMA DE EXECUÃ‡ÃƒO DE ORDENS
           ======================================== */

        class OrderExecutionManager {
            constructor(apiManager) {
                this.apiManager = apiManager;
                this.activePositions = new Map();
                this.executionHistory = [];
                this.systemLogs = [];
                this.maxPositions = 3;
                this.virtualBalance = 10000;
                this.loadFromStorage();
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('execution_manager_data');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.executionHistory = data.executionHistory || [];
                        this.virtualBalance = data.virtualBalance || 10000;
                        this.systemLogs = data.systemLogs || [];
                    }
                } catch (error) {
                    console.error('Erro ao carregar gerenciador:', error);
                }
            }

            saveToStorage() {
                try {
                    const data = {
                        executionHistory: this.executionHistory.slice(-100),
                        virtualBalance: this.virtualBalance,
                        systemLogs: this.systemLogs.slice(-200)
                    };
                    localStorage.setItem('execution_manager_data', JSON.stringify(data));
                } catch (error) {
                    console.error('Erro ao salvar gerenciador:', error);
                }
            }

            log(message, type = 'info') {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    message,
                    type
                };
                this.systemLogs.push(logEntry);
                
                if (this.systemLogs.length > 200) {
                    this.systemLogs = this.systemLogs.slice(-200);
                }
                
                this.saveToStorage();
                console.log(`[${type.toUpperCase()}] ${message}`);
            }

            async executeSignalAuto(signal, mode, riskAmount) {
                if (mode !== 'auto') {
                    this.log('Modo manual - execuÃ§Ã£o nÃ£o automÃ¡tica', 'info');
                    return {
                        success: false,
                        reason: 'manual_mode',
                        message: 'Modo manual ativo'
                    };
                }

                if (this.activePositions.size >= this.maxPositions) {
                    this.log(`Limite de ${this.maxPositions} posiÃ§Ãµes atingido`, 'warning');
                    return {
                        success: false,
                        reason: 'max_positions',
                        message: `MÃ¡ximo de ${this.maxPositions} posiÃ§Ãµes simultÃ¢neas atingido`
                    };
                }

                if (riskAmount > this.virtualBalance * 0.02) {
                    this.log(`Risco muito alto: R$${riskAmount} > 2% do saldo`, 'warning');
                    return {
                        success: false,
                        reason: 'risk_too_high',
                        message: 'Risco excede 2% do saldo disponÃ­vel'
                    };
                }

                if (riskAmount > this.virtualBalance) {
                    this.log('Saldo insuficiente', 'error');
                    return {
                        success: false,
                        reason: 'insufficient_balance',
                        message: 'Saldo insuficiente para executar ordem'
                    };
                }

                const activeConn = this.apiManager.getActiveConnection();
                
                if (!activeConn) {
                    this.log('Sem conexÃ£o ativa', 'error');
                    return {
                        success: false,
                        reason: 'no_connection',
                        message: 'Nenhuma conexÃ£o de API ativa'
                    };
                }

                this.log(`ðŸ¤– Iniciando execuÃ§Ã£o: ${signal.direction} ${signal.symbol}`, 'info');

                try {
                    let orderResult;
                    
                    switch(activeConn.provider) {
                        case 'BINANCE':
                            orderResult = await this.executeBinanceTestnetOrder(signal, activeConn, riskAmount);
                            break;
                        default:
                            orderResult = await this.executeSimulatedOrder(signal, riskAmount);
                            break;
                    }

                    if (orderResult.success) {
                        this.activePositions.set(signal.id, {
                            signal,
                            orderResult,
                            openTime: new Date(),
                            riskAmount
                        });

                        this.virtualBalance -= riskAmount;

                        this.recordExecution(signal, orderResult);
                        this.log(`âœ… Ordem executada: ${orderResult.orderId}`, 'success');
                        this.saveToStorage();
                    }

                    return orderResult;

                } catch (error) {
                    this.log(`âŒ Erro na execuÃ§Ã£o: ${error.message}`, 'error');
                    return {
                        success: false,
                        reason: 'execution_error',
                        message: error.message
                    };
                }
            }

            async executeBinanceTestnetOrder(signal, connection, riskAmount) {
                const TESTNET_URL = 'https://testnet.binance.vision/api/v3';
                
                try {
                    const quantity = this.calculatePositionSize(signal, riskAmount);
                    
                    const params = new URLSearchParams({
                        symbol: signal.symbol,
                        side: signal.direction,
                        type: 'MARKET',
                        quantity: quantity.toString(),
                        timestamp: Date.now()
                    });

                    const signature = await this.signBinanceRequest(params.toString(), connection.secretKey);
                    params.append('signature', signature);

                    const response = await fetch(`${TESTNET_URL}/order?${params.toString()}`, {
                        method: 'POST',
                        headers: {
                            'X-MBX-APIKEY': connection.apiKey
                        }
                    });

                    const data = await response.json();

                    if (response.ok) {
                        return {
                            success: true,
                            orderId: data.orderId,
                            executedQty: data.executedQty,
                            executedPrice: data.fills?.[0]?.price || signal.price,
                            commission: data.fills?.[0]?.commission || 0,
                            timestamp: data.transactTime
                        };
                    } else {
                        throw new Error(data.msg || 'Erro ao executar ordem Binance');
                    }

                } catch (error) {
                    this.log(`Fallback para simulaÃ§Ã£o: ${error.message}`, 'warning');
                    return await this.executeSimulatedOrder(signal, riskAmount);
                }
            }

            async executeSimulatedOrder(signal, riskAmount) {
                const slippage = (Math.random() * 0.001) + 0.0005;
                const executedPrice = signal.direction === 'BUY' 
                    ? signal.price * (1 + slippage)
                    : signal.price * (1 - slippage);

                const quantity = this.calculatePositionSize(signal, riskAmount);

                await new Promise(resolve => setTimeout(resolve, 100));

                return {
                    success: true,
                    orderId: 'SIM-' + Date.now(),
                    executedQty: quantity,
                    executedPrice: executedPrice,
                    commission: (executedPrice * quantity) * 0.001,
                    timestamp: Date.now(),
                    simulated: true
                };
            }

            calculatePositionSize(signal, riskAmount) {
                const riskPercentage = Math.abs((signal.price - signal.stopLoss) / signal.price);
                const quantity = (riskAmount / signal.price) / riskPercentage;
                return Math.floor(quantity * 1000000) / 1000000;
            }

            async signBinanceRequest(queryString, secretKey) {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(secretKey);
                const messageData = encoder.encode(queryString);
                
                const key = await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );
                
                const signature = await crypto.subtle.sign('HMAC', key, messageData);
                const hashArray = Array.from(new Uint8Array(signature));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            closePosition(signalId, result, pnl) {
                const position = this.activePositions.get(signalId);
                
                if (position) {
                    this.virtualBalance += position.riskAmount + pnl;
                    
                    this.activePositions.delete(signalId);
                    this.log(`ðŸ“Š PosiÃ§Ã£o fechada: ${result} | P&L: R$${pnl.toFixed(2)}`, 
                        pnl >= 0 ? 'success' : 'warning');
                    this.saveToStorage();
                }
            }

            emergencyCloseAll() {
                this.log('ðŸš¨ FECHAMENTO DE EMERGÃŠNCIA ACIONADO', 'error');
                
                const closedPositions = [];
                this.activePositions.forEach((position, signalId) => {
                    this.virtualBalance += position.riskAmount;
                    closedPositions.push(signalId);
                    this.log(`ðŸ›‘ PosiÃ§Ã£o ${signalId} fechada por emergÃªncia`, 'warning');
                });

                this.activePositions.clear();
                this.saveToStorage();

                return closedPositions;
            }

            recordExecution(signal, orderResult) {
                const execution = {
                    signalId: signal.id,
                    timestamp: new Date().toISOString(),
                    symbol: signal.symbol,
                    direction: signal.direction,
                    orderResult: orderResult,
                    signal: {
                        score: signal.score,
                        price: signal.price,
                        stopLoss: signal.stopLoss,
                        takeProfit: signal.takeProfit
                    }
                };

                this.executionHistory.push(execution);
                
                if (this.executionHistory.length > 100) {
                    this.executionHistory = this.executionHistory.slice(-100);
                }
                
                this.saveToStorage();
            }

            getExecutionHistory() {
                return [...this.executionHistory];
            }

            getSystemLogs() {
                return [...this.systemLogs];
            }

            getActivePositions() {
                return Array.from(this.activePositions.values());
            }

            getVirtualBalance() {
                return this.virtualBalance;
            }

            setMaxPositions(max) {
                this.maxPositions = Math.max(1, Math.min(10, max));
                this.log(`Limite de posiÃ§Ãµes alterado para ${this.maxPositions}`, 'info');
                this.saveToStorage();
            }
        }

        /* ========================================
           SISTEMA DE AUDITORIA (CORRIGIDO)
           ======================================== */

        class AuditSystem {
            constructor() {
                this.auditLogs = [];
                this.performanceByHour = {};
                this.performanceByScore = {};
                this.indicatorPerformance = {};
                this.listeners = new Set(); // NOVO: Para notificar mudanÃ§as
                this.loadFromStorage();
            }

            // NOVO: MÃ©todo para registrar listeners
            addChangeListener(callback) {
                this.listeners.add(callback);
            }

            removeChangeListener(callback) {
                this.listeners.delete(callback);
            }

            notifyChange() {
                this.listeners.forEach(callback => {
                    try {
                        callback();
                    } catch (error) {
                        console.error('Erro ao notificar listener:', error);
                    }
                });
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('audit_system_data');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.auditLogs = data.auditLogs || [];
                        this.performanceByHour = data.performanceByHour || {};
                        this.performanceByScore = data.performanceByScore || {};
                        this.indicatorPerformance = data.indicatorPerformance || {};
                        
                        if (window.debugAudit) {
                            console.log('ðŸ“‚ [AUDIT] Dados carregados:', {
                                logs: this.auditLogs.length,
                                lastSaved: data.lastSaved || 'N/A'
                            });
                        }
                    } else {
                        if (window.debugAudit) {
                            console.log('ðŸ“‚ [AUDIT] Nenhum dado anterior encontrado');
                        }
                    }
                } catch (e) {
                    console.error('âŒ [AUDIT] Erro ao carregar auditoria:', e);
                }
            }

            saveToStorage() {
                try {
                    const data = {
                        auditLogs: this.auditLogs.slice(-500),
                        performanceByHour: this.performanceByHour,
                        performanceByScore: this.performanceByScore,
                        indicatorPerformance: this.indicatorPerformance,
                        lastSaved: new Date().toISOString()
                    };
                    localStorage.setItem('audit_system_data', JSON.stringify(data));
                    
                    if (window.debugAudit) {
                        console.log('ðŸ’¾ [AUDIT] Dados salvos:', {
                            logs: this.auditLogs.length,
                            timestamp: data.lastSaved
                        });
                    }
                    
                    this.notifyChange(); // NOVO: Notificar mudanÃ§as
                } catch (e) {
                    console.error('âŒ [AUDIT] Erro ao salvar auditoria:', e);
                }
            }

            logSignalGeneration(signal, currentPrice, indicators) {
                if (window.debugAudit) {
                    console.log('ðŸ” [AUDIT] logSignalGeneration chamado:', {
                        signalId: signal.id,
                        price: signal.price,
                        currentPrice: currentPrice.close
                    });
                }

                const candleCloseTime = new Date(signal.timestamp);
                candleCloseTime.setSeconds(0, 0);
                candleCloseTime.setMinutes(Math.floor(candleCloseTime.getMinutes() / 5) * 5 + 5);

                const log = {
                    signalId: signal.id,
                    generatedAt: signal.timestamp.toISOString(),
                    candleCloseTime: candleCloseTime.toISOString(),
                    timeDifference: (candleCloseTime - signal.timestamp) / 1000,
                    
                    prices: {
                        theoretical: signal.price,
                        actualEntry: null,
                        slippage: null,
                        actualExit: null,
                        finalPnL: null
                    },
                    
                    indicators: this.formatIndicators(signal, indicators),
                    
                    scoreRange: this.getScoreRange(signal.score),
                    hourOfDay: signal.timestamp.getHours(),
                    
                    outcome: null,
                    outcomeTime: null,
                    reason: null,
                    
                    metadata: {
                        direction: signal.direction,
                        symbol: signal.symbol,
                        timeframe: signal.timeframe,
                        dataSource: signal.dataSource,
                        hasDivergence: signal.divergence ? true : false
                    }
                };

                this.auditLogs.push(log);
                if (this.auditLogs.length > 500) {
                    this.auditLogs = this.auditLogs.slice(-500);
                }
                
                this.saveToStorage();
                
                if (window.debugAudit) {
                    console.log('âœ… [AUDIT] Log salvo. Total de logs:', this.auditLogs.length);
                }
                
                return log;
            }

            formatIndicators(signal, indicators) {
                const formatted = {};
                
                signal.contributors.forEach(indicator => {
                    formatted[indicator] = {
                        weight: indicators.weights ? indicators.weights[indicator] : 0,
                        contribution: 0
                    };
                });

                return formatted;
            }

            getScoreRange(score) {
                if (score >= 90) return '90-100';
                if (score >= 80) return '80-89';
                if (score >= 70) return '70-79';
                if (score >= 60) return '60-69';
                if (score >= 50) return '50-59';
                return '0-49';
            }

            updateSignalOutcome(signalId, outcome, finalPrice, pnl, executionDetails = null) {
                if (window.debugAudit) {
                    console.log('ðŸ” [AUDIT] updateSignalOutcome chamado:', {
                        signalId,
                        outcome,
                        finalPrice,
                        pnl
                    });
                }

                const log = this.auditLogs.find(l => l.signalId === signalId);
                
                if (log) {
                    log.outcome = outcome;
                    log.outcomeTime = new Date().toISOString();
                    log.prices.actualExit = finalPrice;
                    log.prices.finalPnL = pnl;
                    
                    if (executionDetails) {
                        log.prices.actualEntry = executionDetails.executedPrice;
                        log.prices.slippage = Math.abs(executionDetails.executedPrice - log.prices.theoretical);
                    }

                    const duration = (new Date(log.outcomeTime) - new Date(log.generatedAt)) / 60000;
                    log.reason = this.determineReason(outcome, duration);

                    this.updateStatistics(log);
                    this.saveToStorage();
                    
                    if (window.debugAudit) {
                        console.log('âœ… [AUDIT] Outcome atualizado com sucesso');
                    }
                } else {
                    if (window.debugAudit) {
                        console.error('âŒ [AUDIT] Log nÃ£o encontrado para signalId:', signalId);
                    }
                }
            }

            determineReason(outcome, durationMinutes) {
                if (outcome === 'ACERTO') {
                    return `Atingiu take profit em ${Math.floor(durationMinutes)}min`;
                } else if (outcome === 'ERRO') {
                    return `Atingiu stop loss em ${Math.floor(durationMinutes)}min`;
                } else if (outcome === 'EXPIRADO') {
                    return `Expirou apÃ³s ${Math.floor(durationMinutes)}min sem atingir alvos`;
                } else if (outcome === 'CANCELADO') {
                    return 'Cancelado manualmente';
                }
                return 'Desconhecido';
            }

            updateStatistics(log) {
                if (!log.outcome || log.outcome === 'PENDENTE') return;

                const hour = log.hourOfDay;
                if (!this.performanceByHour[hour]) {
                    this.performanceByHour[hour] = { total: 0, wins: 0, losses: 0, expired: 0, totalPnL: 0 };
                }
                this.performanceByHour[hour].total++;
                if (log.outcome === 'ACERTO') this.performanceByHour[hour].wins++;
                else if (log.outcome === 'ERRO') this.performanceByHour[hour].losses++;
                else if (log.outcome === 'EXPIRADO') this.performanceByHour[hour].expired++;
                this.performanceByHour[hour].totalPnL += log.prices.finalPnL || 0;

                const scoreRange = log.scoreRange;
                if (!this.performanceByScore[scoreRange]) {
                    this.performanceByScore[scoreRange] = { total: 0, wins: 0, losses: 0, expired: 0 };
                }
                this.performanceByScore[scoreRange].total++;
                if (log.outcome === 'ACERTO') this.performanceByScore[scoreRange].wins++;
                else if (log.outcome === 'ERRO') this.performanceByScore[scoreRange].losses++;
                else if (log.outcome === 'EXPIRADO') this.performanceByScore[scoreRange].expired++;

                Object.keys(log.indicators).forEach(indicator => {
                    if (!this.indicatorPerformance[indicator]) {
                        this.indicatorPerformance[indicator] = { total: 0, wins: 0, losses: 0 };
                    }
                    this.indicatorPerformance[indicator].total++;
                    if (log.outcome === 'ACERTO') this.indicatorPerformance[indicator].wins++;
                    else if (log.outcome === 'ERRO') this.indicatorPerformance[indicator].losses++;
                });
            }

            getHealthAlerts() {
                const alerts = [];
                const recentLogs = this.auditLogs.slice(-20).filter(l => l.outcome && l.outcome !== 'PENDENTE');

                if (recentLogs.length >= 10) {
                    const winRate = (recentLogs.filter(l => l.outcome === 'ACERTO').length / recentLogs.length) * 100;
                    
                    if (winRate < 40) {
                        alerts.push({
                            type: 'error',
                            message: `Taxa de acerto crÃ­tica: ${winRate.toFixed(1)}% nos Ãºltimos ${recentLogs.length} sinais`
                        });
                    } else if (winRate < 50) {
                        alerts.push({
                            type: 'warning',
                            message: `Taxa de acerto baixa: ${winRate.toFixed(1)}% nos Ãºltimos ${recentLogs.length} sinais`
                        });
                    }
                }

                return alerts;
            }

            getPerformanceByHour() {
                return this.performanceByHour;
            }

            getPerformanceByScore() {
                return this.performanceByScore;
            }

            getIndicatorPerformance() {
                return this.indicatorPerformance;
            }

            getRecentLogs(limit = 50) {
                return this.auditLogs.slice(-limit).reverse();
            }

            exportToCSV() {
                const headers = [
                    'ID', 'Gerado Em', 'HorÃ¡rio', 'SÃ­mbolo', 'DireÃ§Ã£o', 'Score',
                    'PreÃ§o TeÃ³rico', 'PreÃ§o Entrada', 'Slippage', 'PreÃ§o SaÃ­da',
                    'P&L', 'Resultado', 'Motivo', 'Fonte Dados'
                ];

                const rows = this.auditLogs.map(log => {
                    return [
                        log.signalId,
                        new Date(log.generatedAt).toLocaleString('pt-BR'),
                        log.hourOfDay + 'h',
                        log.metadata.symbol,
                        log.metadata.direction,
                        log.scoreRange,
                        log.prices.theoretical ? log.prices.theoretical.toFixed(2) : 'N/A',
                        log.prices.actualEntry ? log.prices.actualEntry.toFixed(2) : 'N/A',
                        log.prices.slippage ? log.prices.slippage.toFixed(2) : 'N/A',
                        log.prices.actualExit ? log.prices.actualExit.toFixed(2) : 'N/A',
                        log.prices.finalPnL !== null && log.prices.finalPnL !== undefined ? log.prices.finalPnL.toFixed(2) : '0.00',
                        log.outcome || 'PENDENTE',
                        (log.reason || 'Em andamento').replace(/,/g, ';'),
                        log.metadata.dataSource
                    ];
                });

                let csv = headers.join(',') + '\n';
                rows.forEach(row => {
                    const escapedRow = row.map(value => {
                        const strValue = String(value);
                        if (strValue.includes(',')) {
                            return `"${strValue}"`;
                        }
                        return strValue;
                    });
                    csv += escapedRow.join(',') + '\n';
                });

                return csv;
            }

            clearOldData(daysToKeep = 7) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
                
                this.auditLogs = this.auditLogs.filter(log => 
                    new Date(log.generatedAt) > cutoffDate
                );
                
                this.saveToStorage();
            }

            validateData() {
                console.log('ðŸ” === VALIDAÃ‡ÃƒO DOS DADOS DE AUDITORIA ===');
                console.log(`Total de logs: ${this.auditLogs.length}`);
                
                const withOutcome = this.auditLogs.filter(l => l.outcome && l.outcome !== 'PENDENTE');
                const acertos = withOutcome.filter(l => l.outcome === 'ACERTO');
                const erros = withOutcome.filter(l => l.outcome === 'ERRO');
                const expirados = withOutcome.filter(l => l.outcome === 'EXPIRADO');
                
                console.log(`\nCom resultado: ${withOutcome.length}`);
                console.log(`  ACERTO: ${acertos.length}`);
                console.log(`  ERRO: ${erros.length}`);
                console.log(`  EXPIRADO: ${expirados.length}`);
                
                const withPnL = this.auditLogs.filter(l => l.prices.finalPnL !== null && l.prices.finalPnL !== 0);
                console.log(`\nCom P&L diferente de zero: ${withPnL.length}`);
                
                if (withOutcome.length === 0) {
                    console.warn('âš ï¸ NENHUM log tem resultado final!');
                }
                
                if (expirados.length > withOutcome.length * 0.8) {
                    console.warn(`âš ï¸ ${(expirados.length/withOutcome.length*100).toFixed(1)}% dos sinais estÃ£o EXPIRANDO!`);
                    console.warn('   PossÃ­veis problemas:');
                    console.warn('   - Alvos muito distantes');
                    console.warn('   - Timeout muito curto');
                    console.warn('   - Sistema de monitoramento nÃ£o estÃ¡ funcionando');
                }
                
                return {
                    total: this.auditLogs.length,
                    withOutcome: withOutcome.length,
                    acertos: acertos.length,
                    erros: erros.length,
                    expirados: expirados.length,
                    withPnL: withPnL.length
                };
            }
        }

        /* Continua na PARTE 3... */

        // ========================================
        // âœ… MEMORYDB COM SUPABASE
        // ========================================
        
        class MemoryDB {
            constructor() {
                this.signals_history = [];
                this.ml_weights_evolution = [];
                this.config_snapshots = [];
                this.listeners = new Set();
                this.isInitialized = false;
            }

            async init() {
                if (this.isInitialized) return;
                
                try {
                    // Carregar sinais do Supabase
                    const { data: signals, error: signalsError } = await supabase
                        .from('signals')
                        .select('*')
                        .order('timestamp', { ascending: false })
                        .limit(200);

                    if (signalsError) throw signalsError;

                    // Converter para formato da aplicaÃ§Ã£o
                    this.signals_history = (signals || []).map(s => ({
                        id: s.id,
                        timestamp: new Date(s.timestamp),
                        symbol: s.symbol,
                        direction: s.direction,
                        timeframe: s.timeframe,
                        score: s.score,
                        price: parseFloat(s.price),
                        stopLoss: parseFloat(s.stop_loss),
                        takeProfit: parseFloat(s.take_profit),
                        riskReward: s.risk_reward ? parseFloat(s.risk_reward) : 2,
                        status: s.status,
                        pnl: s.pnl ? parseFloat(s.pnl) : 0,
                        finalPrice: s.final_price ? parseFloat(s.final_price) : null,
                        entryTime: s.entry_time ? new Date(s.entry_time) : null,
                        contributors: s.contributors,
                        divergence: s.divergence,
                        features: s.features,
                        dataSource: s.data_source,
                        executed: s.executed || false,
                        executionDetails: s.execution_details,
                        tpslDetails: s.tpsl_details,
                        savedAt: s.saved_at
                    }));

                    // Carregar pesos ML
                    const { data: weights, error: weightsError } = await supabase
                        .from('ml_weights_evolution')
                        .select('*')
                        .order('created_at', { ascending: false })
                        .limit(50);

                    if (weightsError) throw weightsError;

                    this.ml_weights_evolution = (weights || []).map(w => ({
                        date: w.created_at,
                        weights: w.weights,
                        performance: w.performance
                    }));

                    this.isInitialized = true;
                    console.log('âœ… MemoryDB carregado do Supabase:', this.signals_history.length, 'sinais');

                } catch (error) {
                    console.error('âŒ Erro ao carregar MemoryDB:', error);
                    this.isInitialized = true; // Continuar mesmo com erro
                }
            }

            addChangeListener(callback) {
                this.listeners.add(callback);
            }

            removeChangeListener(callback) {
                this.listeners.delete(callback);
            }

            notifyChange() {
                this.listeners.forEach(callback => {
                    try {
                        callback();
                    } catch (error) {
                        console.error('Erro ao notificar listener:', error);
                    }
                });
            }

            async saveSignal(signal) {
                try {
                    // Salvar no Supabase
                    const { error } = await supabase
                        .from('signals')
                        .upsert({
                            id: signal.id,
                            timestamp: signal.timestamp.toISOString(),
                            symbol: signal.symbol,
                            direction: signal.direction,
                            timeframe: signal.timeframe,
                            score: signal.score,
                            price: signal.price,
                            stop_loss: signal.stopLoss,
                            take_profit: signal.takeProfit,
                            risk_reward: signal.riskReward,
                            status: signal.status || 'PENDENTE',
                            pnl: signal.pnl || 0,
                            final_price: signal.finalPrice,
                            entry_time: signal.entryTime,
                            contributors: signal.contributors,
                            divergence: signal.divergence,
                            features: signal.features,
                            data_source: signal.dataSource,
                            executed: signal.executed || false,
                            execution_details: signal.executionDetails,
                            tpsl_details: signal.tpslDetails,
                            saved_at: new Date().toISOString()
                        });

                    if (error) throw error;

                    // Adicionar ao array local
                    this.signals_history.push({
                        ...signal,
                        savedAt: new Date().toISOString()
                    });

                    console.log('ðŸ’¾ Sinal salvo no Supabase:', signal.id);
                    this.notifyChange();

                } catch (error) {
                    console.error('âŒ Erro ao salvar sinal:', error);
                }
            }

            async getAllSignals() {
                if (!this.isInitialized) await this.init();
                return [...this.signals_history];
            }

            async saveWeightsSnapshot(weights, performance) {
                try {
                    const { error } = await supabase
                        .from('ml_weights_evolution')
                        .insert({
                            weights: weights,
                            performance: performance
                        });

                    if (error) throw error;

                    const snapshot = {
                        date: new Date().toISOString(),
                        weights: { ...weights },
                        performance: { ...performance }
                    };

                    this.ml_weights_evolution.push(snapshot);
                    this.notifyChange();

                    console.log('ðŸ’¾ Pesos ML salvos no Supabase');

                } catch (error) {
                    console.error('âŒ Erro ao salvar pesos:', error);
                }
            }

            async getWeightsHistory() {
                if (!this.isInitialized) await this.init();
                return [...this.ml_weights_evolution];
            }

            async getStatistics() {
                try {
                    const { data, error } = await supabase
                        .from('signals')
                        .select('status, pnl');

                    if (error) throw error;

                    const signals = data || [];
                    const total = signals.length;
                    const completed = signals.filter(s => s.status !== 'PENDENTE').length;
                    const successful = signals.filter(s => s.status === 'ACERTO').length;
                    const totalPnL = signals.reduce((sum, s) => sum + parseFloat(s.pnl || 0), 0);

                    return {
                        total,
                        completed,
                        successful,
                        winRate: completed > 0 ? (successful / completed) * 100 : 0,
                        totalPnL
                    };

                } catch (error) {
                    console.error('âŒ Erro ao calcular estatÃ­sticas:', error);
                    return {
                        total: 0,
                        completed: 0,
                        successful: 0,
                        winRate: 0,
                        totalPnL: 0
                    };
                }
            }
        }
        class MarketDataSimulator {
            constructor() {
                this.prices = [];
                this.timeframe = 'M5';
                this.lastPriceCheck = null;
                this.stuckPriceCount = 0;
                this.generateInitialData();
            }

            generateInitialData() {
                const basePrice = 50000;
                for (let i = 0; i < 200; i++) {
                    const timestamp = Date.now() - (200 - i) * 5 * 60 * 1000;
                    const price = basePrice + Math.sin(i * 0.1) * 1000 + Math.random() * 200 - 100;
                    this.prices.push({
                        timestamp,
                        open: price,
                        high: price + Math.random() * 50,
                        low: price - Math.random() * 50,
                        close: price + (Math.random() - 0.5) * 30,
                        volume: Math.random() * 1000000
                    });
                }
                console.log('ðŸ“Š MarketData inicializado com', this.prices.length, 'candles');
            }

            getLatestPrice() {
                const latestPrice = this.prices[this.prices.length - 1];
                
                if (this.lastPriceCheck && this.lastPriceCheck.close === latestPrice.close) {
                    this.stuckPriceCount++;
                    if (this.stuckPriceCount > 3) {
                        console.warn('âš ï¸ PREÃ‡O TRAVADO detectado! Mesmo preÃ§o por', this.stuckPriceCount, 'verificaÃ§Ãµes');
                        console.warn('   Ãšltimo preÃ§o:', latestPrice.close);
                        console.warn('   ForÃ§ando atualizaÃ§Ã£o...');
                        this.addNewCandle();
                        this.stuckPriceCount = 0;
                    }
                } else {
                    this.stuckPriceCount = 0;
                }
                
                this.lastPriceCheck = { ...latestPrice };
                return latestPrice;
            }

            addNewCandle() {
                const lastCandle = this.prices[this.prices.length - 1];
                const volatility = 150;
                const trend = (Math.random() - 0.5) * volatility;
                const newPrice = lastCandle.close + trend;
                
                const newCandle = {
                    timestamp: Date.now(),
                    open: newPrice,
                    high: newPrice + Math.random() * 50,
                    low: newPrice - Math.random() * 50,
                    close: newPrice + (Math.random() - 0.5) * 40,
                    volume: Math.random() * 1000000
                };
                
                this.prices.push(newCandle);
                if (this.prices.length > 200) {
                    this.prices.shift();
                }
                
                if (window.debugAudit && Math.random() < 0.1) {
                    console.log('ðŸ“ˆ Novo candle:', newCandle.close.toFixed(2), 'VariaÃ§Ã£o:', trend.toFixed(2));
                }
                
                return newCandle;
            }

            replaceWithRealData(realData) {
                if (realData && realData.length > 0) {
                    this.prices = [...realData];
                    console.log('âœ… Dados REAIS carregados:', realData.length, 'candles');
                    console.log('   Primeiro preÃ§o:', realData[0].close);
                    console.log('   Ãšltimo preÃ§o:', realData[realData.length - 1].close);
                    return true;
                }
                return false;
            }
        }

        class TechnicalIndicators {
            static calculateRSI(prices, period = 14) {
                if (prices.length < period + 1) return 50;
                
                let gains = 0;
                let losses = 0;
                
                for (let i = prices.length - period; i < prices.length; i++) {
                    const change = prices[i].close - prices[i - 1].close;
                    if (change > 0) gains += change;
                    else losses -= change;
                }
                
                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            static calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                if (prices.length < slowPeriod) return { macd: 0, signal: 0, histogram: 0 };
                
                const fastEMA = this.calculateEMA(prices.slice(-fastPeriod).map(p => p.close), fastPeriod);
                const slowEMA = this.calculateEMA(prices.slice(-slowPeriod).map(p => p.close), slowPeriod);
                const macd = fastEMA - slowEMA;
                
                return { macd, signal: macd * 0.9, histogram: macd * 0.1 };
            }

            static calculateEMA(values, period) {
                const k = 2 / (period + 1);
                let ema = values[0];
                for (let i = 1; i < values.length; i++) {
                    ema = values[i] * k + ema * (1 - k);
                }
                return ema;
            }

            static calculateBollingerBands(prices, period = 20, stdDev = 2) {
                if (prices.length < period) return { upper: 0, middle: 0, lower: 0 };
                
                const recentPrices = prices.slice(-period).map(p => p.close);
                const sma = recentPrices.reduce((a, b) => a + b) / period;
                
                const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
                const sd = Math.sqrt(variance);
                
                return {
                    upper: sma + (sd * stdDev),
                    middle: sma,
                    lower: sma - (sd * stdDev)
                };
            }

            static calculateStochastic(prices, kPeriod = 14, dPeriod = 3) {
                if (prices.length < kPeriod) return { k: 50, d: 50 };
                
                const recentPrices = prices.slice(-kPeriod);
                const highestHigh = Math.max(...recentPrices.map(p => p.high));
                const lowestLow = Math.min(...recentPrices.map(p => p.low));
                const currentClose = prices[prices.length - 1].close;
                
                const k = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
                const d = k * 0.95;
                
                return { k, d };
            }

            static calculateATR(prices, period = 14) {
                if (prices.length < period + 1) return prices[prices.length - 1].close * 0.02;
                
                let trSum = 0;
                for (let i = prices.length - period; i < prices.length; i++) {
                    const high = prices[i].high;
                    const low = prices[i].low;
                    const prevClose = prices[i - 1].close;
                    
                    const tr = Math.max(
                        high - low,
                        Math.abs(high - prevClose),
                        Math.abs(low - prevClose)
                    );
                    trSum += tr;
                }
                
                return trSum / period;
            }

            // âœ¨ NOVO: Volume Profile
            static analyzeVolume(prices, period = 20) {
                if (prices.length < period) {
                    return {
                        avgVolume: 0,
                        volumeTrend: 'neutral',
                        volumeStrength: 0,
                        isAnomalous: false
                    };
                }

                const recentPrices = prices.slice(-period);
                const volumes = recentPrices.map(p => p.volume);
                const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
                
                const currentVolume = prices[prices.length - 1].volume;
                const volumeRatio = currentVolume / avgVolume;
                
                const isAnomalous = volumeRatio > 2.0;
                
                const recent5 = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
                const previous5 = volumes.slice(-10, -5).reduce((a, b) => a + b, 0) / 5;
                
                let volumeTrend = 'neutral';
                if (recent5 > previous5 * 1.2) volumeTrend = 'increasing';
                else if (recent5 < previous5 * 0.8) volumeTrend = 'decreasing';
                
                const volumeStrength = Math.min(1, volumeRatio / 2);
                
                return {
                    avgVolume,
                    currentVolume,
                    volumeRatio,
                    volumeTrend,
                    volumeStrength,
                    isAnomalous
                };
            }

            // âœ¨ NOVO: On-Balance Volume (OBV)
            static calculateOBV(prices) {
                if (prices.length < 2) return { obv: 0, trend: 'neutral', strength: 0 };

                let obv = 0;
                const obvValues = [0];
                
                for (let i = 1; i < prices.length; i++) {
                    if (prices[i].close > prices[i - 1].close) {
                        obv += prices[i].volume;
                    } else if (prices[i].close < prices[i - 1].close) {
                        obv -= prices[i].volume;
                    }
                    obvValues.push(obv);
                }
                
                const obvEMA20 = this.calculateEMA(obvValues.slice(-20), 20);
                const obvEMA5 = this.calculateEMA(obvValues.slice(-5), 5);
                
                let trend = 'neutral';
                let strength = 0;
                
                if (obvEMA5 > obvEMA20 * 1.05) {
                    trend = 'bullish';
                    strength = Math.min(1, (obvEMA5 - obvEMA20) / obvEMA20);
                } else if (obvEMA5 < obvEMA20 * 0.95) {
                    trend = 'bearish';
                    strength = Math.min(1, (obvEMA20 - obvEMA5) / obvEMA20);
                }
                
                const priceTrend = prices[prices.length - 1].close > prices[prices.length - 20]?.close ? 'up' : 'down';
                const obvTrendDirection = obvValues[obvValues.length - 1] > obvValues[obvValues.length - 20] ? 'up' : 'down';
                
                const divergence = priceTrend !== obvTrendDirection;
                
                return {
                    obv: obvValues[obvValues.length - 1],
                    trend,
                    strength,
                    divergence,
                    signal: this.getOBVSignal(trend, divergence)
                };
            }

            static getOBVSignal(trend, divergence) {
                if (divergence) {
                    return trend === 'bullish' ? 'hidden_bullish' : 'hidden_bearish';
                }
                if (trend === 'bullish') return 'bullish_confirmation';
                if (trend === 'bearish') return 'bearish_confirmation';
                return 'neutral';
            }

            // âœ¨ NOVO: Ichimoku Cloud
            static calculateIchimoku(prices, tenkanPeriod = 9, kijunPeriod = 26, senkouBPeriod = 52) {
                if (prices.length < senkouBPeriod) {
                    return {
                        tenkanSen: 0,
                        kijunSen: 0,
                        senkouSpanA: 0,
                        senkouSpanB: 0,
                        chikouSpan: 0,
                        signal: 'neutral',
                        strength: 0,
                        cloudColor: 'neutral'
                    };
                }

                const tenkanHigh = Math.max(...prices.slice(-tenkanPeriod).map(p => p.high));
                const tenkanLow = Math.min(...prices.slice(-tenkanPeriod).map(p => p.low));
                const tenkanSen = (tenkanHigh + tenkanLow) / 2;

                const kijunHigh = Math.max(...prices.slice(-kijunPeriod).map(p => p.high));
                const kijunLow = Math.min(...prices.slice(-kijunPeriod).map(p => p.low));
                const kijunSen = (kijunHigh + kijunLow) / 2;

                const senkouSpanA = (tenkanSen + kijunSen) / 2;

                const senkouBHigh = Math.max(...prices.slice(-senkouBPeriod).map(p => p.high));
                const senkouBLow = Math.min(...prices.slice(-senkouBPeriod).map(p => p.low));
                const senkouSpanB = (senkouBHigh + senkouBLow) / 2;

                const chikouSpan = prices[prices.length - 1].close;

                const currentPrice = prices[prices.length - 1].close;
                
                const cloudColor = senkouSpanA > senkouSpanB ? 'bullish' : 'bearish';
                
                let signal = 'neutral';
                let strength = 0;
                
                if (currentPrice > Math.max(senkouSpanA, senkouSpanB)) {
                    signal = 'bullish';
                    strength = 0.7;
                    
                    if (tenkanSen > kijunSen) {
                        signal = 'strong_bullish';
                        strength = 0.9;
                    }
                } else if (currentPrice < Math.min(senkouSpanA, senkouSpanB)) {
                    signal = 'bearish';
                    strength = 0.7;
                    
                    if (tenkanSen < kijunSen) {
                        signal = 'strong_bearish';
                        strength = 0.9;
                    }
                } else {
                    signal = 'inside_cloud';
                    strength = 0.3;
                }
                
                const chikouAbovePrice = chikouSpan > prices[prices.length - kijunPeriod]?.close;
                
                return {
                    tenkanSen,
                    kijunSen,
                    senkouSpanA,
                    senkouSpanB,
                    chikouSpan,
                    signal,
                    strength,
                    cloudColor,
                    tkCross: tenkanSen > kijunSen ? 'bullish' : 'bearish',
                    chikouConfirmation: chikouAbovePrice,
                    priceVsCloud: currentPrice > Math.max(senkouSpanA, senkouSpanB) ? 'above' :
                                 currentPrice < Math.min(senkouSpanA, senkouSpanB) ? 'below' : 'inside'
                };
            }

            // âœ¨ NOVO: Volume Weighted Average Price (VWAP)
            static calculateVWAP(prices, period = 20) {
                if (prices.length < period) {
                    return { vwap: prices[prices.length - 1].close, signal: 'neutral' };
                }

                const recentPrices = prices.slice(-period);
                
                let sumPriceVolume = 0;
                let sumVolume = 0;
                
                recentPrices.forEach(candle => {
                    const typicalPrice = (candle.high + candle.low + candle.close) / 3;
                    sumPriceVolume += typicalPrice * candle.volume;
                    sumVolume += candle.volume;
                });
                
                const vwap = sumPriceVolume / sumVolume;
                const currentPrice = prices[prices.length - 1].close;
                
                let signal = 'neutral';
                const deviation = ((currentPrice - vwap) / vwap) * 100;
                
                if (deviation > 0.5) signal = 'above_vwap';
                else if (deviation < -0.5) signal = 'below_vwap';
                
                return {
                    vwap,
                    currentPrice,
                    deviation,
                    signal,
                    strength: Math.min(1, Math.abs(deviation) / 2)
                };
            }
        }
        /* ========================================
   OTIMIZADOR DE TP/SL DINÃ‚MICO
   ======================================== */

class TPSLOptimizer {
    constructor(auditSystem) {
        this.auditSystem = auditSystem;
        this.optimalRatios = {
            'M5': { tp: 3.5, sl: 1.5 },
            'M15': { tp: 4.0, sl: 1.8 }
        };
        this.volatilityCache = new Map();
        this.loadOptimalRatios();
    }

    loadOptimalRatios() {
        try {
            const saved = localStorage.getItem('tpsl_optimal_ratios');
            if (saved) {
                const data = JSON.parse(saved);
                this.optimalRatios = data;
                console.log('âœ… Ratios TP/SL carregados:', this.optimalRatios);
            }
        } catch (error) {
            console.error('Erro ao carregar ratios:', error);
        }
    }

    saveOptimalRatios() {
        try {
            localStorage.setItem('tpsl_optimal_ratios', JSON.stringify(this.optimalRatios));
        } catch (error) {
            console.error('Erro ao salvar ratios:', error);
        }
    }

    calculateVolatility(prices, period = 20) {
        if (prices.length < period) return 0.02;
        
        const recentPrices = prices.slice(-period);
        const returns = [];
        
        for (let i = 1; i < recentPrices.length; i++) {
            const ret = (recentPrices[i].close - recentPrices[i-1].close) / recentPrices[i-1].close;
            returns.push(ret);
        }
        
        const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
        const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) / returns.length;
        const volatility = Math.sqrt(variance);
        
        return volatility;
    }

    getOptimalLevels(currentPrice, atr, timeframe, direction, prices) {
        const volatility = this.calculateVolatility(prices);
        this.volatilityCache.set(timeframe, volatility);
        
        let tpMultiplier = this.optimalRatios[timeframe].tp;
        let slMultiplier = this.optimalRatios[timeframe].sl;
        
        if (volatility < 0.015) {
            tpMultiplier *= 1.2;
            slMultiplier *= 0.9;
        } else if (volatility > 0.03) {
            tpMultiplier *= 0.8;
            slMultiplier *= 1.1;
        }
        
       const stopLoss = direction === 'BUY' 
            ? currentPrice - (atr * slMultiplier)
            : currentPrice + (atr * slMultiplier);
            
        const takeProfit = direction === 'BUY'
            ? currentPrice + (atr * tpMultiplier)
            : Math.max(0.01, currentPrice - (atr * tpMultiplier)); // âœ… CORRIGIDO: evita valores negativos
        
        const adjustedLevels = this.adjustForSupport(currentPrice, stopLoss, takeProfit, prices, direction);
        
        return {
            stopLoss: adjustedLevels.stopLoss,
            takeProfit: adjustedLevels.takeProfit,
            atrUsed: atr,
            volatility: volatility,
            tpMultiplier: tpMultiplier,
            slMultiplier: slMultiplier,
            riskReward: Math.abs(adjustedLevels.takeProfit - currentPrice) / Math.abs(adjustedLevels.stopLoss - currentPrice)
        };
    }

    adjustForSupport(currentPrice, stopLoss, takeProfit, prices, direction) {
        const recentPrices = prices.slice(-50);
        const highs = recentPrices.map(p => p.high);
        const lows = recentPrices.map(p => p.low);
        
        const resistanceLevels = this.findSignificantLevels(highs, 'high');
        const supportLevels = this.findSignificantLevels(lows, 'low');
        
        let adjustedSL = stopLoss;
        let adjustedTP = takeProfit;
        
        if (direction === 'BUY') {
            const nearestSupport = supportLevels.find(level => 
                level < currentPrice && level > stopLoss
            );
            if (nearestSupport) {
                adjustedSL = nearestSupport * 0.998;
            }
            
            const nearestResistance = resistanceLevels.find(level =>
                level > currentPrice && level < takeProfit
            );
            if (nearestResistance) {
                adjustedTP = nearestResistance * 0.998;
            }
        } else {
            const nearestResistance = resistanceLevels.find(level =>
                level > currentPrice && level < stopLoss
            );
            if (nearestResistance) {
                adjustedSL = nearestResistance * 1.002;
            }
            
            const nearestSupport = supportLevels.find(level =>
                level < currentPrice && level > takeProfit
            );
            if (nearestSupport) {
                adjustedTP = nearestSupport * 1.002;
            }
        }
        
        return { stopLoss: adjustedSL, takeProfit: adjustedTP };
    }

    findSignificantLevels(prices, type) {
        const sorted = [...prices].sort((a, b) => b - a);
        const levels = [];
        const threshold = 0.005;
        
        for (let i = 0; i < sorted.length; i++) {
            const price = sorted[i];
            const nearbyCount = sorted.filter(p => 
                Math.abs(p - price) / price < threshold
            ).length;
            
            if (nearbyCount >= 3) {
                const isDuplicate = levels.some(level => 
                    Math.abs(level - price) / price < threshold
                );
                if (!isDuplicate) {
                    levels.push(price);
                }
            }
        }
        
        return levels.sort((a, b) => type === 'high' ? b - a : a - b);
    }

    async learnFromResults() {
        if (!this.auditSystem) return;
        
        const logs = this.auditSystem.getRecentLogs(100);
        const completedLogs = logs.filter(l => l.outcome && l.outcome !== 'PENDENTE');
        
        if (completedLogs.length < 20) return;
        
        ['M5', 'M15'].forEach(tf => {
            const tfLogs = completedLogs.filter(l => l.metadata.timeframe === tf);
            if (tfLogs.length < 10) return;
            
            const acertos = tfLogs.filter(l => l.outcome === 'ACERTO');
            const erros = tfLogs.filter(l => l.outcome === 'ERRO');
            const expirados = tfLogs.filter(l => l.outcome === 'EXPIRADO');
            
            const winRate = acertos.length / tfLogs.length;
            const expiredRate = expirados.length / tfLogs.length;
            
            if (expiredRate > 0.6) {
                this.optimalRatios[tf].tp *= 0.9;
                console.log(`ðŸ“‰ ${tf}: TP reduzido para ${this.optimalRatios[tf].tp.toFixed(2)}x ATR`);
            } else if (erros.length > acertos.length && winRate < 0.4) {
                this.optimalRatios[tf].sl *= 1.1;
                console.log(`ðŸ“ˆ ${tf}: SL aumentado para ${this.optimalRatios[tf].sl.toFixed(2)}x ATR`);
            } else if (winRate > 0.6) {
                this.optimalRatios[tf].sl *= 0.95;
                this.optimalRatios[tf].tp *= 1.05;
                console.log(`âœ… ${tf}: Otimizado - TP: ${this.optimalRatios[tf].tp.toFixed(2)}x SL: ${this.optimalRatios[tf].sl.toFixed(2)}x`);
            }
            
            this.optimalRatios[tf].tp = Math.max(2.5, Math.min(6.0, this.optimalRatios[tf].tp));
            this.optimalRatios[tf].sl = Math.max(1.0, Math.min(3.0, this.optimalRatios[tf].sl));
        });
        
        this.saveOptimalRatios();
    }

    getStatistics() {
        return {
            ratios: this.optimalRatios,
            volatility: Object.fromEntries(this.volatilityCache)
        };
    }
}
        class AlphaEngine {
            constructor(memoryDB) {
                this.memoryDB = memoryDB;
                this.weights = {
                    rsi: 0.12,
                    macd: 0.10,
                    bollinger: 0.10,
                    stochastic_events: 0.15,
                    stochastic_divergence: 0.20,
                    volume: 0.10,        // âœ¨ NOVO
                    obv: 0.08,           // âœ¨ NOVO
                    ichimoku: 0.10,      // âœ¨ NOVO
                    vwap: 0.05           // âœ¨ NOVO
                };
                this.performance = {
                    totalSignals: 0,
                    successfulSignals: 0,
                    winRate: 0,
                    totalPnL: 0
                };
                this.listeners = new Set(); // NOVO: Para notificar mudanÃ§as
                this.warmUpModel();
            }

            // NOVO: MÃ©todo para registrar listeners
            addChangeListener(callback) {
                this.listeners.add(callback);
            }

            removeChangeListener(callback) {
                this.listeners.delete(callback);
            }

            notifyChange() {
                this.listeners.forEach(callback => {
                    try {
                        callback();
                    } catch (error) {
                        console.error('Erro ao notificar listener:', error);
                    }
                });
            }

            async warmUpModel() {
                try {
                    const stats = await this.memoryDB.getStatistics();
                    if (stats.total > 0) {
                        this.performance = {
                            totalSignals: stats.total,
                            successfulSignals: stats.successful,
                            winRate: stats.winRate,
                            totalPnL: stats.totalPnL
                        };
                        this.notifyChange(); // NOVO: Notificar apÃ³s carregar
                    }
                } catch (error) {
                    console.log('Erro ao aquecer modelo:', error);
                }
            }

          analyzeMarket(marketData, dataSource) {
    const prices = marketData.prices;
    const currentPrice = marketData.getLatestPrice();
    
    const rsi = TechnicalIndicators.calculateRSI(prices);
    const macd = TechnicalIndicators.calculateMACD(prices);
    const bollinger = TechnicalIndicators.calculateBollingerBands(prices);
    const stochastic = TechnicalIndicators.calculateStochastic(prices);
    
    // âœ… NOVOS INDICADORES ADICIONADOS
    const volume = TechnicalIndicators.analyzeVolume(prices);
    const obv = TechnicalIndicators.calculateOBV(prices);
    const ichimoku = TechnicalIndicators.calculateIchimoku(prices);
    const vwap = TechnicalIndicators.calculateVWAP(prices);
    
    const features = this.extractFeatures(currentPrice, rsi, macd, bollinger, stochastic, volume, obv, ichimoku, vwap);
    
    // âœ… CORRIGIDO: Agora gera e retorna o sinal
    const signal = this.generateSignal(features, currentPrice, dataSource);
    
    return signal;
}

            extractFeatures(currentPrice, rsi, macd, bollinger, stochastic, volume, obv, ichimoku, vwap) {
    return {
        rsi: {
                        value: rsi,
                        overbought: rsi > 70,
                        oversold: rsi < 30,
                        score: this.calculateRSIScore(rsi)
                    },
                    macd: {
                        value: macd.macd,
                        signal: macd.signal,
                        histogram: macd.histogram,
                        bullish: macd.macd > macd.signal,
                        score: this.calculateMACDScore(macd)
                    },
                    bollinger: {
                        position: (currentPrice.close - bollinger.lower) / (bollinger.upper - bollinger.lower),
                        squeeze: (bollinger.upper - bollinger.lower) / bollinger.middle < 0.1,
                        score: this.calculateBollingerScore(currentPrice.close, bollinger)
                    },
                    stochastic: {
            k: stochastic.k,
            d: stochastic.d,
            overbought: stochastic.k > 80,
            oversold: stochastic.k < 20,
            crossover: this.detectStochasticCrossover(stochastic),
            divergence: this.detectDivergence(),
            score: this.calculateStochasticScore(stochastic)
        },
        // âœ… NOVOS INDICADORES ADICIONADOS
        volume: {
            value: volume,
            score: this.calculateVolumeScore(volume)
        },
        obv: {
            value: obv,
            score: this.calculateOBVScore(obv)
        },
        ichimoku: {
            value: ichimoku,
            score: this.calculateIchimokuScore(ichimoku)
        },
        vwap: {
            value: vwap,
            score: this.calculateVWAPScore(vwap)
        }
    };
}

            calculateRSIScore(rsi) {
                if (rsi < 30) return 0.8;
                if (rsi > 70) return -0.8;
                return 0;
            }

            calculateMACDScore(macd) {
                if (macd.macd > macd.signal && macd.histogram > 0) return 0.7;
                if (macd.macd < macd.signal && macd.histogram < 0) return -0.7;
                return 0;
            }

            calculateBollingerScore(price, bollinger) {
                const position = (price - bollinger.lower) / (bollinger.upper - bollinger.lower);
                if (position < 0.2) return 0.6;
                if (position > 0.8) return -0.6;
                return 0;
            }

            calculateStochasticScore(stochastic) {
                let score = 0;
                if (stochastic.k < 20) score += 0.5;
                if (stochastic.k > 80) score -= 0.5;
                
                if (stochastic.k > stochastic.d) score += 0.3;
                else score -= 0.3;
                
                return score;
            }

            detectStochasticCrossover(stochastic) {
                return Math.abs(stochastic.k - stochastic.d) < 5;
            }

            detectDivergence() {
                return {
                    present: Math.random() < 0.3,
                    type: Math.random() > 0.5 ? 'bullish' : 'bearish',
                    strength: Math.random() * 0.5 + 0.5
                };
            }
calculateVolumeScore(volume) {
                let score = 0;
                
                if (volume.volumeTrend === 'increasing') score += 0.4;
                else if (volume.volumeTrend === 'decreasing') score -= 0.2;
                
                if (volume.isAnomalous) score += 0.5;
                
                score += volume.volumeStrength * 0.3;
                
                return Math.max(-1, Math.min(1, score));
            }

            calculateOBVScore(obv) {
                let score = 0;
                
                if (obv.trend === 'bullish') score += 0.6;
                else if (obv.trend === 'bearish') score -= 0.6;
                
                if (obv.divergence) {
                    if (obv.signal === 'hidden_bullish') score += 0.8;
                    else if (obv.signal === 'hidden_bearish') score -= 0.8;
                }
                
                score += obv.strength * (obv.trend === 'bullish' ? 0.4 : -0.4);
                
                return Math.max(-1, Math.min(1, score));
            }

            calculateIchimokuScore(ichimoku) {
                let score = 0;
                
                if (ichimoku.signal === 'strong_bullish') score += 0.9;
                else if (ichimoku.signal === 'bullish') score += 0.6;
                else if (ichimoku.signal === 'strong_bearish') score -= 0.9;
                else if (ichimoku.signal === 'bearish') score -= 0.6;
                else if (ichimoku.signal === 'inside_cloud') score += 0;
                
                if (ichimoku.tkCross === 'bullish') score += 0.3;
                else if (ichimoku.tkCross === 'bearish') score -= 0.3;
                
                if (ichimoku.chikouConfirmation && score > 0) score += 0.2;
                else if (!ichimoku.chikouConfirmation && score < 0) score -= 0.2;
                
                return Math.max(-1, Math.min(1, score));
            }

            calculateVWAPScore(vwap) {
                let score = 0;
                
                if (vwap.signal === 'above_vwap') score += 0.5;
                else if (vwap.signal === 'below_vwap') score -= 0.5;
                
                score += vwap.strength * (vwap.deviation > 0 ? 0.3 : -0.3);
                
                return Math.max(-1, Math.min(1, score));
            }
            generateSignal(features, currentPrice, dataSource) {
                let score = 0;
                const contributors = [];

                Object.keys(this.weights).forEach(indicator => {
                    let indicatorScore = 0;
                    
                    switch(indicator) {
                        case 'rsi':
                            indicatorScore = features.rsi.score;
                            break;
                        case 'macd':
                            indicatorScore = features.macd.score;
                            break;
                        case 'bollinger':
                            indicatorScore = features.bollinger.score;
                            break;
                        case 'stochastic_events':
                            indicatorScore = features.stochastic.score;
                            break;
                        case 'stochastic_divergence':
                if (features.stochastic.divergence.present) {
                    indicatorScore = features.stochastic.divergence.type === 'bullish' ? 0.8 : -0.8;
                    indicatorScore *= features.stochastic.divergence.strength;
                }
                break; // âœ… CORRIGIDO: break no lugar certo
                        case 'volume':
                            indicatorScore = features.volume.score;
                            break;
                        case 'obv':
                            indicatorScore = features.obv.score;
                            break;
                        case 'ichimoku':
                            indicatorScore = features.ichimoku.score;
                            break;
                        case 'vwap':
                indicatorScore = features.vwap.score;
                break;
        } // âœ… CORRIGIDO: fechamento do switch
                          
                    
                    
                    score += indicatorScore * this.weights[indicator];
                    if (Math.abs(indicatorScore) > 0.1) {
                        contributors.push(indicator);
                    }
                });

                const normalizedScore = Math.max(0, Math.min(100, (score + 1) * 50));

                if (normalizedScore < 25) {
                    return null;
                }

                const direction = score > 0 ? 'BUY' : 'SELL';
        const atr = TechnicalIndicators.calculateATR([currentPrice]);
        
        // âœ¨ NOVO: Usa otimizador de TP/SL
        const prices = this.marketDataRef ? this.marketDataRef.prices : [];
        const optimizedLevels = this.tpslOptimizer ? 
            this.tpslOptimizer.getOptimalLevels(currentPrice.close, atr, 'M5', direction, prices) :
            {
                stopLoss: direction === 'BUY' ? currentPrice.close - (atr * 2) : currentPrice.close + (atr * 2),
                takeProfit: direction === 'BUY' ? currentPrice.close + (atr * 4) : currentPrice.close - (atr * 4),
                riskReward: 2.0
            };
        
       const timeframeMinutes = 5; // âœ… CORRIGIDO: timeframe fixo de 5 minutos
                const entryTime = new Date();
                entryTime.setMinutes(entryTime.getMinutes() + Math.floor(Math.random() * timeframeMinutes) + 1);
                
                const signal = {
                    id: Date.now() + Math.random(),
                    timestamp: new Date(),
                    symbol: 'BTCUSDT',
                    direction,
                    timeframe: timeframeMinutes === 5 ? 'M5' : 'M15',
                    score: Math.round(normalizedScore),
                    price: currentPrice.close,
            entryTime: entryTime,
            stopLoss: optimizedLevels.stopLoss,
            takeProfit: optimizedLevels.takeProfit,
            riskReward: optimizedLevels.riskReward,
            tpslDetails: optimizedLevels, // âœ¨ NOVO
            contributors,
                    divergence: features.stochastic.divergence.present ? features.stochastic.divergence : null,
                    features,
                    status: 'PENDENTE',
                    dataSource,
                    pnl: 0,
                    executed: false
                };

                this.memoryDB.saveSignal(signal);
                
                if (window.auditSystemRef) {
                    try {
                        if (window.debugAudit) {
                            console.log('ðŸ” [ENGINE] Chamando auditSystem.logSignalGeneration');
                        }
                        window.auditSystemRef.logSignalGeneration(signal, currentPrice, { weights: this.weights });
                    } catch (error) {
                        console.error('âŒ [ENGINE] Erro ao registrar no auditSystem:', error);
                    }
                } else {
                    console.warn('âš ï¸ [ENGINE] auditSystemRef nÃ£o estÃ¡ disponÃ­vel!');
                }

                return signal;
            }

            async learnFromTrade(signal, result) {
                const successful = result === 'ACERTO';
                const learningRate = 0.1;
                const multiplier = signal.divergence ? 2 : 1;
                
                signal.contributors.forEach(indicator => {
                    if (successful) {
                        this.weights[indicator] = Math.min(1, this.weights[indicator] + learningRate * multiplier);
                    } else {
                        this.weights[indicator] = Math.max(0, this.weights[indicator] - learningRate * multiplier);
                    }
                });

                const totalWeight = Object.values(this.weights).reduce((a, b) => a + b, 0);
                Object.keys(this.weights).forEach(key => {
                    this.weights[key] /= totalWeight;
                });

                this.performance.totalSignals++;
                if (successful) this.performance.successfulSignals++;
                this.performance.winRate = (this.performance.successfulSignals / this.performance.totalSignals) * 100;

                signal.status = result;
                await this.memoryDB.saveSignal(signal);

                if (this.performance.totalSignals % 10 === 0) {
                    await this.memoryDB.saveWeightsSnapshot(this.weights, this.performance);
                }
                
                this.notifyChange(); // NOVO: Notificar mudanÃ§as na performance
            }
        }
/* ========================================
           SISTEMA DE NOTIFICAÃ‡Ã•ES TELEGRAM
           ======================================== */

        class TelegramNotifier {
            constructor() {
                this.botToken = null;
                this.chatId = null;
                this.enabled = false;
                this.queue = [];
                this.isSending = false;
                this.loadConfig();
            }

            loadConfig() {
                try {
                    const saved = localStorage.getItem('telegram_config');
                    if (saved) {
                        const config = JSON.parse(saved);
                        this.botToken = config.botToken;
                        this.chatId = config.chatId;
                        this.enabled = config.enabled || false;
                        console.log('âœ… ConfiguraÃ§Ã£o Telegram carregada');
                    }
                } catch (error) {
                    console.error('Erro ao carregar config Telegram:', error);
                }
            }

            saveConfig() {
                try {
                    const config = {
                        botToken: this.botToken,
                        chatId: this.chatId,
                        enabled: this.enabled
                    };
                    localStorage.setItem('telegram_config', JSON.stringify(config));
                } catch (error) {
                    console.error('Erro ao salvar config Telegram:', error);
                }
            }

            configure(botToken, chatId) {
                this.botToken = botToken;
                this.chatId = chatId;
                this.saveConfig();
            }

            enable() {
                if (!this.botToken || !this.chatId) {
                    throw new Error('Configure o Bot Token e Chat ID primeiro');
                }
                this.enabled = true;
                this.saveConfig();
            }

            disable() {
                this.enabled = false;
                this.saveConfig();
            }

            async testConnection() {
                if (!this.botToken || !this.chatId) {
                    return { success: false, message: 'Configure o Bot Token e Chat ID' };
                }

                try {
                    const response = await this.sendMessage('ðŸ¤– Teste de conexÃ£o bem-sucedido!');
                    return { success: true, message: 'Mensagem enviada com sucesso!' };
                } catch (error) {
                    return { success: false, message: error.message };
                }
            }

            async sendMessage(text, parseMode = 'HTML') {
                if (!this.enabled || !this.botToken || !this.chatId) {
                    return;
                }

                this.queue.push({ text, parseMode });
                
                if (!this.isSending) {
                    this.processQueue();
                }
            }

            async processQueue() {
                if (this.queue.length === 0) {
                    this.isSending = false;
                    return;
                }

                this.isSending = true;
                const message = this.queue.shift();

                try {
                    const url = `https://api.telegram.org/bot${this.botToken}/sendMessage`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            chat_id: this.chatId,
                            text: message.text,
                            parse_mode: message.parseMode
                        })
                    });

                    const data = await response.json();
                    
                    if (!data.ok) {
                        console.error('Erro ao enviar mensagem Telegram:', data.description);
                    }

                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    this.processQueue();

                } catch (error) {
                    console.error('Erro ao enviar mensagem:', error);
                    this.isSending = false;
                }
            }

            formatSignalMessage(signal) {
                const emoji = signal.direction === 'BUY' ? 'ðŸŸ¢' : 'ðŸ”´';
                const dataSource = signal.dataSource === 'REAL' ? 'ðŸ“¡ Dados Reais' : 'ðŸ”® SimulaÃ§Ã£o';
                
                let message = `${emoji} <b>NOVO SINAL</b>\n\n`;
                message += `<b>Ativo:</b> ${signal.symbol}\n`;
                message += `<b>DireÃ§Ã£o:</b> ${signal.direction}\n`;
                message += `<b>Score:</b> ${signal.score}%\n`;
                message += `<b>PreÃ§o:</b> R$ ${signal.price.toFixed(2)}\n`;
                message += `<b>Stop Loss:</b> R$ ${signal.stopLoss.toFixed(2)}\n`;
                message += `<b>Take Profit:</b> R$ ${signal.takeProfit.toFixed(2)}\n`;
                message += `<b>Timeframe:</b> ${signal.timeframe}\n`;
                message += `<b>Fonte:</b> ${dataSource}\n`;
                
                if (signal.divergence) {
                    message += `\nâš¡ <b>DivergÃªncia ${signal.divergence.type}</b>`;
                }
                
                const entryTime = new Date(signal.entryTime);
                message += `\nâ° <b>Entrada:</b> ${entryTime.toLocaleTimeString('pt-BR')}`;
                
                return message;
            }

            formatExecutionMessage(signal, executionResult) {
                let message = `ðŸ¤– <b>ORDEM EXECUTADA</b>\n\n`;
                message += `<b>DireÃ§Ã£o:</b> ${signal.direction}\n`;
                message += `<b>SÃ­mbolo:</b> ${signal.symbol}\n`;
                message += `<b>PreÃ§o Executado:</b> R$ ${executionResult.executedPrice.toFixed(2)}\n`;
                message += `<b>Quantidade:</b> ${executionResult.executedQty}\n`;
                message += `<b>Order ID:</b> ${executionResult.orderId}\n`;
                
                if (executionResult.simulated) {
                    message += `\nâš ï¸ <i>Ordem simulada</i>`;
                }
                
                return message;
            }

            formatResultMessage(signal, result, pnl) {
                let emoji = '';
                let title = '';
                
                if (result === 'ACERTO') {
                    emoji = 'âœ…';
                    title = 'TAKE PROFIT ATINGIDO';
                } else if (result === 'ERRO') {
                    emoji = 'âŒ';
                    title = 'STOP LOSS ATINGIDO';
                } else if (result === 'EXPIRADO') {
                    emoji = 'â±ï¸';
                    title = 'SINAL EXPIRADO';
                }
                
                let message = `${emoji} <b>${title}</b>\n\n`;
                message += `<b>SÃ­mbolo:</b> ${signal.symbol}\n`;
                message += `<b>DireÃ§Ã£o:</b> ${signal.direction}\n`;
                message += `<b>P&L:</b> R$ ${pnl.toFixed(2)}\n`;
                
                if (signal.finalPrice) {
                    message += `<b>PreÃ§o Final:</b> R$ ${signal.finalPrice.toFixed(2)}\n`;
                }
                
                return message;
            }

            async notifySignal(signal) {
                if (!this.enabled) return;
                const message = this.formatSignalMessage(signal);
                await this.sendMessage(message);
            }

            async notifyExecution(signal, executionResult) {
                if (!this.enabled) return;
                const message = this.formatExecutionMessage(signal, executionResult);
                await this.sendMessage(message);
            }

            async notifyResult(signal, result, pnl) {
                if (!this.enabled) return;
                const message = this.formatResultMessage(signal, result, pnl);
                await this.sendMessage(message);
            }

            async notifyDailyReport(stats) {
                if (!this.enabled) return;
                
                let message = `ðŸ“Š <b>RELATÃ“RIO DIÃRIO</b>\n\n`;
                message += `<b>Total de Trades:</b> ${stats.totalTrades}\n`;
                message += `<b>VitÃ³rias:</b> ${stats.wins} (${stats.winRate.toFixed(1)}%)\n`;
                message += `<b>Derrotas:</b> ${stats.losses}\n`;
                message += `<b>P&L Total:</b> R$ ${stats.totalPnL.toFixed(2)}\n`;
                
                await this.sendMessage(message);
            }

            isConfigured() {
                return this.botToken && this.chatId;
            }

            isEnabled() {
                return this.enabled;
            }
        }
        /* ========================================
           SISTEMA DE BACKTESTING
           ======================================== */

        class BacktestEngine {
            constructor(alphaEngine, memoryDB) {
                this.alphaEngine = alphaEngine;
                this.memoryDB = memoryDB;
                this.results = [];
                this.isRunning = false;
            }

            async loadHistoricalData(symbol, timeframe, startDate, endDate) {
                console.log(`ðŸ“Š Carregando dados histÃ³ricos: ${symbol} ${timeframe}`);
                console.log(`   PerÃ­odo: ${startDate} atÃ© ${endDate}`);
                
                const data = this.generateHistoricalData(startDate, endDate, timeframe);
                
                console.log(`âœ… ${data.length} candles carregados`);
                return data;
            }

            generateHistoricalData(startDate, endDate, timeframe) {
                const candles = [];
                const start = new Date(startDate).getTime();
                const end = new Date(endDate).getTime();
                const intervalMs = timeframe === 'M5' ? 5 * 60 * 1000 : 15 * 60 * 1000;
                
                let basePrice = 50000;
                let timestamp = start;
                
                while (timestamp <= end) {
                    const trend = Math.sin(candles.length * 0.01) * 500;
                    const noise = (Math.random() - 0.5) * 200;
                    const price = basePrice + trend + noise;
                    
                    candles.push({
                        timestamp,
                        open: price,
                        high: price + Math.random() * 100,
                        low: price - Math.random() * 100,
                        close: price + (Math.random() - 0.5) * 50,
                        volume: Math.random() * 1000000
                    });
                    
                    basePrice = price;
                    timestamp += intervalMs;
                }
                
                return candles;
            }

            async runBacktest(config) {
                if (this.isRunning) {
                    throw new Error('Backtest jÃ¡ em execuÃ§Ã£o');
                }

                this.isRunning = true;
                this.results = [];
                
                const {
                    symbol = 'BTCUSDT',
                    timeframe = 'M5',
                    startDate,
                    endDate,
                    initialBalance = 10000,
                    riskPerTrade = 100,
                    minScore = 50
                } = config;

                console.log('ðŸš€ Iniciando Backtest...');
                console.log(`   SÃ­mbolo: ${symbol}`);
                console.log(`   PerÃ­odo: ${startDate} a ${endDate}`);
                console.log(`   Saldo inicial: R$ ${initialBalance}`);

                try {
                    const historicalData = await this.loadHistoricalData(symbol, timeframe, startDate, endDate);
                    
                    if (historicalData.length < 200) {
                        throw new Error('Dados insuficientes para backtest (mÃ­nimo 200 candles)');
                    }

                    let balance = initialBalance;
                    let openPositions = [];
                    const trades = [];
                    
                    for (let i = 200; i < historicalData.length; i++) {
                        const currentCandles = historicalData.slice(0, i + 1);
                        const currentPrice = currentCandles[i];
                        
                        const mockMarketData = {
                            prices: currentCandles,
                            getLatestPrice: () => currentPrice
                        };
                        
                        openPositions = openPositions.filter(position => {
                            const candle = currentPrice;
                            let closed = false;
                            let result = null;
                            let pnl = 0;
                            
                            if (position.direction === 'BUY') {
                                if (candle.high >= position.takeProfit) {
                                    result = 'WIN';
                                    pnl = riskPerTrade * 2;
                                    closed = true;
                                } else if (candle.low <= position.stopLoss) {
                                    result = 'LOSS';
                                    pnl = -riskPerTrade;
                                    closed = true;
                                }
                            } else {
                                if (candle.low <= position.takeProfit) {
                                    result = 'WIN';
                                    pnl = riskPerTrade * 2;
                                    closed = true;
                                } else if (candle.high >= position.stopLoss) {
                                    result = 'LOSS';
                                    pnl = -riskPerTrade;
                                    closed = true;
                                }
                            }
                            
                            if (!closed && i - position.entryIndex > 20) {
                                result = 'TIMEOUT';
                                pnl = 0;
                                closed = true;
                            }
                            
                            if (closed) {
                                balance += pnl;
                                trades.push({
                                    ...position,
                                    exitPrice: candle.close,
                                    exitTime: candle.timestamp,
                                    result,
                                    pnl,
                                    balance
                                });
                            }
                            
                            return !closed;
                        });
                        
                        if (openPositions.length === 0) {
                            try {
                                const signal = this.alphaEngine.analyzeMarket(mockMarketData, 'BACKTEST');
                                
                                if (signal && signal.score >= minScore && balance >= riskPerTrade) {
                                    openPositions.push({
                                        entryIndex: i,
                                        entryPrice: currentPrice.close,
                                        entryTime: currentPrice.timestamp,
                                        direction: signal.direction,
                                        stopLoss: signal.stopLoss,
                                        takeProfit: signal.takeProfit,
                                        score: signal.score,
                                        symbol
                                    });
                                }
                            } catch (error) {
                                // Ignora erros
                            }
                        }
                        
                        if (i % 100 === 0) {
                            const progress = ((i / historicalData.length) * 100).toFixed(1);
                            console.log(`â³ Progresso: ${progress}% | Trades: ${trades.length} | Saldo: R$ ${balance.toFixed(2)}`);
                        }
                    }
                    
                    openPositions.forEach(position => {
                        balance -= riskPerTrade;
                        trades.push({
                            ...position,
                            exitPrice: historicalData[historicalData.length - 1].close,
                            exitTime: historicalData[historicalData.length - 1].timestamp,
                            result: 'TIMEOUT',
                            pnl: -riskPerTrade,
                            balance
                        });
                    });
                    
                    const stats = this.calculateBacktestStats(trades, initialBalance, balance);
                    
                    this.results = {
                        config,
                        trades,
                        stats,
                        finalBalance: balance,
                        historicalDataPoints: historicalData.length
                    };
                    
                    console.log('âœ… Backtest concluÃ­do!');
                    console.log(`   Total de trades: ${trades.length}`);
                    console.log(`   Win Rate: ${stats.winRate.toFixed(2)}%`);
                    console.log(`   Retorno: ${stats.totalReturn.toFixed(2)}%`);
                    console.log(`   Saldo final: R$ ${balance.toFixed(2)}`);
                    
                    return this.results;
                    
                } catch (error) {
                    console.error('âŒ Erro no backtest:', error);
                    throw error;
                } finally {
                    this.isRunning = false;
                }
            }

            calculateBacktestStats(trades, initialBalance, finalBalance) {
                if (trades.length === 0) {
                    return {
                        totalTrades: 0,
                        wins: 0,
                        losses: 0,
                        timeouts: 0,
                        winRate: 0,
                        lossRate: 0,
                        totalReturn: 0,
                        maxDrawdown: 0,
                        sharpeRatio: 0,
                        profitFactor: 0,
                        avgWin: 0,
                        avgLoss: 0,
                        largestWin: 0,
                        largestLoss: 0
                    };
                }

                const wins = trades.filter(t => t.result === 'WIN');
                const losses = trades.filter(t => t.result === 'LOSS');
                const timeouts = trades.filter(t => t.result === 'TIMEOUT');
                
                const totalPnL = trades.reduce((sum, t) => sum + t.pnl, 0);
                const totalWins = wins.reduce((sum, t) => sum + t.pnl, 0);
                const totalLosses = Math.abs(losses.reduce((sum, t) => sum + t.pnl, 0));
                
                let peak = initialBalance;
                let maxDrawdown = 0;
                
                trades.forEach(trade => {
                    if (trade.balance > peak) {
                        peak = trade.balance;
                    }
                    const drawdown = ((peak - trade.balance) / peak) * 100;
                    if (drawdown > maxDrawdown) {
                        maxDrawdown = drawdown;
                    }
                });
                
                const returns = trades.map(t => (t.pnl / initialBalance) * 100);
                const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
                const stdDev = Math.sqrt(
                    returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length
                );
                const sharpeRatio = stdDev !== 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0;
                
                return {
                    totalTrades: trades.length,
                    wins: wins.length,
                    losses: losses.length,
                    timeouts: timeouts.length,
                    winRate: (wins.length / trades.length) * 100,
                    lossRate: (losses.length / trades.length) * 100,
                    totalReturn: ((finalBalance - initialBalance) / initialBalance) * 100,
                    totalPnL,
                    maxDrawdown,
                    sharpeRatio,
                    profitFactor: totalLosses !== 0 ? totalWins / totalLosses : 0,
                    avgWin: wins.length > 0 ? totalWins / wins.length : 0,
                    avgLoss: losses.length > 0 ? totalLosses / losses.length : 0,
                    largestWin: wins.length > 0 ? Math.max(...wins.map(t => t.pnl)) : 0,
                    largestLoss: losses.length > 0 ? Math.min(...losses.map(t => t.pnl)) : 0
                };
            }

            getResults() {
                return this.results;
            }

            exportResults() {
                if (!this.results || !this.results.trades) {
                    return null;
                }

                const { trades, stats } = this.results;
                
                let csv = 'Data/Hora,SÃ­mbolo,DireÃ§Ã£o,PreÃ§o Entrada,Stop Loss,Take Profit,PreÃ§o SaÃ­da,Resultado,P&L,Saldo,Score\n';
                
                trades.forEach(trade => {
                    csv += [
                        new Date(trade.entryTime).toLocaleString('pt-BR'),
                        trade.symbol,
                        trade.direction,
                        trade.entryPrice.toFixed(2),
                        trade.stopLoss.toFixed(2),
                        trade.takeProfit.toFixed(2),
                        trade.exitPrice.toFixed(2),
                        trade.result,
                        trade.pnl.toFixed(2),
                        trade.balance.toFixed(2),
                        trade.score
                    ].join(',') + '\n';
                });
                
                csv += '\n\nESTATÃSTICAS\n';
                csv += `Total de Trades,${stats.totalTrades}\n`;
                csv += `VitÃ³rias,${stats.wins}\n`;
                csv += `Derrotas,${stats.losses}\n`;
                csv += `Win Rate,${stats.winRate.toFixed(2)}%\n`;
                csv += `Retorno Total,${stats.totalReturn.toFixed(2)}%\n`;
                csv += `Max Drawdown,${stats.maxDrawdown.toFixed(2)}%\n`;
                csv += `Sharpe Ratio,${stats.sharpeRatio.toFixed(2)}\n`;
                csv += `Profit Factor,${stats.profitFactor.toFixed(2)}\n`;
                
                return csv;
            }
        }
        /* ========================================
           COMPONENTE APP PRINCIPAL
           ======================================== */

        function App() {
            const [currentView, setCurrentView] = useState('dashboard');
            const [mode, setMode] = useState('manual');
            const [isActive, setIsActive] = useState(false);
            const [signals, setSignals] = useState([]);
            const [marketData, setMarketData] = useState(null);
            const [alphaEngine, setAlphaEngine] = useState(null);
            const [notification, setNotification] = useState(null);
            const [minScore, setMinScore] = useState(50);
            const [riskAmount, setRiskAmount] = useState(100);
            const [dataSource, setDataSource] = useState('SIMULADO');
            const [memoryDB, setMemoryDB] = useState(null);
            const [apiManager, setApiManager] = useState(null);
            const [orderExecutor, setOrderExecutor] = useState(null);
            const [auditSystem, setAuditSystem] = useState(null);
            const [maxPositions, setMaxPositions] = useState(3);
            const [updateTrigger, setUpdateTrigger] = useState(0); // NOVO: Para forÃ§ar re-renders

            const marketDataRef = useRef(null);
            const alphaEngineRef = useRef(null);
            const memoryDBRef = useRef(null);
            const apiManagerRef = useRef(null);
            const auditSystemRef = useRef(null);
            const orderExecutorRef = useRef(null);
            const verificationTimers = useRef(new Map());
            const minScoreRef = useRef(minScore);
const modeRef = useRef(mode);

useEffect(() => {
    minScoreRef.current = minScore;
}, [minScore]);

useEffect(() => {
    modeRef.current = mode;
}, [mode]);

            useEffect(() => {
               try {
                console.log('ðŸš€ Inicializando sistema...');
                
                // âœ… Solicitar permissÃ£o para notificaÃ§Ãµes
                if ("Notification" in window && Notification.permission === "default") {
                    Notification.requestPermission().then(permission => {
                        if (permission === "granted") {
                            console.log('âœ… PermissÃ£o para notificaÃ§Ãµes concedida');
                        }
                    });
                }
                
                // âœ… Inicializar MemoryDB com Supabase
                memoryDBRef.current = new MemoryDB();
                memoryDBRef.current.init().then(() => {
                    setMemoryDB(memoryDBRef.current);
                    console.log('âœ… MemoryDB inicializado com Supabase');
                });
                
                marketDataRef.current = new MarketDataSimulator();
                setMarketData(marketDataRef.current);
                console.log('âœ… MarketData inicializado');
                
                // âœ… Inicializar AuditSystem com Supabase
                auditSystemRef.current = new AuditSystem();
                window.auditSystemRef = auditSystemRef.current;
                auditSystemRef.current.init().then(() => {
                    setAuditSystem(auditSystemRef.current);
                    console.log('âœ… AuditSystem inicializado com Supabase');
                });
                
                alphaEngineRef.current = new AlphaEngine(memoryDBRef.current);
                alphaEngineRef.current.marketDataRef = marketDataRef.current;
                alphaEngineRef.current.tpslOptimizer = new TPSLOptimizer(auditSystemRef.current);
                setAlphaEngine(alphaEngineRef.current);
                console.log('âœ… AlphaEngine inicializado');
                
                apiManagerRef.current = new APIConnectionManager();
                setApiManager(apiManagerRef.current);
                console.log('âœ… APIManager inicializado');
                
                orderExecutorRef.current = new OrderExecutionManager(apiManagerRef.current);
                setOrderExecutor(orderExecutorRef.current);
                console.log('âœ… OrderExecutor inicializado');

                const telegramNotifier = new TelegramNotifier();
                window.telegramNotifier = telegramNotifier;
                console.log('âœ… TelegramNotifier inicializado');

                const scheduleDailyReport = () => {
                    const now = new Date();
                    const tonight = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 0);
                    
                    if (tonight <= now) {
                        tonight.setDate(tonight.getDate() + 1);
                    }
                    
                    const msUntilReport = tonight - now;
                    
                    setTimeout(async () => {
                        if (memoryDBRef.current && telegramNotifier.isEnabled()) {
                            const stats = await memoryDBRef.current.getStatistics();
                            await telegramNotifier.notifyDailyReport(stats);
                        }
                        scheduleDailyReport();
                    }, msUntilReport);
                };

                scheduleDailyReport();
                
                const updateCallback = () => setUpdateTrigger(prev => prev + 1);
                
                memoryDBRef.current.addChangeListener(updateCallback);
                alphaEngineRef.current.addChangeListener(updateCallback);
                auditSystemRef.current.addChangeListener(updateCallback);
                
                console.log('ðŸŽ‰ Sistema totalmente inicializado!');
                console.log('%cðŸ’¡ Sistema agora usa SUPABASE para persistÃªncia!', 'color: #00ff88; font-weight: bold;');
                
                setInterval(() => {
                    if (alphaEngineRef.current && alphaEngineRef.current.tpslOptimizer) {
                        alphaEngineRef.current.tpslOptimizer.learnFromResults();
                    }
                }, 5 * 60 * 1000);
                
                return () => {
                    if (memoryDBRef.current) memoryDBRef.current.removeChangeListener(updateCallback);
                    if (alphaEngineRef.current) alphaEngineRef.current.removeChangeListener(updateCallback);
                    if (auditSystemRef.current) auditSystemRef.current.removeChangeListener(updateCallback);
                };
                
            } catch (error) {
                console.error('âŒ Erro na inicializaÃ§Ã£o:', error);
            }
        }, []);

            // âœ… LIMPEZA DE TIMERS AO DESMONTAR
            useEffect(() => {
                return () => {
                    // Limpar todos os timers de verificaÃ§Ã£o
                    verificationTimers.current.forEach((timerData) => {
                        if (timerData.timer) clearTimeout(timerData.timer);
                        if (timerData.interval) clearInterval(timerData.interval);
                    });
                    verificationTimers.current.clear();
                    console.log('ðŸ§¹ Timers limpos ao desmontar componente');
                };
            }, []);

            useEffect(() => {
                const loadSavedSignals = async () => {
                    if (memoryDB) {
                        const savedSignals = await memoryDB.getAllSignals();
                        const pendingSignals = savedSignals.filter(s => s.status === 'PENDENTE');
                        if (pendingSignals.length > 0) {
                            setSignals(pendingSignals);
                            pendingSignals.forEach(signal => {
                                scheduleSignalVerification(signal);
                            });
                        }
                    }
                };
                
                if (memoryDB) {
                    loadSavedSignals();
                }
            }, [memoryDB]);

            useEffect(() => {
                const config = {
                    minScore,
                    riskAmount,
                    maxPositions
                };
                localStorage.setItem('alpha_config', JSON.stringify(config));
            }, [minScore, riskAmount, maxPositions]);

            useEffect(() => {
                if (!isActive || !marketData || !alphaEngine || !apiManager) return;

                let lastKnownPrice = null;
                let samePriceCount = 0;

                const interval = setInterval(async () => {
                    try {
                        const activeConn = apiManager.getActiveConnection();
                        let currentDataSource = 'SIMULADO';
                        
                        const currentPrice = marketData.getLatestPrice();
                        if (lastKnownPrice && currentPrice.close === lastKnownPrice) {
                            samePriceCount++;
                            if (samePriceCount > 2) {
                                console.warn('âš ï¸ [LOOP] PreÃ§o nÃ£o mudou por', samePriceCount, 'iteraÃ§Ãµes. ForÃ§ando atualizaÃ§Ã£o...');
                                marketData.addNewCandle();
                                samePriceCount = 0;
                            }
                        } else {
                            samePriceCount = 0;
                        }
                        lastKnownPrice = currentPrice.close;
                        
                        if (activeConn && activeConn.status === 'connected') {
                            try {
                                let symbolToFetch = 'BTCUSDT';
                                if (activeConn.provider === 'ALPHA_VANTAGE') {
                                    symbolToFetch = 'IBM';
                                } else if (activeConn.provider === 'COINGECKO') {
                                    symbolToFetch = 'BTC';
                                }
                                
                                const realData = await fetchRealMarketData(
                                    activeConn.provider,
                                    activeConn.apiKey,
                                    symbolToFetch,
                                    'M5',
                                    activeConn.secretKey
                                );
                                
                                if (realData && realData.length > 0) {
                                    marketData.replaceWithRealData(realData);
                                    currentDataSource = 'REAL';
                                    setDataSource('REAL');
                                } else {
                                    throw new Error('Array de dados vazio');
                                }
                            } catch (error) {
                                if (dataSource === 'REAL') {
                                    console.warn('âš ï¸ Erro ao buscar dados reais, voltando para simulaÃ§Ã£o');
                                    marketData.generateInitialData();
                                } else {
                                    marketData.addNewCandle();
                                }
                                currentDataSource = 'SIMULADO';
                                setDataSource('SIMULADO');
                            }
                        } else {
                            marketData.addNewCandle();
                            currentDataSource = 'SIMULADO';
                            setDataSource('SIMULADO');
                        }
                        
                        const signal = alphaEngine.analyzeMarket(marketData, currentDataSource);

                        // ADICIONE ESTE LOG PARA DEPURAÃ‡ÃƒO
    if (signal) {
        console.log(`Sinal gerado: Score ${signal.score} | MÃ­nimo necessÃ¡rio: ${minScoreRef.current}`);
    }

     if (signal && signal.score >= minScoreRef.current) {
            console.log('%cSINAL APROVADO! Mostrando notificaÃ§Ã£o...', 'color: #00ff88; font-weight: bold;');
            
            setSignals(prev => [signal, ...prev.slice(0, 9)]);
            showNotification(`Novo sinal ${signal.direction} - Score: ${signal.score}%`);
            playAlert();
            scheduleSignalVerification(signal);

            if (window.telegramNotifier && window.telegramNotifier.isEnabled()) {
                window.telegramNotifier.notifySignal(signal);
            }
            
            // VerificaÃ§Ã£o para o modo automÃ¡tico
            if (modeRef.current === 'auto' && orderExecutorRef.current) {
                const executionResult = await orderExecutorRef.current.executeSignalAuto(
                    signal,
                    modeRef.current, // Usando a referÃªncia
                    riskAmount // Supondo que riskAmount tambÃ©m tenha uma ref se for dinÃ¢mico
                );
                
                if (executionResult.success) {
                    showNotification(
                        `ðŸ¤– ORDEM EXECUTADA: ${signal.direction} @ ${executionResult.executedPrice.toFixed(2)} | ID: ${executionResult.orderId}`
                    );
                    
                    signal.executed = true;
                    signal.executionDetails = executionResult;

                    if (window.telegramNotifier && window.telegramNotifier.isEnabled()) {
                        window.telegramNotifier.notifyExecution(signal, executionResult);
                    }
                    
                    // Atualiza o sinal na lista para mostrar que foi executado
                    setSignals(prev => prev.map(s => s.id === signal.id ? signal : s));
                } else {
                    showNotification(`âš ï¸ Falha na execuÃ§Ã£o automÃ¡tica: ${executionResult.message}`);
                }
            }
        } // <--- Fim do IF principal

    } catch (error) { // <--- Agora o CATCH estÃ¡ correto
        console.error('âŒ [LOOP] Erro:', error);
    }
}, 30000);
                return () => clearInterval(interval);
            }, [isActive, marketData, alphaEngine, minScore, apiManager, dataSource, mode, riskAmount, orderExecutor]); // âœ… ADICIONADO: orderExecutor

            useEffect(() => {
                if (!isActive) return;
                
                const countdownInterval = setInterval(() => {
                    setSignals(prev => [...prev]);
                }, 1000);

                return () => clearInterval(countdownInterval);
            }, [isActive]);

            const scheduleSignalVerification = (signal) => {
                try {
                    const now = new Date().getTime();
                    const entryTime = new Date(signal.entryTime).getTime();
                    const timeframeMs = signal.timeframe === 'M5' ? 5 * 60 * 1000 : 15 * 60 * 1000;
                    
                    const timeUntilEntry = Math.max(0, entryTime - now);
                    const verificationDelay = timeUntilEntry + timeframeMs;
                    
                    const monitoringInterval = setInterval(() => {
                        const currentPrice = marketDataRef.current?.getLatestPrice()?.close;
                        if (!currentPrice) return;
                        
                        let shouldStop = false;
                        let result = null;
                        let pnl = 0;
                        
                        if (signal.direction === 'BUY') {
                            if (currentPrice >= signal.takeProfit) {
                                result = 'ACERTO';
                                pnl = riskAmount * 2;
                                shouldStop = true;
                            } else if (currentPrice <= signal.stopLoss) {
                                result = 'ERRO';
                                pnl = -riskAmount;
                                shouldStop = true;
                            }
                        } else {
                            if (currentPrice <= signal.takeProfit) {
                                result = 'ACERTO';
                                pnl = riskAmount * 2;
                                shouldStop = true;
                            } else if (currentPrice >= signal.stopLoss) {
                                result = 'ERRO';
                                pnl = -riskAmount;
                                shouldStop = true;
                            }
                        }
                        
                        if (shouldStop) {
                            clearInterval(monitoringInterval);
                            clearTimeout(verificationTimerId);
                            verificationTimers.current.delete(signal.id);

                            if (window.auditSystemRef) {
                                try {
                                    if (window.debugAudit) {
                                        console.log('ðŸ” [MONITOR] Atualizando auditoria');
                                    }
                                    window.auditSystemRef.updateSignalOutcome(
                                        signal.id,
                                        result,
                                        currentPrice,
                                        pnl,
                                        signal.executionDetails
                                    );
                                } catch (error) {
                                    console.error('âŒ [MONITOR] Erro ao atualizar auditoria:', error);
                                }
                            }
                            
                            if (orderExecutorRef.current && signal.executed) {
                                orderExecutorRef.current.closePosition(signal.id, result, pnl);
                            }
                            
                            verifySignalOutcome(signal, result, pnl, currentPrice);
                        }
                    }, 5000);
                    
                    const verificationTimerId = setTimeout(() => {
                        clearInterval(monitoringInterval);
                        
                        if (orderExecutorRef.current && signal.executed) {
                            orderExecutorRef.current.closePosition(signal.id, 'EXPIRADO', 0);
                        }
                        
                        verifySignalOutcome(signal);
                    }, verificationDelay);

                    verificationTimers.current.set(signal.id, {
                        timer: verificationTimerId,
                        interval: monitoringInterval
                    });
                } catch (error) {
                    console.error('Erro ao agendar verificaÃ§Ã£o:', error);
                }
            };

            const verifySignalOutcome = async (signal, forcedResult = null, forcedPnl = null, forcedPrice = null) => {
                try {
                    if (!marketData) return;

                    let result = forcedResult || 'EXPIRADO';
                    let pnl = forcedPnl || 0;
                    let currentPrice = forcedPrice || marketData.getLatestPrice().close;
                    
                    if (!forcedResult) {
                        if (signal.direction === 'BUY') {
                            if (currentPrice >= signal.takeProfit) {
                                result = 'ACERTO';
                                pnl = riskAmount * 2;
                            } else if (currentPrice <= signal.stopLoss) {
                                result = 'ERRO';
                                pnl = -riskAmount;
                            }
                        } else {
                            if (currentPrice <= signal.takeProfit) {
                                result = 'ACERTO';
                                pnl = riskAmount * 2;
                            } else if (currentPrice >= signal.stopLoss) {
                                result = 'ERRO';
                                pnl = -riskAmount;
                            }
                        }
                    }

                    signal.status = result;
                    signal.pnl = pnl;
                    signal.finalPrice = currentPrice;

                    if (window.auditSystemRef) {
                        try {
                            if (window.debugAudit) {
                                console.log('ðŸ” [VERIFY] Atualizando auditoria');
                            }
                            window.auditSystemRef.updateSignalOutcome(
                                signal.id,
                                result,
                                currentPrice,
                                pnl,
                                signal.executionDetails
                            );
                        } catch (error) {
                            console.error('âŒ [VERIFY] Erro ao atualizar auditoria:', error);
                        }
                    }

                    if (alphaEngine && result !== 'EXPIRADO') {
                        await alphaEngine.learnFromTrade(signal, result);
                    }

                    setSignals(prevSignals => {
    // Usamos .map() para criar um NOVO array. Isso Ã© crucial para o React detectar a mudanÃ§a.
    return prevSignals.map(s => {
        // Se o ID do sinal no array for o mesmo que o sinal que estamos processando...
        if (s.id === signal.id) {
            // ...retornamos um NOVO objeto com as propriedades atualizadas.
            return { ...s, status: result, pnl, finalPrice: currentPrice };
        }
        // Caso contrÃ¡rio, apenas retornamos o sinal original sem modificaÃ§Ã£o.
        return s;
    });
});
                       // Substitua o bloco problemÃ¡tico por esta Ãºnica linha de cÃ³digo:

setSignals(prev => prev.map(s => s.id === signal.id ? { ...s, status: result, pnl, finalPrice: currentPrice } : s));


                    showNotification(
                        result === 'ACERTO' 
                            ? `âœ… Sinal confirmado: +${formatBRL(pnl)}`
                            : result === 'ERRO'
                            ? `âŒ Stop atingido: ${formatBRL(pnl)}`
                            : `â±ï¸ Sinal expirado`
                    );
                         // âœ¨ NOVO: Notifica resultado
                    if (window.telegramNotifier && window.telegramNotifier.isEnabled()) {
                        window.telegramNotifier.notifyResult(signal, result, pnl);
                    }
                    verificationTimers.current.delete(signal.id);
                } catch (error) {
                    console.log('Erro na verificaÃ§Ã£o:', error);
                }
            };

            const handleEmergencyStop = () => {
                if (orderExecutorRef.current) {
                    const closedPositions = orderExecutorRef.current.emergencyCloseAll();
                    showNotification(`ðŸš¨ EMERGÃŠNCIA: ${closedPositions.length} posiÃ§Ãµes fechadas`);
                    
                    setSignals(prev => prev.map(s => {
                        if (closedPositions.includes(s.id)) {
                            return { ...s, status: 'CANCELADO', pnl: 0 };
                        }
                        return s;
                    }));
                }
            };

            const playAlert = () => {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (error) {
                    console.log('Audio not available');
                }
            };

            const showNotification = (message) => {
                try {
                    if (!message) return;
                    
                    // Toast na interface
                    setNotification(message);
                    setTimeout(() => setNotification(null), 3000);
                    
                    // âœ… NOTIFICAÃ‡ÃƒO NATIVA DO NAVEGADOR
                    if ("Notification" in window && Notification.permission === "granted") {
                        new Notification("âš¡ Alpha-Learner", {
                            body: message,
                            icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='75'>âš¡</text></svg>",
                            badge: "âš¡",
                            tag: "alpha-learner",
                            requireInteraction: false,
                            silent: false
                        });
                    }
                } catch (error) {
                    console.log('Erro ao mostrar notificaÃ§Ã£o:', error);
                }
            };

            const dismissSignal = (signalId) => {
                try {
                    if (!signalId) return;
                    
                    const timerData = verificationTimers.current.get(signalId);
                    if (timerData) {
                        if (timerData.timer) clearTimeout(timerData.timer);
                        if (timerData.interval) clearInterval(timerData.interval);
                        verificationTimers.current.delete(signalId);
                    }
                    
                    setSignals(prev => prev.filter(s => s && s.id !== signalId));
                } catch (error) {
                    console.log('Erro ao dispensar sinal:', error);
                }
            };

            const copySignalDetails = (signal) => {
                try {
                    if (!signal) {
                        showNotification('Erro: Sinal nÃ£o encontrado');
                        return;
                    }

                    const details = `
Sinal: ${signal.direction || 'N/A'} ${signal.symbol || 'N/A'}
Score: ${signal.score || 0}%
PreÃ§o: ${formatBRL(signal.price)}
Stop: ${formatBRL(signal.stopLoss)}
Alvo: ${formatBRL(signal.takeProfit)}
TF: ${signal.timeframe || 'N/A'}
Status: ${signal.status || 'PENDENTE'}
Fonte: ${signal.dataSource || 'N/A'}
${signal.divergence ? `Divergencia: ${signal.divergence.type}` : ''}
`.trim();
                    if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                        navigator.clipboard.writeText(details)
                            .then(() => showNotification('Detalhes copiados!'))
                            .catch(() => showNotification('Erro ao copiar'));
                    }
                } catch (error) {
                    console.log('Erro ao copiar:', error);
                }
            };

            const formatBRL = (value) => {
                if (value === null || value === undefined) return 'R$ 0,00';
                return value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            };

            return (
                <div className="app">
                    <Sidebar currentView={currentView} setCurrentView={setCurrentView} />
                    <div className="main-content">
                        <Header 
                            isActive={isActive} 
                            setIsActive={setIsActive}
                            mode={mode}
                            setMode={setMode}
                            dataSource={dataSource}
                            orderExecutor={orderExecutor}
                            onEmergencyStop={handleEmergencyStop}
                        />
                        
                        {currentView === 'dashboard' && (
                            <Dashboard 
                                signals={signals}
                                alphaEngine={alphaEngine}
                                minScore={minScore}
                                setMinScore={setMinScore}
                                dismissSignal={dismissSignal}
                                copySignalDetails={copySignalDetails}
                                riskAmount={riskAmount}
                                setRiskAmount={setRiskAmount}
                                maxPositions={maxPositions}
                                setMaxPositions={setMaxPositions}
                                formatBRL={formatBRL}
                                orderExecutor={orderExecutor}
                                mode={mode}
                                updateTrigger={updateTrigger}
                            />
                        )}
                        
                        {currentView === 'performance' && (
                            <Performance 
                                alphaEngine={alphaEngine} 
                                signals={signals} 
                                memoryDB={memoryDB} 
                                formatBRL={formatBRL}
                                updateTrigger={updateTrigger}
                            />
                        )}
                        
                        {currentView === 'ml-engine' && (
                            <MLEngine 
                                alphaEngine={alphaEngine} 
                                memoryDB={memoryDB}
                                updateTrigger={updateTrigger}
                            />
                        )}
                        
                        {currentView === 'robot' && (
                            <RobotView 
                                orderExecutor={orderExecutor}
                                formatBRL={formatBRL}
                                maxPositions={maxPositions}
                                setMaxPositions={setMaxPositions}
                            />
                        )}

                        {currentView === 'audit' && (
                            <AuditView 
                                auditSystem={auditSystem}
                                formatBRL={formatBRL}
                            />
                        )}
                        
                        {currentView === 'connections' && (
                            <ConnectionsView 
                                apiManager={apiManager}
                                showNotification={showNotification}
                            />
                        )}
                        {currentView === 'backtest' && (
                            <BacktestView 
                                alphaEngine={alphaEngine}
                                memoryDB={memoryDB}
                                formatBRL={formatBRL}
                            />
                        )}
                        {currentView === 'advanced-metrics' && (
                            <AdvancedMetrics 
                                auditSystem={auditSystem}
                                alphaEngine={alphaEngine}
                                memoryDB={memoryDB}
                                formatBRL={formatBRL}
                            />
                        )}
                        {currentView === 'telegram' && (
                            <TelegramConfig 
                                telegramNotifier={window.telegramNotifier}
                                showNotification={showNotification}
                            />
                        )}
                        {currentView === 'settings' && (
                            <Settings 
                                minScore={minScore}
                                setMinScore={setMinScore}
                            />
                        )}
                    </div>
                    
                    {notification && (
                        <div className="notification">
                            {notification}
                        </div>
                    )}
                </div>
            );
        }

        /* COMPONENTES REACT - Sidebar e Header */
        
        function Sidebar({ currentView, setCurrentView }) {
            const menuItems = [
                { id: 'dashboard', label: 'Dashboard', icon: 'ðŸ“Š' },
                { id: 'robot', label: 'Painel do RobÃ´', icon: 'ðŸ¤–' },
                { id: 'audit', label: 'Auditoria', icon: 'ðŸ“‹' },
                { id: 'backtest', label: 'Backtesting', icon: 'ðŸ”¬' },
                { id: 'advanced-metrics', label: 'MÃ©tricas AvanÃ§adas', icon: 'ðŸ“ˆ' },
                { id: 'telegram', label: 'Telegram', icon: 'ðŸ“±' },
                { id: 'performance', label: 'Performance', icon: 'ðŸ“ˆ' },
                { id: 'ml-engine', label: 'ML Engine', icon: 'ðŸ§ ' },
                { id: 'connections', label: 'ConexÃµes', icon: 'ðŸ”—' },
                { id: 'settings', label: 'ConfiguraÃ§Ãµes', icon: 'âš™ï¸' }
            ];

            return (
                <div className="sidebar">
                    <div className="logo">âš¡ Alpha-Learner v2.3</div>
                    {menuItems.map(item => (
                        <div 
                            key={item.id}
                            className={`nav-item ${currentView === item.id ? 'active' : ''}`}
                            onClick={() => setCurrentView(item.id)}
                        >
                            {item.icon} {item.label}
                        </div>
                    ))}
                </div>
            );
        }

        function Header({ isActive, setIsActive, mode, setMode, dataSource, orderExecutor, onEmergencyStop }) {
            return (
                <div className="header">
                    <div>
                        <h2>Trading Console</h2>
                        <div className="mode-selector">
                            <div 
                                className={`mode-btn ${mode === 'manual' ? 'active' : ''}`}
                                onClick={() => setMode('manual')}
                            >
                                ðŸŽ¯ Modo Assistente
                            </div>
                            <div 
                                className={`mode-btn ${mode === 'auto' ? 'active' : ''}`}
                                onClick={() => setMode('auto')}
                            >
                                ðŸ¤– Modo RobÃ´
                            </div>
                        </div>
                    </div>
                    <div className="status-indicator">
                        <div className={`toggle-switch ${isActive ? 'active' : ''}`} 
                             onClick={() => setIsActive(!isActive)}>
                        </div>
                        <span>Alpha Engine: {isActive ? 'ATIVO' : 'INATIVO'}</span>
                        <div className="status-dot"></div>
                        
                        <div className={`data-source-badge ${dataSource === 'REAL' ? 'data-source-real' : 'data-source-simulated'}`}>
                            {dataSource === 'REAL' ? 'ðŸŸ¢ DADOS EM TEMPO REAL' : 'ðŸŸ  DADOS SIMULADOS'}
                        </div>
                        
                        {mode === 'auto' && isActive && orderExecutor && (
                            <>
                                <div style={{
                                    background: 'rgba(255, 193, 7, 0.2)',
                                    border: '1px solid #ffc107',
                                    padding: '8px 12px',
                                    borderRadius: '8px',
                                    fontSize: '12px',
                                    fontWeight: 'bold',
                                    color: '#ffc107'
                                }}>
                                    ðŸ¤– EXECUTANDO AUTOMATICAMENTE
                                </div>
                                
                                <button 
                                    className="btn btn-emergency"
                                    onClick={onEmergencyStop}
                                >
                                    ðŸš¨ PARAR TUDO
                                </button>
                            </>
                        )}
                    </div>
                </div>
            );
        }

        /* COMPONENTES REACT - Dashboard e Performance (COM ATUALIZAÃ‡ÃƒO EM TEMPO REAL) */

        function Dashboard({ signals, alphaEngine, minScore, setMinScore, dismissSignal, copySignalDetails, riskAmount, setRiskAmount, maxPositions, setMaxPositions, formatBRL, orderExecutor, mode, updateTrigger }) {
            const [metrics, setMetrics] = useState({ winRate: 0, totalPnL: 0, totalSignals: 0 });

            // NOVO: Atualizar mÃ©tricas quando alphaEngine ou updateTrigger mudar
            useEffect(() => {
                const updateMetrics = () => {
                    try {
                        if (!alphaEngine || !alphaEngine.performance) {
                            setMetrics({ winRate: 0, totalPnL: 0, totalSignals: 0 });
                            return;
                        }
                        setMetrics({
                            winRate: alphaEngine.performance.winRate || 0,
                            totalPnL: alphaEngine.performance.totalPnL || 0,
                            totalSignals: alphaEngine.performance.totalSignals || 0
                        });
                    } catch (error) {
                        console.error('Erro ao atualizar mÃ©tricas:', error);
                    }
                };

                updateMetrics();
                
                // NOVO: Atualizar a cada 5 segundos
                const interval = setInterval(updateMetrics, 5000);
                return () => clearInterval(interval);
            }, [alphaEngine, updateTrigger]);

            return (
                <div>
                    {mode === 'auto' && (
                        <div className="robot-status-panel">
                            <h3>ðŸ¤– Status do RobÃ´</h3>
                            <div className="metric-grid">
                                <div className="metric-card">
                                    <div className="metric-value">
                                        {orderExecutor ? orderExecutor.getActivePositions().length : 0}
                                    </div>
                                    <div className="metric-label">PosiÃ§Ãµes Abertas</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value">
                                        {formatBRL(orderExecutor ? orderExecutor.getVirtualBalance() : 0)}
                                    </div>
                                    <div className="metric-label">Saldo Virtual</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value">
                                        {orderExecutor ? orderExecutor.getExecutionHistory().length : 0}
                                    </div>
                                    <div className="metric-label">Ordens Executadas</div>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="grid">
                        <div className="card">
                            <h3>âš™ï¸ ConfiguraÃ§Ãµes de OperaÃ§Ã£o</h3>
                            <div className="form-group">
                                <label className="form-label">Score MÃ­nimo: {minScore}%</label>
                                <input 
                                    type="range" 
                                    min="20" 
                                    max="95" 
                                    value={minScore}
                                    onChange={(e) => setMinScore(Number(e.target.value))}
                                    className="form-input"
                                />
                            </div>
                            <div className="form-group">
                                <label className="form-label">Valor de Risco (R$)</label>
                                <input 
                                    type="number"
                                    value={riskAmount}
                                    onChange={(e) => setRiskAmount(Number(e.target.value))}
                                    className="form-input"
                                />
                            </div>
                            {mode === 'auto' && (
                                <div className="form-group">
                                    <label className="form-label">MÃ¡ximo de PosiÃ§Ãµes SimultÃ¢neas</label>
                                    <input 
                                        type="number"
                                        min="1"
                                        max="10"
                                        value={maxPositions}
                                        onChange={(e) => {
                                            const val = Number(e.target.value);
                                            setMaxPositions(val);
                                            if (orderExecutor) {
                                                orderExecutor.setMaxPositions(val);
                                            }
                                        }}
                                        className="form-input"
                                    />
                                </div>
                            )}
                        </div>

                        <div className="card">
                            <h3>ðŸ“Š MÃ©tricas em Tempo Real</h3>
                            <div className="metric-grid">
                                <div className="metric-card">
                                    <div className="metric-value">{signals ? signals.length : 0}</div>
                                    <div className="metric-label">Sinais Ativos</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value">{metrics.winRate.toFixed(1)}%</div>
                                    <div className="metric-label">Taxa de Acerto</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value" style={{ 
                                        color: metrics.totalPnL >= 0 ? '#00ff88' : '#ff4757',
                                        fontSize: '24px'
                                    }}>
                                        {formatBRL(metrics.totalPnL)}
                                    </div>
                                    <div className="metric-label">P&L Acumulado</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸŽ¯ Oportunidades de Trading</h3>
                        {!signals || signals.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '40px' }}>
                                ðŸ” Aguardando sinais de alta qualidade...
                            </div>
                        ) : (
                            <div className="grid">
                                {signals.map(signal => (
                                    <SignalCard 
                                        key={signal ? signal.id : Math.random()}
                                        signal={signal}
                                        onDismiss={dismissSignal}
                                        onCopy={copySignalDetails}
                                        formatBRL={formatBRL}
                                        mode={mode}
                                    />
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function Performance({ alphaEngine, signals, memoryDB, formatBRL, updateTrigger }) {
            const [stats, setStats] = useState(null);

            // NOVO: Atualizar estatÃ­sticas quando memoryDB ou updateTrigger mudar
            useEffect(() => {
                const loadStats = async () => {
                    if (memoryDB) {
                        const dbStats = await memoryDB.getStatistics();
                        setStats(dbStats);
                    }
                };
                loadStats();
                
                // NOVO: Atualizar a cada 5 segundos
                const interval = setInterval(loadStats, 5000);
                return () => clearInterval(interval);
            }, [memoryDB, signals, updateTrigger]);

            if (!alphaEngine) return null;

            return (
                <div>
                    <div className="card">
                        <h3>ðŸ“ˆ Performance Geral</h3>
                        <div className="metric-grid">
                            <div className="metric-card">
                                <div className="metric-value">{stats?.total || 0}</div>
                                <div className="metric-label">Total de Sinais</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value">{stats?.successful || 0}</div>
                                <div className="metric-label">Sinais Bem-sucedidos</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value">{(stats?.winRate || 0).toFixed(1)}%</div>
                                <div className="metric-label">Taxa de Acerto</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value" style={{
                                    color: (stats?.totalPnL || 0) >= 0 ? '#00ff88' : '#ff4757'
                                }}>
                                    {formatBRL(stats?.totalPnL || 0)}
                                </div>
                                <div className="metric-label">P&L Total</div>
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸŽ¯ HistÃ³rico Recente</h3>
                        {!signals || signals.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '20px' }}>
                                Nenhum sinal ainda
                            </div>
                        ) : (
                            <div>
                                {signals.filter(s => s && s.status !== 'PENDENTE').map(signal => (
                                    <div key={signal.id} style={{ 
                                        padding: '15px', 
                                        margin: '10px 0',
                                        border: '1px solid rgba(255, 255, 255, 0.1)',
                                        borderRadius: '8px',
                                        background: signal.status === 'ACERTO' ? 
                                            'rgba(0, 255, 136, 0.1)' : 'rgba(255, 71, 87, 0.1)'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                            <div>
                                                <strong>{signal.direction} {signal.symbol}</strong>
                                                <span style={{ marginLeft: '10px', fontSize: '14px', color: '#a0a0a0' }}>
                                                    Score: {signal.score}%
                                                </span>
                                            </div>
                                            <div style={{ 
                                                color: signal.status === 'ACERTO' ? '#00ff88' : '#ff4757',
                                                fontWeight: 'bold'
                                            }}>
                                                {formatBRL(signal.pnl || 0)}
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function MLEngine({ alphaEngine, memoryDB, updateTrigger }) {
            const [weightsHistory, setWeightsHistory] = useState([]);
            const [currentWeights, setCurrentWeights] = useState({});

            // NOVO: Atualizar pesos quando alphaEngine ou updateTrigger mudar
            useEffect(() => {
                const loadHistory = async () => {
                    if (memoryDB) {
                        const history = await memoryDB.getWeightsHistory();
                        setWeightsHistory(history);
                    }
                };
                loadHistory();
                
                // NOVO: Atualizar a cada 5 segundos
                const interval = setInterval(loadHistory, 5000);
                return () => clearInterval(interval);
            }, [memoryDB, updateTrigger]);

            useEffect(() => {
                if (alphaEngine && alphaEngine.weights) {
                    setCurrentWeights(alphaEngine.weights);
                }
                
                // NOVO: Atualizar a cada 5 segundos
                const interval = setInterval(() => {
                    if (alphaEngine && alphaEngine.weights) {
                        setCurrentWeights({...alphaEngine.weights});
                    }
                }, 5000);
                
                return () => clearInterval(interval);
            }, [alphaEngine, updateTrigger]);

            if (!alphaEngine) return null;

            return (
                <div>
                    <div className="card">
                        <h3>ðŸ§  Pesos Adaptativos</h3>
                        <div style={{ marginTop: '20px' }}>
                            {Object.entries(currentWeights).map(([indicator, weight]) => (
                                <div key={indicator} className="weight-item">
                                    <div>
                                        <strong>{indicator.replace('_', ' ').toUpperCase()}</strong>
                                        <br />
                                        <small>{((weight || 0) * 100).toFixed(1)}%</small>
                                    </div>
                                    <div className="weight-bar">
                                        <div 
                                            className="weight-fill" 
                                            style={{ width: `${(weight || 0) * 100}%` }}
                                        ></div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        /* CONTINUAÃ‡ÃƒO DOS COMPONENTES - SignalCard, RobotView, AuditView, ConnectionsView, Settings */

        function SignalCard({ signal, onDismiss, onCopy, formatBRL, mode }) {
            if (!signal) return null;

            const getStatusClass = () => {
                if (signal.status === 'ACERTO') return 'success';
                if (signal.status === 'ERRO') return 'error';
                return '';
            };

            let timeToEntry = 0;
            let minutes = 0;
            let seconds = 0;
            
            try {
                if (signal.entryTime) {
                    const now = new Date();
                    const entryTime = new Date(signal.entryTime);
                    timeToEntry = Math.max(0, Math.floor((entryTime - now) / 1000));
                    minutes = Math.floor(timeToEntry / 60);
                    seconds = timeToEntry % 60;
                }
            } catch (error) {
                timeToEntry = 0;
            }
            
            const formatEntryTime = () => {
                if (signal.status !== 'PENDENTE') return `Status: ${signal.status}`;
                if (timeToEntry <= 0) return "â° ENTRAR AGORA";
                if (timeToEntry < 60) return `â±ï¸ ${seconds}s para entrada`;
                return `â±ï¸ ${minutes}m ${seconds}s para entrada`;
            };

            const getExactEntryTime = () => {
                try {
                    const entryDate = new Date(signal.entryTime);
                    return entryDate.toLocaleTimeString('pt-BR', { 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        second: '2-digit' 
                    });
                } catch {
                    return 'N/A';
                }
            };
            
            return (
                <div className={`signal-card ${timeToEntry <= 30 && timeToEntry > 0 ? 'urgent' : ''} ${getStatusClass()}`}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                        <div className={`signal-direction ${(signal.direction || '').toLowerCase()}`}>
                            {signal.direction === 'BUY' ? 'ðŸŸ¢' : 'ðŸ”´'} {signal.direction || 'N/A'} {signal.symbol || 'N/A'}
                        </div>
                        
                        <div style={{
                            padding: '4px 8px',
                            borderRadius: '12px',
                            fontSize: '10px',
                            fontWeight: 'bold',
                            background: signal.dataSource === 'REAL' ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 165, 0, 0.2)',
                            color: signal.dataSource === 'REAL' ? '#00ff88' : '#ffa500',
                            border: `1px solid ${signal.dataSource === 'REAL' ? '#00ff88' : '#ffa500'}`
                        }}>
                            {signal.dataSource === 'REAL' ? 'ðŸ“¡ Real' : 'ðŸ”® Simulado'}
                        </div>
                    </div>
                    
                    <div>
                        <span className="signal-score">Score: {signal.score || 0}%</span>
                        <span className={`signal-status ${signal.status?.toLowerCase() || 'pending'}`}>
                            {signal.status === 'ACERTO' && 'âœ… ACERTO'}
                            {signal.status === 'ERRO' && 'âŒ ERRO'}
                            {signal.status === 'EXPIRADO' && 'â±ï¸ EXPIRADO'}
                            {signal.status === 'PENDENTE' && 'â³ PENDENTE'}
                            {signal.status === 'CANCELADO' && 'ðŸš« CANCELADO'}
                        </span>
                        {mode === 'auto' && signal.executed && (
                            <span className="signal-status success" style={{ marginLeft: '5px' }}>
                                ðŸ¤– EXECUTADO
                            </span>
                        )}
                    </div>
                    
                    <div style={{ 
                        background: timeToEntry <= 30 && signal.status === 'PENDENTE' ? 'rgba(255, 215, 0, 0.2)' : 'rgba(0, 255, 136, 0.1)',
                        border: `1px solid ${timeToEntry <= 30 && signal.status === 'PENDENTE' ? '#ffd700' : 'rgba(0, 255, 136, 0.3)'}`,
                        padding: '8px 12px',
                        borderRadius: '8px',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        color: timeToEntry <= 30 && signal.status === 'PENDENTE' ? '#ffd700' : '#00ff88',
                        marginBottom: '10px',
                        marginTop: '10px',
                        textAlign: 'center'
                    }}>
                        {formatEntryTime()}
                    </div>

                    {signal.status === 'PENDENTE' && (
                        <div style={{
                            background: 'rgba(0, 184, 217, 0.15)',
                            border: '1px solid rgba(0, 184, 217, 0.4)',
                            borderRadius: '8px',
                            padding: '10px 12px',
                            marginBottom: '10px',
                            fontSize: '13px',
                            fontWeight: 'bold',
                            color: '#00b8d9',
                            textAlign: 'center',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: '8px'
                        }}>
                            <span style={{ fontSize: '16px' }}>ðŸŽ¯</span>
                            <div>
                                <div style={{ fontSize: '11px', opacity: 0.8, marginBottom: '2px' }}>
                                    HORÃRIO EXATO DE ENTRADA
                                </div>
                                <div style={{ fontSize: '16px', letterSpacing: '1px' }}>
                                    {getExactEntryTime()}
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {signal.divergence && (
                        <div style={{
                            background: 'rgba(255, 215, 0, 0.2)',
                            border: '1px solid #ffd700',
                            borderRadius: '8px',
                            padding: '8px 12px',
                            fontSize: '12px',
                            fontWeight: 'bold',
                            color: '#ffd700',
                            marginBottom: '10px'
                        }}>
                            âš¡ DivergÃªncia {signal.divergence.type || 'N/A'}
                        </div>
                    )}
                    
                    {signal.executionDetails && (
                        <div style={{
                            background: 'rgba(0, 255, 136, 0.1)',
                            border: '1px solid #00ff88',
                            borderRadius: '8px',
                            padding: '10px',
                            marginBottom: '10px',
                            fontSize: '12px'
                        }}>
                            <strong>Detalhes da ExecuÃ§Ã£o:</strong>
                            <div>Order ID: {signal.executionDetails.orderId}</div>
                            <div>PreÃ§o Executado: {formatBRL(signal.executionDetails.executedPrice)}</div>
                            <div>Quantidade: {signal.executionDetails.executedQty}</div>
                        </div>
                    )}
                    
                    <div className="signal-details">
                        <div><strong>PreÃ§o:</strong> {formatBRL(signal.price)}</div>
                        <div><strong>Timeframe:</strong> {signal.timeframe || 'N/A'}</div>
                        <div><strong>Stop Loss:</strong> {formatBRL(signal.stopLoss)}</div>
                        <div><strong>Take Profit:</strong> {formatBRL(signal.takeProfit)}</div>
                        <div><strong>R/R:</strong> 1:2</div>
                        <div><strong>Risco:</strong> R$ 100</div>
                    </div>
                    
                    {signal.status !== 'PENDENTE' && signal.pnl !== undefined && (
                        <div style={{ 
                            padding: '12px', 
                            borderRadius: '8px', 
                            background: signal.pnl >= 0 ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 71, 87, 0.2)',
                            marginTop: '10px',
                            border: `1px solid ${signal.pnl >= 0 ? '#00ff88' : '#ff4757'}`
                        }}>
                            <strong>Resultado Final:</strong> 
                            <span style={{ 
                                color: signal.pnl >= 0 ? '#00ff88' : '#ff4757',
                                fontWeight: 'bold',
                                fontSize: '16px',
                                marginLeft: '10px'
                            }}>
                                {formatBRL(signal.pnl)}
                            </span>
                            {signal.finalPrice && (
                                <div style={{ fontSize: '12px', marginTop: '5px', color: '#a0a0a0' }}>
                                    PreÃ§o final: {formatBRL(signal.finalPrice)}
                                </div>
                            )}
                        </div>
                    )}
                    
                    <div className="signal-actions">
                        <button className="btn btn-primary" onClick={() => onCopy && onCopy(signal)}>
                            ðŸ“‹ Copiar
                        </button>
                        <button className="btn btn-secondary" onClick={() => onDismiss && onDismiss(signal.id)}>
                            âŒ Dispensar
                        </button>
                    </div>
                </div>
            );
        }

        function RobotView({ orderExecutor, formatBRL, maxPositions, setMaxPositions }) {
            const [logs, setLogs] = useState([]);
            const [positions, setPositions] = useState([]);
            const [history, setHistory] = useState([]);

            useEffect(() => {
                if (!orderExecutor) return;

                const updateData = () => {
                    setLogs(orderExecutor.getSystemLogs().slice(-50).reverse());
                    setPositions(orderExecutor.getActivePositions());
                    setHistory(orderExecutor.getExecutionHistory().slice(-20).reverse());
                };

                updateData();
                const interval = setInterval(updateData, 2000);
                return () => clearInterval(interval);
            }, [orderExecutor]);

            if (!orderExecutor) {
                return (
                    <div className="card">
                        <h3>â³ Carregando...</h3>
                        <p>Inicializando sistema de execuÃ§Ã£o...</p>
                    </div>
                );
            }

            return (
                <div>
                    <div className="warning-box">
                        âš ï¸ <strong>Painel do RobÃ´:</strong> Sistema de execuÃ§Ã£o automÃ¡tica para conta DEMO. 
                        Todas as ordens sÃ£o executadas em ambiente de testes.
                    </div>

                    <div className="warning-box" style={{ background: 'rgba(255, 193, 7, 0.1)', borderColor: 'rgba(255, 193, 7, 0.3)' }}>
                        â„¹ï¸ <strong>Aviso:</strong> Os dados nÃ£o sÃ£o salvos permanentemente. 
                        Todas as configuraÃ§Ãµes e histÃ³rico sÃ£o mantidos apenas durante a sessÃ£o atual. 
                        Ao recarregar a pÃ¡gina, os dados serÃ£o perdidos.
                    </div>

                    <div className="grid">
                        <div className="card">
                            <h3>ðŸ’° Status Financeiro</h3>
                            <div className="metric-card">
                                <div className="metric-value">
                                    {formatBRL(orderExecutor.getVirtualBalance())}
                                </div>
                                <div className="metric-label">Saldo Virtual DisponÃ­vel</div>
                            </div>
                        </div>

                        <div className="card">
                            <h3>âš™ï¸ ConfiguraÃ§Ãµes de Risco</h3>
                            <div className="form-group">
                                <label className="form-label">
                                    MÃ¡ximo de PosiÃ§Ãµes: {maxPositions}
                                </label>
                                <input 
                                    type="range"
                                    min="1"
                                    max="10"
                                    value={maxPositions}
                                    onChange={(e) => {
                                        const val = Number(e.target.value);
                                        setMaxPositions(val);
                                        orderExecutor.setMaxPositions(val);
                                    }}
                                    className="form-input"
                                />
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸ“Š PosiÃ§Ãµes Abertas ({positions.length})</h3>
                        {positions.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '20px' }}>
                                Nenhuma posiÃ§Ã£o aberta no momento
                            </div>
                        ) : (
                            positions.map(pos => (
                                <div key={pos.signal.id} className="position-card">
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
                                        <strong>
                                            {pos.signal.direction} {pos.signal.symbol}
                                        </strong>
                                        <span style={{ fontSize: '12px', color: '#a0a0a0' }}>
                                            {new Date(pos.openTime).toLocaleTimeString()}
                                        </span>
                                    </div>
                                    <div style={{ fontSize: '13px' }}>
                                        <div>Entrada: {formatBRL(pos.orderResult.executedPrice)}</div>
                                        <div>Stop: {formatBRL(pos.signal.stopLoss)}</div>
                                        <div>Alvo: {formatBRL(pos.signal.takeProfit)}</div>
                                        <div>Order ID: {pos.orderResult.orderId}</div>
                                    </div>
                                </div>
                            ))
                        )}
                    </div>

                    <div className="card">
                        <h3>ðŸ“œ HistÃ³rico de ExecuÃ§Ãµes</h3>
                        {history.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '20px' }}>
                                Nenhuma execuÃ§Ã£o ainda
                            </div>
                        ) : (
                            <div>
                                {history.map((exec, idx) => (
                                    <div key={idx} style={{
                                        padding: '10px',
                                        margin: '5px 0',
                                        border: '1px solid rgba(255, 255, 255, 0.1)',
                                        borderRadius: '6px',
                                        fontSize: '12px'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                            <strong>{exec.direction} {exec.symbol}</strong>
                                            <span>{new Date(exec.timestamp).toLocaleString()}</span>
                                        </div>
                                        <div style={{ marginTop: '5px', color: '#a0a0a0' }}>
                                            PreÃ§o: {formatBRL(exec.orderResult.executedPrice)} | 
                                            Order: {exec.orderResult.orderId}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    <div className="card">
                        <h3>ðŸ“‹ Logs do Sistema</h3>
                        <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
                            {logs.length === 0 ? (
                                <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '20px' }}>
                                    Nenhum log ainda
                                </div>
                            ) : (
                                logs.map((log, idx) => (
                                    <div key={idx} className={`log-entry ${log.type}`}>
                                        <span style={{ color: '#00ff88' }}>
                                            {new Date(log.timestamp).toLocaleTimeString()}
                                        </span> {log.message}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function AuditView({ auditSystem, formatBRL }) {
            const [activeTab, setActiveTab] = useState('logs');
            const [logs, setLogs] = useState([]);
            const [alerts, setAlerts] = useState([]);
            const [perfByHour, setPerfByHour] = useState({});
            const [perfByScore, setPerfByScore] = useState({});
            const [indicatorPerf, setIndicatorPerf] = useState({});

            useEffect(() => {
                if (!auditSystem) return;
                
                const updateData = () => {
                    setLogs(auditSystem.getRecentLogs(50));
                    setAlerts(auditSystem.getHealthAlerts());
                    setPerfByHour(auditSystem.getPerformanceByHour());
                    setPerfByScore(auditSystem.getPerformanceByScore());
                    setIndicatorPerf(auditSystem.getIndicatorPerformance());
                };

                updateData();
                const interval = setInterval(updateData, 5000);
                return () => clearInterval(interval);
            }, [auditSystem]);

            const handleExport = () => {
                if (!auditSystem) return;
                
                const csv = auditSystem.exportToCSV();
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `audit_${new Date().toISOString().split('T')[0]}.csv`;
                link.click();
            };

            const handleDiagnostic = () => {
                console.log('====== DIAGNÃ“STICO DO SISTEMA DE AUDITORIA ======');
                console.log('auditSystem existe?', !!auditSystem);
                console.log('window.auditSystemRef existe?', !!window.auditSystemRef);
                console.log('SÃ£o o mesmo objeto?', auditSystem === window.auditSystemRef);
                console.log('NÃºmero de logs:', auditSystem ? auditSystem.auditLogs.length : 0);
                console.log('Debug ativo?', window.debugAudit);
                console.log('===============================================');
                
                if (auditSystem) {
                    const validation = auditSystem.validateData();
                    
                    let message = `Sistema OK!\n\nLogs totais: ${validation.total}\n`;
                    message += `Com resultado: ${validation.withOutcome}\n`;
                    message += `Acertos: ${validation.acertos}\n`;
                    message += `Erros: ${validation.erros}\n`;
                    message += `Expirados: ${validation.expirados}\n\n`;
                    
                    if (validation.withOutcome === 0) {
                        message += 'âš ï¸ NENHUM sinal tem resultado final!\n';
                        message += 'O sistema pode nÃ£o estar verificando os sinais corretamente.';
                    } else if (validation.expirados > validation.withOutcome * 0.8) {
                        message += `âš ï¸ ${(validation.expirados/validation.withOutcome*100).toFixed(1)}% dos sinais estÃ£o EXPIRANDO!\n`;
                        message += 'Considere ajustar os alvos ou timeouts.';
                    }
                    
                    message += '\n\nVerifique o console para mais detalhes.';
                    alert(message);
                } else {
                    alert('ERRO: Sistema de auditoria nÃ£o inicializado!');
                }
            };

            const handleClearOldData = () => {
                if (!auditSystem) return;
                if (confirm('Limpar logs com mais de 7 dias?')) {
                    auditSystem.clearOldData(7);
                    setLogs(auditSystem.getRecentLogs(50));
                    alert('Dados antigos removidos!');
                }
            };

            const handleValidateData = () => {
                if (!auditSystem) return;
                
                console.log('\nðŸ” === VALIDAÃ‡ÃƒO MANUAL ===');
                const validation = auditSystem.validateData();
                
                let alertMsg = 'ðŸ“Š VALIDAÃ‡ÃƒO DOS DADOS\n\n';
                alertMsg += `Total de logs: ${validation.total}\n`;
                alertMsg += `Com resultado final: ${validation.withOutcome}\n`;
                alertMsg += `â”œâ”€ Acertos: ${validation.acertos}\n`;
                alertMsg += `â”œâ”€ Erros: ${validation.erros}\n`;
                alertMsg += `â””â”€ Expirados: ${validation.expirados}\n\n`;
                
                if (validation.withOutcome === 0) {
                    alertMsg += 'âŒ PROBLEMA: Nenhum sinal tem resultado!\n';
                    alertMsg += 'O sistema nÃ£o estÃ¡ verificando os sinais.';
                } else {
                    const winRate = validation.withOutcome > 0 ? (validation.acertos / validation.withOutcome * 100) : 0;
                    const expiredRate = validation.withOutcome > 0 ? (validation.expirados / validation.withOutcome * 100) : 0;
                    
                    alertMsg += `Win Rate: ${winRate.toFixed(1)}%\n`;
                    alertMsg += `Taxa de ExpiraÃ§Ã£o: ${expiredRate.toFixed(1)}%\n\n`;
                    
                    if (expiredRate > 80) {
                        alertMsg += 'âš ï¸ Muitos sinais expirando!\n';
                        alertMsg += 'Ajuste os alvos ou timeouts.';
                    } else if (expiredRate > 50) {
                        alertMsg += 'âš ï¸ Taxa de expiraÃ§Ã£o alta.';
                    } else {
                        alertMsg += 'âœ… Sistema funcionando corretamente!';
                    }
                }
                
                alert(alertMsg);
            };

            if (!auditSystem) {
                return <div className="card"><h3>Carregando auditoria...</h3></div>;
            }

            return (
                <div>
                    <div className="warning-box">
                        ðŸ“Š Sistema de Auditoria e ValidaÃ§Ã£o
                        <div style={{ marginTop: '8px', fontSize: '11px' }}>
                            Logs coletados: <strong>{logs.length}</strong> | 
                            Debug: <strong>{window.debugAudit ? 'ATIVO' : 'INATIVO'}</strong> |
                            Sistema: <strong>{auditSystem ? 'OK' : 'ERRO'}</strong>
                        </div>
                    </div>

                    {logs.length === 0 && auditSystem && (
                        <div className="warning-box">
                            âš ï¸ Nenhum log coletado ainda. Use o botÃ£o "DiagnÃ³stico" para verificar o status.
                        </div>
                    )}

                    {alerts.length > 0 && (
                        <div className="card">
                            <h3>âš ï¸ Alertas</h3>
                            {alerts.map((alert, idx) => (
                                <div key={idx} className={alert.type === 'error' ? 'error-box' : 'warning-box'}>
                                    {alert.message}
                                </div>
                            ))}
                        </div>
                    )}

                    <div className="card">
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
                            <h3>Dados de Auditoria</h3>
                            <div style={{ display: 'flex', gap: '10px' }}>
                                <button className="btn btn-secondary" onClick={handleDiagnostic}>
                                    ðŸ” DiagnÃ³stico
                                </button>
                                <button className="btn btn-secondary" onClick={handleValidateData}>
                                    âœ… Validar Dados
                                </button>
                                <button className="btn btn-secondary" onClick={handleClearOldData}>
                                    ðŸ—‘ï¸ Limpar Antigos
                                </button>
                                <button className="btn btn-primary" onClick={handleExport}>
                                    ðŸ“¥ Exportar CSV
                                </button>
                            </div>
                        </div>

                        <div className="mode-selector">
                            <div className={`mode-btn ${activeTab === 'logs' ? 'active' : ''}`} onClick={() => setActiveTab('logs')}>
                                ðŸ“‹ Logs
                            </div>
                            <div className={`mode-btn ${activeTab === 'hour' ? 'active' : ''}`} onClick={() => setActiveTab('hour')}>
                                â° Por HorÃ¡rio
                            </div>
                            <div className={`mode-btn ${activeTab === 'score' ? 'active' : ''}`} onClick={() => setActiveTab('score')}>
                                ðŸ“Š Por Score
                            </div>
                            <div className={`mode-btn ${activeTab === 'indicators' ? 'active' : ''}`} onClick={() => setActiveTab('indicators')}>
                                ðŸŽ¯ Indicadores
                            </div>
                        </div>

                        {activeTab === 'logs' && (
                            <div style={{ maxHeight: '600px', overflowY: 'auto', marginTop: '20px' }}>
                                {logs.length === 0 ? (
                                    <div style={{ textAlign: 'center', padding: '40px', color: '#a0a0a0' }}>
                                        Nenhum log ainda
                                    </div>
                                ) : (
                                    logs.map((log, idx) => (
                                        <div key={idx} style={{
                                            padding: '15px',
                                            margin: '10px 0',
                                            border: '1px solid rgba(255, 255, 255, 0.1)',
                                            borderRadius: '8px',
                                            background: log.outcome === 'ACERTO' ? 'rgba(0, 255, 136, 0.05)' : 
                                                       log.outcome === 'ERRO' ? 'rgba(255, 71, 87, 0.05)' : 'rgba(255, 255, 255, 0.02)'
                                        }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                <strong>{log.metadata.direction} {log.metadata.symbol}</strong>
                                                <span style={{ fontSize: '12px', color: '#a0a0a0' }}>
                                                    {new Date(log.generatedAt).toLocaleString('pt-BR')}
                                                </span>
                                            </div>
                                            <div style={{ fontSize: '13px', color: '#c0c0c0', marginTop: '10px' }}>
                                                <div>Score: {log.scoreRange} | HorÃ¡rio: {log.hourOfDay}h</div>
                                                <div>PreÃ§o: {formatBRL(log.prices.theoretical)}</div>
                                                {log.outcome && (
                                                    <div style={{ marginTop: '8px', color: log.outcome === 'ACERTO' ? '#00ff88' : '#ff4757' }}>
                                                        {log.outcome} | P&L: {formatBRL(log.prices.finalPnL)}
                                                        <div style={{ fontSize: '11px', marginTop: '3px' }}>{log.reason}</div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    ))
                                )}
                            </div>
                        )}

                        {activeTab === 'hour' && (
                            <div style={{ marginTop: '20px' }}>
                                {Object.keys(perfByHour).length === 0 ? (
                                    <div style={{ textAlign: 'center', padding: '40px', color: '#a0a0a0' }}>
                                        Dados insuficientes
                                    </div>
                                ) : (
                                    Object.entries(perfByHour).sort((a, b) => Number(a[0]) - Number(b[0])).map(([hour, stats]) => {
                                        const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                                        return (
                                            <div key={hour} style={{
                                                padding: '15px',
                                                margin: '10px 0',
                                                border: '1px solid rgba(255, 255, 255, 0.1)',
                                                borderRadius: '8px'
                                            }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                    <div>
                                                        <strong>{hour}:00h</strong>
                                                        <div style={{ fontSize: '13px', color: '#a0a0a0', marginTop: '5px' }}>
                                                            {stats.total} sinais | {stats.wins} vitÃ³rias
                                                        </div>
                                                    </div>
                                                    <div style={{ textAlign: 'right' }}>
                                                        <div style={{ fontSize: '24px', color: winRate >= 50 ? '#00ff88' : '#ff4757' }}>
                                                            {winRate.toFixed(1)}%
                                                        </div>
                                                        <div style={{ fontSize: '14px', color: stats.totalPnL >= 0 ? '#00ff88' : '#ff4757' }}>
                                                            {formatBRL(stats.totalPnL)}
                                                        </div>
                                                          </div>
                                                </div>
                                            </div>
                                        );
                                    })
                                )}
                            </div>
                        )}

                        {activeTab === 'score' && (
                            <div style={{ marginTop: '20px' }}>
                                {Object.keys(perfByScore).length === 0 ? (
                                    <div style={{ textAlign: 'center', padding: '40px', color: '#a0a0a0' }}>
                                        Dados insuficientes
                                    </div>
                                ) : (
                                    Object.entries(perfByScore).map(([range, stats]) => {
                                        const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                                        return (
                                            <div key={range} style={{
                                                padding: '15px',
                                                margin: '10px 0',
                                                border: '1px solid rgba(255, 255, 255, 0.1)',
                                                borderRadius: '8px'
                                            }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                    <div>
                                                        <strong>Score: {range}%</strong>
                                                        <div style={{ fontSize: '13px', color: '#a0a0a0', marginTop: '5px' }}>
                                                            {stats.total} sinais | {stats.wins} vitÃ³rias
                                                        </div>
                                                    </div>
                                                    <div style={{ fontSize: '20px', color: winRate >= 50 ? '#00ff88' : '#ff4757' }}>
                                                        {winRate.toFixed(1)}%
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })
                                )}
                            </div>
                        )}

                        {activeTab === 'indicators' && (
                            <div style={{ marginTop: '20px' }}>
                                {Object.keys(indicatorPerf).length === 0 ? (
                                    <div style={{ textAlign: 'center', padding: '40px', color: '#a0a0a0' }}>
                                        Dados insuficientes
                                    </div>
                                ) : (
                                    Object.entries(indicatorPerf).map(([indicator, stats]) => {
                                        const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                                        return (
                                            <div key={indicator} style={{
                                                padding: '15px',
                                                margin: '10px 0',
                                                border: '1px solid rgba(255, 255, 255, 0.1)',
                                                borderRadius: '8px'
                                            }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                    <div>
                                                        <strong>{indicator.toUpperCase()}</strong>
                                                        <div style={{ fontSize: '13px', color: '#a0a0a0', marginTop: '5px' }}>
                                                            {stats.total} sinais
                                                        </div>
                                                    </div>
                                                    <div style={{ fontSize: '24px', color: winRate >= 50 ? '#00ff88' : '#ff4757' }}>
                                                        {winRate.toFixed(1)}%
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function ConnectionsView({ apiManager, showNotification }) {
            const [selectedProvider, setSelectedProvider] = useState('BINANCE');
            const [apiKey, setApiKey] = useState('');
            const [secretKey, setSecretKey] = useState('');
            const [testing, setTesting] = useState(false);
            const [testResult, setTestResult] = useState(null);
            const [updateTrigger, setUpdateTrigger] = useState(0);

            if (!apiManager) {
                return <div className="card"><h3>â³ Carregando...</h3></div>;
            }

            const handleTest = async () => {
                if (!apiKey.trim()) {
                    showNotification('Insira a API Key');
                    return;
                }

                setTesting(true);
                setTestResult(null);

                try {
                    const result = await testAPIConnection(selectedProvider, apiKey, secretKey || null);
                    setTestResult(result);
                    
                    if (result.success) {
                        apiManager.addConnection(selectedProvider, apiKey, secretKey || null);
                        apiManager.updateStatus(selectedProvider, 'connected');
                        apiManager.setActive(selectedProvider);
                        showNotification('âœ… ConexÃ£o estabelecida!');
                        setUpdateTrigger(prev => prev + 1);
                    } else {
                        showNotification(`âŒ ${result.message}`);
                    }
                } catch (error) {
                    setTestResult({ success: false, message: `Erro: ${error.message}` });
                } finally {
                    setTesting(false);
                }
            };

            const handleDisconnect = (provider) => {
                apiManager.removeConnection(provider);
                showNotification('ConexÃ£o removida');
                setUpdateTrigger(prev => prev + 1);
            };

            const connectedProviders = [];
            if (apiManager.connections) {
                apiManager.connections.forEach((conn, provider) => {
                    if (conn.status === 'connected') {
                        connectedProviders.push(provider);
                    }
                });
            }

            return (
                <div>
                    <div className="warning-box">
                        âš ï¸ Use chaves da Testnet para testes sem risco
                    </div>

                    <div className="card">
                        <h3>ðŸ”— Nova ConexÃ£o</h3>
                        
                        <div className="form-group">
                            <label className="form-label">Provedor</label>
                            <select 
                                className="form-select"
                                value={selectedProvider}
                                onChange={(e) => setSelectedProvider(e.target.value)}
                            >
                                {Object.entries(API_PROVIDERS).map(([key, provider]) => (
                                    <option key={key} value={key}>
                                        {provider.icon} {provider.name}
                                    </option>
                                ))}
                            </select>
                        </div>

                        <div className="form-group">
                            <label className="form-label">API Key</label>
                            <input 
                                type="password"
                                className="form-input"
                                value={apiKey}
                                onChange={(e) => setApiKey(e.target.value)}
                            />
                        </div>

                        {API_PROVIDERS[selectedProvider].requiresSecret && (
                            <div className="form-group">
                                <label className="form-label">Secret Key</label>
                                <input 
                                    type="password"
                                    className="form-input"
                                    value={secretKey}
                                    onChange={(e) => setSecretKey(e.target.value)}
                                />
                            </div>
                        )}

                        <button 
                            className="btn btn-primary" 
                            onClick={handleTest}
                            disabled={testing}
                            style={{ width: '100%' }}
                        >
                            {testing ? 'ðŸ”„ Testando...' : 'ðŸ”— Salvar e Testar'}
                        </button>

                        {testResult && (
                            <div className={testResult.success ? 'success-box' : 'error-box'} style={{ marginTop: '15px' }}>
                                {testResult.message}
                            </div>
                        )}
                    </div>

                    <div className="card">
                        <h3>ðŸ“Š ConexÃµes Ativas</h3>
                        {connectedProviders.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '40px' }}>
                                Nenhuma conexÃ£o ativa
                            </div>
                        ) : (
                            connectedProviders.map(provider => {
                                const providerInfo = API_PROVIDERS[provider];
                                const isActive = apiManager.activeProvider === provider;
                                
                                return (
                                    <div key={provider} className={`api-provider-card ${isActive ? 'connected' : ''}`}>
                                        <div style={{ display: 'flex', alignItems: 'center', marginBottom: '15px' }}>
                                            <div style={{ flex: 1 }}>
                                                <h4 style={{ color: '#00ff88', margin: 0 }}>
                                                    {providerInfo.icon} {providerInfo.name}
                                                </h4>
                                            </div>
                                            <div className="api-status-badge api-status-connected">
                                                âœ… Conectado
                                            </div>
                                        </div>

                                        <div style={{ display: 'flex', gap: '10px' }}>
                                            {!isActive && (
                                                <button 
                                                    className="btn btn-primary"
                                                    onClick={() => {
                                                        apiManager.setActive(provider);
                                                        showNotification(`${providerInfo.name} ativado`);
                                                        setUpdateTrigger(prev => prev + 1);
                                                    }}
                                                >
                                                    âš¡ Ativar
                                                </button>
                                            )}
                                            <button 
                                                className="btn btn-danger"
                                                onClick={() => handleDisconnect(provider)}
                                            >
                                                ðŸ—‘ï¸ Remover
                                            </button>
                                        </div>
                                    </div>
                                );
                            })
                        )}
                    </div>
                </div>
            );
        }
function BacktestView({ alphaEngine, memoryDB, formatBRL }) {
            const [config, setConfig] = useState({
                startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                endDate: new Date().toISOString().split('T')[0],
                initialBalance: 10000,
                riskPerTrade: 100,
                minScore: 60,
                timeframe: 'M5'
            });
            const [results, setResults] = useState(null);
            const [isRunning, setIsRunning] = useState(false);
            const [progress, setProgress] = useState(0);
            const backtestEngineRef = useRef(null);

            useEffect(() => {
                if (alphaEngine && memoryDB) {
                    backtestEngineRef.current = new BacktestEngine(alphaEngine, memoryDB);
                }
            }, [alphaEngine, memoryDB]);

            const handleRunBacktest = async () => {
                if (!backtestEngineRef.current) return;
                
                setIsRunning(true);
                setResults(null);
                setProgress(0);
                
                try {
                    const result = await backtestEngineRef.current.runBacktest(config);
                    setResults(result);
                } catch (error) {
                    alert(`Erro no backtest: ${error.message}`);
                } finally {
                    setIsRunning(false);
                    setProgress(100);
                }
            };

            const handleExport = () => {
                if (!backtestEngineRef.current) return;
                
                const csv = backtestEngineRef.current.exportResults();
                if (csv) {
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `backtest_${new Date().toISOString().split('T')[0]}.csv`;
                    link.click();
                }
            };

            return (
                <div>
                    <div className="warning-box">
                        ðŸ”¬ <strong>Backtesting:</strong> Teste suas estratÃ©gias com dados histÃ³ricos antes de operar com dinheiro real.
                    </div>

                    <div className="card">
                        <h3>âš™ï¸ ConfiguraÃ§Ã£o do Backtest</h3>
                        
                        <div className="grid">
                            <div className="form-group">
                                <label className="form-label">Data Inicial</label>
                                <input 
                                    type="date"
                                    className="form-input"
                                    value={config.startDate}
                                    onChange={(e) => setConfig({...config, startDate: e.target.value})}
                                    disabled={isRunning}
                                />
                            </div>
                            
                            <div className="form-group">
                                <label className="form-label">Data Final</label>
                                <input 
                                    type="date"
                                    className="form-input"
                                    value={config.endDate}
                                    onChange={(e) => setConfig({...config, endDate: e.target.value})}
                                    disabled={isRunning}
                                />
                            </div>
                        </div>

                        <div className="grid">
                            <div className="form-group">
                                <label className="form-label">Saldo Inicial (R$)</label>
                                <input 
                                    type="number"
                                    className="form-input"
                                    value={config.initialBalance}
                                    onChange={(e) => setConfig({...config, initialBalance: Number(e.target.value)})}
                                    disabled={isRunning}
                                />
                            </div>
                            
                            <div className="form-group">
                                <label className="form-label">Risco por Trade (R$)</label>
                                <input 
                                    type="number"
                                    className="form-input"
                                    value={config.riskPerTrade}
                                    onChange={(e) => setConfig({...config, riskPerTrade: Number(e.target.value)})}
                                    disabled={isRunning}
                                />
                            </div>
                        </div>

                        <div className="form-group">
                            <label className="form-label">Score MÃ­nimo: {config.minScore}%</label>
                            <input 
                                type="range"
                                min="30"
                                max="90"
                                value={config.minScore}
                                onChange={(e) => setConfig({...config, minScore: Number(e.target.value)})}
                                className="form-input"
                                disabled={isRunning}
                            />
                        </div>

                        <button 
                            className="btn btn-primary"
                            onClick={handleRunBacktest}
                            disabled={isRunning}
                            style={{ width: '100%', fontSize: '16px', padding: '15px' }}
                        >
                            {isRunning ? 'â³ Executando Backtest...' : 'ðŸš€ Iniciar Backtest'}
                        </button>

                        {isRunning && (
                            <div style={{ marginTop: '20px' }}>
                                <div style={{ 
                                    height: '8px', 
                                    background: 'rgba(255,255,255,0.1)', 
                                    borderRadius: '4px',
                                    overflow: 'hidden'
                                }}>
                                    <div style={{
                                        height: '100%',
                                        width: `${progress}%`,
                                        background: '#00ff88',
                                        transition: 'width 0.3s ease'
                                    }}></div>
                                </div>
                                <div style={{ textAlign: 'center', marginTop: '10px', color: '#a0a0a0' }}>
                                    Processando dados histÃ³ricos...
                                </div>
                            </div>
                        )}
                    </div>

                    {results && results.stats && (
                        <>
                            <div className="card">
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
                                    <h3>ðŸ“Š Resultados do Backtest</h3>
                                    <button className="btn btn-primary" onClick={handleExport}>
                                        ðŸ“¥ Exportar CSV
                                    </button>
                                </div>

                                <div className="metric-grid">
                                    <div className="metric-card">
                                        <div className="metric-value">{results.stats.totalTrades}</div>
                                        <div className="metric-label">Total de Trades</div>
                                    </div>
                                    <div className="metric-card">
                                        <div className="metric-value" style={{ color: '#00ff88' }}>{results.stats.wins}</div>
                                        <div className="metric-label">VitÃ³rias</div>
                                    </div>
                                    <div className="metric-card">
                                        <div className="metric-value" style={{ color: '#ff4757' }}>{results.stats.losses}</div>
                                        <div className="metric-label">Derrotas</div>
                                    </div>
                                    <div className="metric-card">
                                        <div className="metric-value">{results.stats.winRate.toFixed(1)}%</div>
                                        <div className="metric-label">Win Rate</div>
                                    </div>
                                </div>

                                <div className="metric-grid" style={{ marginTop: '20px' }}>
                                    <div className="metric-card">
                                        <div className="metric-value" style={{ 
                                            color: results.stats.totalReturn >= 0 ? '#00ff88' : '#ff4757',
                                            fontSize: '28px'
                                        }}>
                                            {results.stats.totalReturn >= 0 ? '+' : ''}{results.stats.totalReturn.toFixed(2)}%
                                        </div>
                                        <div className="metric-label">Retorno Total</div>
                                    </div>
                                    <div className="metric-card">
                                        <div className="metric-value" style={{ color: '#ff4757' }}>
                                            {results.stats.maxDrawdown.toFixed(2)}%
                                        </div>
                                        <div className="metric-label">Max Drawdown</div>
                                    </div>
                                    <div className="metric-card">
                                        <div className="metric-value">{results.stats.sharpeRatio.toFixed(2)}</div>
                                        <div className="metric-label">Sharpe Ratio</div>
                                    </div>
                                    <div className="metric-card">
                                        <div className="metric-value">{results.stats.profitFactor.toFixed(2)}</div>
                                        <div className="metric-label">Profit Factor</div>
                                    </div>
                                </div>

                                <div style={{ marginTop: '30px', padding: '20px', background: 'rgba(255,255,255,0.05)', borderRadius: '12px' }}>
                                    <h4 style={{ marginBottom: '15px', color: '#00ff88' }}>ðŸ’° Resumo Financeiro</h4>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px', fontSize: '14px' }}>
                                        <div>
                                            <strong>Saldo Inicial:</strong>
                                            <div style={{ color: '#00ff88', fontSize: '18px', marginTop: '5px' }}>
                                                {formatBRL(config.initialBalance)}
                                            </div>
                                        </div>
                                        <div>
                                            <strong>Saldo Final:</strong>
                                            <div style={{ 
                                                color: results.finalBalance >= config.initialBalance ? '#00ff88' : '#ff4757',
                                                fontSize: '18px',
                                                marginTop: '5px'
                                            }}>
                                                {formatBRL(results.finalBalance)}
                                            </div>
                                        </div>
                                        <div>
                                            <strong>Lucro MÃ©dio:</strong>
                                            <div style={{ color: '#00ff88', marginTop: '5px' }}>
                                                {formatBRL(results.stats.avgWin)}
                                            </div>
                                        </div>
                                        <div>
                                            <strong>Perda MÃ©dia:</strong>
                                            <div style={{ color: '#ff4757', marginTop: '5px' }}>
                                                {formatBRL(results.stats.avgLoss)}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div className="card">
                                <h3>ðŸ“ˆ HistÃ³rico de Trades</h3>
                                <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
                                    {results.trades.slice(0, 50).map((trade, idx) => (
                                        <div key={idx} style={{
                                            padding: '15px',
                                            margin: '10px 0',
                                            border: '1px solid rgba(255,255,255,0.1)',
                                            borderRadius: '8px',
                                            background: trade.result === 'WIN' ? 'rgba(0,255,136,0.05)' : 
                                                       trade.result === 'LOSS' ? 'rgba(255,71,87,0.05)' : 'rgba(255,255,255,0.02)'
                                        }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
                                                <strong>{trade.direction} @ {formatBRL(trade.entryPrice)}</strong>
                                                <span style={{ 
                                                    color: trade.result === 'WIN' ? '#00ff88' : trade.result === 'LOSS' ? '#ff4757' : '#ffc107',
                                                    fontWeight: 'bold'
                                                }}>
                                                    {trade.result === 'WIN' ? 'âœ…' : trade.result === 'LOSS' ? 'âŒ' : 'â±ï¸'} {trade.result}
                                                </span>
                                            </div>
                                            <div style={{ fontSize: '13px', color: '#a0a0a0' }}>
                                                <div>Entrada: {new Date(trade.entryTime).toLocaleString('pt-BR')}</div>
                                                <div>SaÃ­da: {formatBRL(trade.exitPrice)} | P&L: {formatBRL(trade.pnl)}</div>
                                                <div>Saldo apÃ³s: {formatBRL(trade.balance)}</div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                {results.trades.length > 50 && (
                                    <div style={{ textAlign: 'center', color: '#a0a0a0', marginTop: '15px' }}>
                                        Mostrando 50 de {results.trades.length} trades. Exporte para ver todos.
                                    </div>
                                )}
                            </div>
                        </>
                    )}
                </div>
            );
        }

        /* ========================================
           DASHBOARD DE MÃ‰TRICAS AVANÃ‡ADAS
           ======================================== */

        function AdvancedMetrics({ auditSystem, alphaEngine, memoryDB, formatBRL }) {
            const [metrics, setMetrics] = useState(null);
            const [timeRange, setTimeRange] = useState('7d');

            useEffect(() => {
                const calculateMetrics = async () => {
                    if (!auditSystem || !alphaEngine || !memoryDB) return;

                    const logs = auditSystem.getRecentLogs(200);
                    const completedLogs = logs.filter(l => l.outcome && l.outcome !== 'PENDENTE');
                    
                    if (completedLogs.length === 0) {
                        setMetrics(null);
                        return;
                    }

                    const cutoffDate = new Date();
                    if (timeRange === '24h') cutoffDate.setHours(cutoffDate.getHours() - 24);
                    else if (timeRange === '7d') cutoffDate.setDate(cutoffDate.getDate() - 7);
                    else if (timeRange === '30d') cutoffDate.setDate(cutoffDate.getDate() - 30);
                    
                    const filteredLogs = completedLogs.filter(l => 
                        new Date(l.generatedAt) >= cutoffDate
                    );

                    if (filteredLogs.length === 0) {
                        setMetrics(null);
                        return;
                    }

                    const wins = filteredLogs.filter(l => l.outcome === 'ACERTO');
                    const losses = filteredLogs.filter(l => l.outcome === 'ERRO');
                    const expired = filteredLogs.filter(l => l.outcome === 'EXPIRADO');

                    const totalPnL = filteredLogs.reduce((sum, l) => sum + (l.prices.finalPnL || 0), 0);
                    const winRate = (wins.length / filteredLogs.length) * 100;
                    const lossRate = (losses.length / filteredLogs.length) * 100;
                    const expiredRate = (expired.length / filteredLogs.length) * 100;

                    const totalWins = wins.reduce((sum, l) => sum + (l.prices.finalPnL || 0), 0);
                    const totalLosses = Math.abs(losses.reduce((sum, l) => sum + (l.prices.finalPnL || 0), 0));
                    const profitFactor = totalLosses > 0 ? totalWins / totalLosses : 0;

                    const avgWin = wins.length > 0 ? totalWins / wins.length : 0;
                    const avgLoss = losses.length > 0 ? totalLosses / losses.length : 0;
                    const expectancy = (winRate / 100 * avgWin) - (lossRate / 100 * avgLoss);

                    const kellyCriterion = winRate > 0 ? 
                        (winRate / 100 - (lossRate / 100)) / (avgWin / avgLoss || 1) : 0;

                    const returns = filteredLogs.map(l => (l.prices.finalPnL || 0) / 100);
                    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
                    const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
                    const stdDev = Math.sqrt(variance);
                    const sharpeRatio = stdDev !== 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0;

                    let peak = 0;
                    let maxDrawdown = 0;
                    let runningPnL = 0;

                    filteredLogs.forEach(log => {
                        runningPnL += log.prices.finalPnL || 0;
                        if (runningPnL > peak) {
                            peak = runningPnL;
                        } else {
                            const currentDrawdown = peak - runningPnL;
                            if (currentDrawdown > maxDrawdown) {
                                maxDrawdown = currentDrawdown;
                            }
                        }
                    });

                    let currentStreak = 0;
                    let maxWinStreak = 0;
                    let maxLossStreak = 0;
                    let lastOutcome = null;

                    filteredLogs.forEach(log => {
                        if (log.outcome === 'ACERTO') {
                            if (lastOutcome === 'ACERTO') {
                                currentStreak++;
                            } else {
                                currentStreak = 1;
                            }
                            if (currentStreak > maxWinStreak) maxWinStreak = currentStreak;
                        } else if (log.outcome === 'ERRO') {
                            if (lastOutcome === 'ERRO') {
                                currentStreak++;
                            } else {
                                currentStreak = 1;
                            }
                            if (currentStreak > maxLossStreak) maxLossStreak = currentStreak;
                        } else {
                            currentStreak = 0;
                        }
                        lastOutcome = log.outcome;
                    });

                    const recoveryFactor = maxDrawdown > 0 ? totalPnL / maxDrawdown : 0;

                    const durations = filteredLogs
                        .filter(l => l.outcomeTime)
                        .map(l => (new Date(l.outcomeTime) - new Date(l.generatedAt)) / 60000);
                    const avgDuration = durations.length > 0 ? 
                        durations.reduce((a, b) => a + b, 0) / durations.length : 0;

                    const hourlyPerformance = {};
                    for (let h = 0; h < 24; h++) {
                        const hourLogs = filteredLogs.filter(l => l.hourOfDay === h);
                        if (hourLogs.length > 0) {
                            const hourWins = hourLogs.filter(l => l.outcome === 'ACERTO').length;
                            const hourPnL = hourLogs.reduce((sum, l) => sum + (l.prices.finalPnL || 0), 0);
                            hourlyPerformance[h] = {
                                trades: hourLogs.length,
                                winRate: (hourWins / hourLogs.length) * 100,
                                pnl: hourPnL
                            };
                        }
                    }

                    const bestHour = Object.entries(hourlyPerformance)
                        .sort((a, b) => b[1].pnl - a[1].pnl)[0];
                    const worstHour = Object.entries(hourlyPerformance)
                        .sort((a, b) => a[1].pnl - b[1].pnl)[0];

                    const scorePerformance = {};
                    ['90-100', '80-89', '70-79', '60-69', '50-59'].forEach(range => {
                        const rangeLogs = filteredLogs.filter(l => l.scoreRange === range);
                        if (rangeLogs.length > 0) {
                            const rangeWins = rangeLogs.filter(l => l.outcome === 'ACERTO').length;
                            scorePerformance[range] = {
                                trades: rangeLogs.length,
                                winRate: (rangeWins / rangeLogs.length) * 100,
                                pnl: rangeLogs.reduce((sum, l) => sum + (l.prices.finalPnL || 0), 0)
                            };
                        }
                    });

                    setMetrics({
                        totalTrades: filteredLogs.length,
                        wins: wins.length,
                        losses: losses.length,
                        expired: expired.length,
                        winRate,
                        lossRate,
                        expiredRate,
                        totalPnL,
                        profitFactor,
                        expectancy,
                        kellyCriterion,
                        sharpeRatio,
                        maxDrawdown,
                        recoveryFactor,
                        avgWin,
                        avgLoss,
                        avgDuration,
                        maxWinStreak,
                        maxLossStreak,
                        hourlyPerformance,
                        bestHour: bestHour ? { hour: bestHour[0], data: bestHour[1] } : null,
                        worstHour: worstHour ? { hour: worstHour[0], data: worstHour[1] } : null,
                        scorePerformance
                    });
                };

                calculateMetrics();
                const interval = setInterval(calculateMetrics, 10000);
                return () => clearInterval(interval);
            }, [auditSystem, alphaEngine, memoryDB, timeRange]);

            if (!metrics) {
                return (
                    <div className="card">
                        <h3>ðŸ“Š MÃ©tricas AvanÃ§adas</h3>
                        <div style={{ textAlign: 'center', padding: '40px', color: '#a0a0a0' }}>
                            Dados insuficientes. Execute alguns sinais primeiro.
                        </div>
                    </div>
                );
            }

            return (
                <div>
                    <div className="card">
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
                            <h3>ðŸ“Š MÃ©tricas AvanÃ§adas</h3>
                            <div className="mode-selector" style={{ width: 'auto' }}>
                                <div 
                                    className={`mode-btn ${timeRange === '24h' ? 'active' : ''}`}
                                    onClick={() => setTimeRange('24h')}
                                    style={{ padding: '8px 16px', fontSize: '14px' }}
                                >
                                    24h
                                </div>
                                <div 
                                    className={`mode-btn ${timeRange === '7d' ? 'active' : ''}`}
                                    onClick={() => setTimeRange('7d')}
                                    style={{ padding: '8px 16px', fontSize: '14px' }}
                                >
                                    7 dias
                                </div>
                                <div 
                                    className={`mode-btn ${timeRange === '30d' ? 'active' : ''}`}
                                    onClick={() => setTimeRange('30d')}
                                    style={{ padding: '8px 16px', fontSize: '14px' }}
                                >
                                    30 dias
                                </div>
                            </div>
                        </div>

                        <div className="metric-grid">
                            <div className="metric-card">
                                <div className="metric-value">{metrics.totalTrades}</div>
                                <div className="metric-label">Total de Trades</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value" style={{ color: metrics.winRate >= 50 ? '#00ff88' : '#ff4757' }}>
                                    {metrics.winRate.toFixed(1)}%
                                </div>
                                <div className="metric-label">Win Rate</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value" style={{ 
                                    color: metrics.totalPnL >= 0 ? '#00ff88' : '#ff4757',
                                    fontSize: '24px'
                                }}>
                                    {formatBRL(metrics.totalPnL)}
                                </div>
                                <div className="metric-label">P&L Total</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value" style={{ 
                                    color: metrics.profitFactor >= 1.5 ? '#00ff88' : metrics.profitFactor >= 1 ? '#ffc107' : '#ff4757'
                                }}>
                                    {metrics.profitFactor.toFixed(2)}
                                </div>
                                <div className="metric-label">Profit Factor</div>
                            </div>
                        </div>
                    </div>

                    <div className="grid">
                        <div className="card">
                            <h3>ðŸŽ¯ MÃ©tricas de Risco</h3>
                            <div style={{ padding: '15px' }}>
                                <div style={{ marginBottom: '20px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                        <strong>Sharpe Ratio</strong>
                                        <span style={{ 
                                            color: metrics.sharpeRatio >= 1.5 ? '#00ff88' : 
                                                   metrics.sharpeRatio >= 1 ? '#ffc107' : '#ff4757',
                                            fontSize: '18px',
                                            fontWeight: 'bold'
                                        }}>
                                            {metrics.sharpeRatio.toFixed(2)}
                                        </span>
                                    </div>
                                    <div style={{ fontSize: '12px', color: '#a0a0a0' }}>
                                        {metrics.sharpeRatio >= 2 ? 'ðŸŒŸ Excelente' : 
                                         metrics.sharpeRatio >= 1.5 ? 'âœ… Muito Bom' :
                                         metrics.sharpeRatio >= 1 ? 'ðŸ‘ Bom' :
                                         metrics.sharpeRatio >= 0.5 ? 'âš ï¸ Regular' : 'âŒ Ruim'}
                                    </div>
                                </div>

                                <div style={{ marginBottom: '20px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                        <strong>Max Drawdown</strong>
                                        <span style={{ color: '#ff4757', fontSize: '18px', fontWeight: 'bold' }}>
                                            {formatBRL(metrics.maxDrawdown)}
                                        </span>
                                    </div>
                                    <div style={{ 
                                        height: '8px', 
                                        background: 'rgba(255,255,255,0.1)', 
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${Math.min(100, (metrics.maxDrawdown / Math.abs(metrics.totalPnL || 1)) * 100)}%`,
                                            background: '#ff4757'
                                        }}></div>
                                    </div>
                                </div>

                                <div style={{ marginBottom: '20px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                        <strong>Recovery Factor</strong>
                                        <span style={{ 
                                            color: metrics.recoveryFactor >= 3 ? '#00ff88' : '#ffc107',
                                            fontSize: '18px',
                                            fontWeight: 'bold'
                                        }}>
                                            {metrics.recoveryFactor.toFixed(2)}
                                        </span>
                                    </div>
                                    <div style={{ fontSize: '12px', color: '#a0a0a0' }}>
                                        Lucro / Max Drawdown {metrics.recoveryFactor >= 3 ? '(Ã“timo)' : '(Melhorar)'}
                                    </div>
                                </div>

                                <div>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                        <strong>Kelly Criterion</strong>
                                        <span style={{ fontSize: '18px', fontWeight: 'bold', color: '#00ff88' }}>
                                            {(metrics.kellyCriterion * 100).toFixed(1)}%
                                        </span>
                                    </div>
                                    <div style={{ fontSize: '12px', color: '#a0a0a0' }}>
                                        Tamanho de posiÃ§Ã£o sugerido
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="card">
                            <h3>ðŸ’° AnÃ¡lise de Retornos</h3>
                            <div style={{ padding: '15px' }}>
                                <div style={{ marginBottom: '20px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                        <strong>Expectativa MatemÃ¡tica</strong>
                                        <span style={{ 
                                            color: metrics.expectancy >= 0 ? '#00ff88' : '#ff4757',
                                            fontSize: '18px',
                                            fontWeight: 'bold'
                                        }}>
                                            {formatBRL(metrics.expectancy)}
                                        </span>
                                    </div>
                                    <div style={{ fontSize: '12px', color: '#a0a0a0' }}>
                                        Retorno esperado por trade
                                    </div>
                                </div>

                                <div style={{ marginBottom: '20px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                        <strong>Lucro MÃ©dio</strong>
                                        <span style={{ color: '#00ff88', fontSize: '18px', fontWeight: 'bold' }}>
                                            {formatBRL(metrics.avgWin)}
                                        </span>
                                    </div>
                                </div>

                                <div style={{ marginBottom: '20px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                        <strong>Perda MÃ©dia</strong>
                                        <span style={{ color: '#ff4757', fontSize: '18px', fontWeight: 'bold' }}>
                                            {formatBRL(metrics.avgLoss)}
                                        </span>
                                    </div>
                                </div>

                                <div>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                        <strong>Tempo MÃ©dio</strong>
                                        <span style={{ fontSize: '18px', fontWeight: 'bold' }}>
                                            {metrics.avgDuration.toFixed(1)} min
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h3>â° Performance por HorÃ¡rio</h3>
                        <div style={{ padding: '15px' }}>
                            {metrics.bestHour && (
                                <div style={{ 
                                    marginBottom: '15px', 
                                    padding: '15px', 
                                    background: 'rgba(0,255,136,0.1)',
                                    border: '1px solid #00ff88',
                                    borderRadius: '8px'
                                }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <div>
                                            <strong style={{ color: '#00ff88' }}>ðŸ† Melhor HorÃ¡rio: {metrics.bestHour.hour}:00h</strong>
                                            <div style={{ fontSize: '13px', color: '#a0a0a0', marginTop: '5px' }}>
                                                {metrics.bestHour.data.trades} trades | Win Rate: {metrics.bestHour.data.winRate.toFixed(1)}%
                                            </div>
                                        </div>
                                        <div style={{ fontSize: '20px', color: '#00ff88', fontWeight: 'bold' }}>
                                            {formatBRL(metrics.bestHour.data.pnl)}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {metrics.worstHour && (
                                <div style={{ 
                                    padding: '15px', 
                                    background: 'rgba(255,71,87,0.1)',
                                    border: '1px solid #ff4757',
                                    borderRadius: '8px'
                                }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <div>
                                            <strong style={{ color: '#ff4757' }}>âš ï¸ Pior HorÃ¡rio: {metrics.worstHour.hour}:00h</strong>
                                            <div style={{ fontSize: '13px', color: '#a0a0a0', marginTop: '5px' }}>
                                                {metrics.worstHour.data.trades} trades | Win Rate: {metrics.worstHour.data.winRate.toFixed(1)}%
                                            </div>
                                        </div>
                                        <div style={{ fontSize: '20px', color: '#ff4757', fontWeight: 'bold' }}>
                                            {formatBRL(metrics.worstHour.data.pnl)}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸ“Š Performance por Score</h3>
                        <div style={{ padding: '15px' }}>
                            {Object.entries(metrics.scorePerformance).map(([range, data]) => (
                                <div key={range} style={{
                                    padding: '12px',
                                    margin: '8px 0',
                                    border: '1px solid rgba(255,255,255,0.1)',
                                    borderRadius: '8px',
                                    background: 'rgba(255,255,255,0.02)'
                                }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <div>
                                            <strong>Score: {range}%</strong>
                                            <div style={{ fontSize: '13px', color: '#a0a0a0', marginTop: '5px' }}>
                                                {data.trades} trades | Win Rate: {data.winRate.toFixed(1)}%
                                            </div>
                                        </div>
                                        <div style={{ 
                                            fontSize: '18px', 
                                            fontWeight: 'bold',
                                            color: data.pnl >= 0 ? '#00ff88' : '#ff4757'
                                        }}>
                                            {formatBRL(data.pnl)}
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="grid">
                        <div className="card">
                            <h3>ðŸ”¥ SequÃªncias</h3>
                            <div style={{ padding: '15px' }}>
                                <div style={{ 
                                    padding: '15px', 
                                    background: 'rgba(0,255,136,0.1)',
                                    borderRadius: '8px',
                                    marginBottom: '15px'
                                }}>
                                    <div style={{ fontSize: '32px', color: '#00ff88', fontWeight: 'bold', textAlign: 'center' }}>
                                        {metrics.maxWinStreak}
                                    </div>
                                    <div style={{ textAlign: 'center', color: '#a0a0a0', marginTop: '5px' }}>
                                        VitÃ³rias Consecutivas
                                    </div>
                                </div>
                                
                                <div style={{ 
                                    padding: '15px', 
                                    background: 'rgba(255,71,87,0.1)',
                                    borderRadius: '8px'
                                }}>
                                    <div style={{ fontSize: '32px', color: '#ff4757', fontWeight: 'bold', textAlign: 'center' }}>
                                        {metrics.maxLossStreak}
                                    </div>
                                    <div style={{ textAlign: 'center', color: '#a0a0a0', marginTop: '5px' }}>
                                        Perdas Consecutivas
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="card">
                            <h3>ðŸ“ˆ DistribuiÃ§Ã£o de Resultados</h3>
                            <div style={{ padding: '15px' }}>
                                <div style={{ marginBottom: '15px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '5px' }}>
                                        <span>VitÃ³rias</span>
                                        <strong style={{ color: '#00ff88' }}>{metrics.winRate.toFixed(1)}%</strong>
                                    </div>
                                    <div style={{ 
                                        height: '8px', 
                                        background: 'rgba(255,255,255,0.1)', 
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${metrics.winRate}%`,
                                            background: '#00ff88'
                                        }}></div>
                                    </div>
                                </div>

                                <div style={{ marginBottom: '15px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '5px' }}>
                                        <span>Derrotas</span>
                                        <strong style={{ color: '#ff4757' }}>{metrics.lossRate.toFixed(1)}%</strong>
                                    </div>
                                    <div style={{ 
                                        height: '8px', 
                                        background: 'rgba(255,255,255,0.1)', 
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${metrics.lossRate}%`,
                                            background: '#ff4757'
                                        }}></div>
                                    </div>
                                </div>

                                <div>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '5px' }}>
                                        <span>Expirados</span>
                                        <strong style={{ color: '#ffc107' }}>{metrics.expiredRate.toFixed(1)}%</strong>
                                    </div>
                                    <div style={{ 
                                        height: '8px', 
                                        background: 'rgba(255,255,255,0.1)', 
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${metrics.expiredRate}%`,
                                            background: '#ffc107'
                                        }}></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        function TelegramConfig({ telegramNotifier, showNotification }) {
            const [botToken, setBotToken] = useState('');
            const [chatId, setChatId] = useState('');
            const [isTesting, setIsTesting] = useState(false);
            const [isEnabled, setIsEnabled] = useState(false);

            useEffect(() => {
                if (telegramNotifier) {
                    setIsEnabled(telegramNotifier.isEnabled());
                }
            }, [telegramNotifier]);

            const handleSave = () => {
                if (!botToken.trim() || !chatId.trim()) {
                    showNotification('Preencha todos os campos');
                    return;
                }

                telegramNotifier.configure(botToken.trim(), chatId.trim());
                showNotification('âœ… ConfiguraÃ§Ã£o salva!');
            };

            const handleTest = async () => {
                setIsTesting(true);
                
                try {
                    const result = await telegramNotifier.testConnection();
                    if (result.success) {
                        showNotification('âœ… Teste bem-sucedido! Verifique seu Telegram');
                    } else {
                        showNotification(`âŒ ${result.message}`);
                    }
                } catch (error) {
                    showNotification(`âŒ Erro: ${error.message}`);
                } finally {
                    setIsTesting(false);
                }
            };

            const handleToggle = () => {
                try {
                    if (isEnabled) {
                        telegramNotifier.disable();
                        setIsEnabled(false);
                        showNotification('NotificaÃ§Ãµes desativadas');
                    } else {
                        telegramNotifier.enable();
                        setIsEnabled(true);
                        showNotification('âœ… NotificaÃ§Ãµes ativadas!');
                    }
                } catch (error) {
                    showNotification(`âŒ ${error.message}`);
                }
            };

            return (
                <div>
                    <div className="warning-box">
                        ðŸ“± <strong>Como configurar:</strong><br/>
                        1. Abra o Telegram e procure por <strong>@BotFather</strong><br/>
                        2. Envie <code>/newbot</code> e siga as instruÃ§Ãµes<br/>
                        3. Copie o <strong>Bot Token</strong> fornecido<br/>
                        4. Procure seu bot e envie <code>/start</code><br/>
                        5. Acesse <a href="https://api.telegram.org/botSEU_TOKEN/getUpdates" target="_blank" style={{color: '#00ff88'}}>
                            api.telegram.org/botSEU_TOKEN/getUpdates
                        </a><br/>
                        6. Procure por <code>"chat":{"{"}id":NUMERO{"}"}</code> - esse Ã© seu Chat ID
                    </div>

                    <div className="card">
                        <h3>âš™ï¸ ConfiguraÃ§Ã£o do Telegram</h3>
                        
                        <div className="form-group">
                            <label className="form-label">Bot Token</label>
                            <input 
                                type="password"
                                className="form-input"
                                placeholder="123456:ABC-DEF1234ghIkl..."
                                value={botToken}
                                onChange={(e) => setBotToken(e.target.value)}
                            />
                        </div>

                        <div className="form-group">
                            <label className="form-label">Chat ID</label>
                            <input 
                                type="text"
                                className="form-input"
                                placeholder="123456789"
                                value={chatId}
                                onChange={(e) => setChatId(e.target.value)}
                            />
                        </div>

                        <div style={{ display: 'flex', gap: '10px' }}>
                            <button 
                                className="btn btn-primary"
                                onClick={handleSave}
                                style={{ flex: 1 }}
                            >
                                ðŸ’¾ Salvar
                            </button>
                            <button 
                                className="btn btn-secondary"
                                onClick={handleTest}
                                disabled={isTesting || !telegramNotifier?.isConfigured()}
                                style={{ flex: 1 }}
                            >
                                {isTesting ? 'â³ Testando...' : 'ðŸ” Testar'}
                            </button>
                        </div>
                    </div>

                    {telegramNotifier?.isConfigured() && (
                        <div className="card">
                            <h3>ðŸ“¢ NotificaÃ§Ãµes</h3>
                            
                            <div style={{ 
                                display: 'flex', 
                                justifyContent: 'space-between', 
                                alignItems: 'center',
                                padding: '20px',
                                background: isEnabled ? 'rgba(0,255,136,0.1)' : 'rgba(255,255,255,0.05)',
                                borderRadius: '12px',
                                border: `1px solid ${isEnabled ? '#00ff88' : 'rgba(255,255,255,0.1)'}`
                            }}>
                                <div>
                                    <strong style={{ fontSize: '18px' }}>
                                        {isEnabled ? 'âœ… Ativado' : 'â­• Desativado'}
                                    </strong>
                                    <div style={{ fontSize: '14px', color: '#a0a0a0', marginTop: '5px' }}>
                                        {isEnabled ? 'VocÃª receberÃ¡ notificaÃ§Ãµes de todos os sinais' : 'Ative para receber notificaÃ§Ãµes'}
                                    </div>
                                </div>
                                
                                <div 
                                    className={`toggle-switch ${isEnabled ? 'active' : ''}`}
                                    onClick={handleToggle}
                                    style={{ cursor: 'pointer' }}
                                ></div>
                            </div>

                            {isEnabled && (
                                <div style={{ marginTop: '20px', padding: '15px', background: 'rgba(0,255,136,0.1)', borderRadius: '8px' }}>
                                    <strong style={{ color: '#00ff88' }}>ðŸ“¬ VocÃª receberÃ¡ notificaÃ§Ãµes para:</strong>
                                    <ul style={{ marginTop: '10px', paddingLeft: '20px', lineHeight: '1.8' }}>
                                        <li>Novos sinais gerados</li>
                                        <li>Ordens executadas (modo robÃ´)</li>
                                        <li>Stop Loss / Take Profit atingido</li>
                                        <li>RelatÃ³rio diÃ¡rio de performance</li>
                                    </ul>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }
        function Settings({ minScore, setMinScore }) {
            return (
                <div>
                    <div className="card">
                        <h3>âš™ï¸ ConfiguraÃ§Ãµes</h3>
                        <div className="form-group">
                            <label className="form-label">Score MÃ­nimo: {minScore}%</label>
                            <input 
                                type="range"
                                min="50"
                                max="95"
                                value={minScore}
                                onChange={(e) => setMinScore(Number(e.target.value))}
                                className="form-input"
                            />
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸ“š Sobre</h3>
                        <p style={{ lineHeight: '1.6', color: '#c0c0c0' }}>
                            Plataforma de trading algorÃ­tmico com Machine Learning e sistema de auditoria integrado.
                        </p>
                        <div style={{ marginTop: '15px', fontSize: '14px', color: '#00ff88' }}>
                            VersÃ£o: 2.3.0 | Build: 2024.006 | AtualizaÃ§Ã£o em Tempo Real Implementada
                        </div>
                        
                        <div style={{ marginTop: '20px', padding: '15px', background: 'rgba(0, 255, 136, 0.1)', borderRadius: '8px', border: '1px solid rgba(0, 255, 136, 0.3)' }}>
                            <h4 style={{ color: '#00ff88', marginBottom: '10px' }}>âœ¨ Novidades v2.3</h4>
                            <ul style={{ color: '#c0c0c0', lineHeight: '1.8', paddingLeft: '20px' }}>
                                <li>âœ… <strong>AtualizaÃ§Ã£o em tempo real</strong> de todas as mÃ©tricas</li>
                                <li>âœ… <strong>Dashboard responsivo</strong> com dados sempre atualizados</li>
                                <li>âœ… <strong>Performance ao vivo</strong> sem necessidade de recarregar</li>
                                <li>âœ… <strong>ML Engine dinÃ¢mico</strong> com pesos adaptativos visÃ­veis</li>
                                <li>âœ… <strong>Sistema de listeners</strong> para propagaÃ§Ã£o de mudanÃ§as</li>
                                <li>âœ… <strong>CorreÃ§Ãµes de bugs</strong> em cÃ¡lculos de indicadores</li>
                            </ul>
                        </div>

                        <div style={{ marginTop: '20px', padding: '15px', background: 'rgba(255, 193, 7, 0.1)', borderRadius: '8px', border: '1px solid rgba(255, 193, 7, 0.3)' }}>
                            <h4 style={{ color: '#ffc107', marginBottom: '10px' }}>ðŸ’¡ Dicas de Uso</h4>
                            <ul style={{ color: '#c0c0c0', lineHeight: '1.8', paddingLeft: '20px' }}>
                                <li>Use o <strong>Modo Assistente</strong> para anÃ¡lise manual com alertas</li>
                                <li>Use o <strong>Modo RobÃ´</strong> para execuÃ§Ã£o automÃ¡tica (DEMO)</li>
                                <li>Conecte APIs reais para dados em tempo real</li>
                                <li>Verifique a <strong>Auditoria</strong> para anÃ¡lise detalhada</li>
                                <li>Digite <code>auditDiag()</code> no console para diagnÃ³stico</li>
                            </ul>
                        </div>

                        <div style={{ marginTop: '20px', padding: '15px', background: 'rgba(255, 71, 87, 0.1)', borderRadius: '8px', border: '1px solid rgba(255, 71, 87, 0.3)' }}>
                            <h4 style={{ color: '#ff4757', marginBottom: '10px' }}>âš ï¸ Aviso Legal</h4>
                            <p style={{ color: '#c0c0c0', lineHeight: '1.8', fontSize: '13px' }}>
                                Este sistema Ã© fornecido apenas para fins educacionais e de demonstraÃ§Ã£o. 
                                Trading de ativos financeiros envolve risco significativo de perda. 
                                NÃ£o opere com capital que vocÃª nÃ£o pode perder. 
                                Os desenvolvedores nÃ£o se responsabilizam por perdas financeiras.
                            </p>
                        </div>
                    </div>
                </div>
            );
        }

        /* ========================================
           RENDERIZAÃ‡ÃƒO FINAL
           ======================================== */

        try {
            const rootElement = document.getElementById('root');
            if (rootElement) {
                ReactDOM.render(<App />, rootElement);
                console.log('âœ… AplicaÃ§Ã£o renderizada com sucesso!');
                console.log('%cðŸŽ‰ Alpha-Learner v2.3 Inicializado!', 'color: #00ff88; font-size: 16px; font-weight: bold;');
                console.log('%cðŸ“Š Todas as mÃ©tricas agora atualizam em tempo real', 'color: #00ff88;');
                console.log('%cðŸ’¡ Digite auditDiag() para diagnÃ³stico do sistema', 'color: #ffc107;');
            } else {
                console.error('âŒ Elemento root nÃ£o encontrado!');
            }
        } catch (error) {
            console.error('âŒ Erro ao renderizar aplicaÃ§Ã£o:', error);
            document.getElementById('root').innerHTML = `
                <div style="padding: 40px; text-align: center; color: #ff4757;">
                    <h2>âŒ Erro ao Inicializar</h2>
                    <p>Verifique o console para mais detalhes</p>
                    <pre style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 8px; margin-top: 20px; text-align: left;">
                        ${error.message}
                    </pre>
                </div>
            `;
        }
    </script>
</body>
</html>




















