<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpha-Learner Trading Platform v2.2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.5/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        .app {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 250px;
            background: rgba(20, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 30px;
            text-align: center;
        }
        .nav-item {
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }
        .nav-item:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
        }
        .nav-item.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
        }
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
            gap: 15px;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00ff88;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .data-source-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        .data-source-real {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }
        .data-source-simulated {
            background: rgba(255, 165, 0, 0.2);
            border: 1px solid #ffa500;
            color: #ffa500;
        }
        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        .card h3 {
            color: #00ff88;
            margin-bottom: 16px;
            font-size: 18px;
        }
        .warning-box {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #ffc107;
        }
        .success-box {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #00ff88;
        }
        .error-box {
            background: rgba(255, 71, 87, 0.1);
            border: 1px solid rgba(255, 71, 87, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #ff4757;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .signal-card {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.05) 100%);
            border: 1px solid #00ff88;
            border-radius: 16px;
            padding: 20px;
            position: relative;
            animation: slideIn 0.5s ease-out;
        }
        .signal-card.urgent {
            animation: pulse-urgent 1s infinite;
        }
        @keyframes pulse-urgent {
            0%, 100% { 
                border-color: #ffd700;
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            }
            50% { 
                border-color: #ffed4e;
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            }
        }
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .signal-direction {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .signal-direction.buy {
            color: #00ff88;
        }
        .signal-direction.sell {
            color: #ff4757;
        }
        .signal-score {
            background: rgba(0, 255, 136, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .signal-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            display: inline-block;
            margin-left: 10px;
        }
        .signal-status.pending {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        .signal-status.success {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        .signal-status.error {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
        }
        .signal-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
            font-size: 14px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        .btn-primary {
            background: #00ff88;
            color: #000;
        }
        .btn-primary:hover:not(:disabled) {
            background: #00cc6a;
            transform: translateY(-2px);
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }
        .btn-danger {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
            border: 1px solid #ff4757;
        }
        .btn-emergency {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: 2px solid #ff0000;
            font-weight: bold;
            font-size: 16px;
            padding: 15px 30px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 8px;
        }
        .metric-label {
            font-size: 14px;
            color: #a0a0a0;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-label {
            display: block;
            margin-bottom: 8px;
            color: #c0c0c0;
            font-weight: 500;
        }
        .form-input, .form-select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 16px;
        }
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.2);
        }
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .toggle-switch.active {
            background: #00ff88;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }
        .toggle-switch.active::after {
            transform: translateX(30px);
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 136, 0.9);
            color: #000;
            padding: 16px 20px;
            border-radius: 8px;
            font-weight: 500;
            animation: slideInRight 0.5s ease-out;
            z-index: 1000;
            max-width: 400px;
        }
        @keyframes slideInRight {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .mode-btn {
            flex: 1;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        .mode-btn.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
        }
        .log-entry {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }
        .log-entry.info {
            background: rgba(0, 184, 217, 0.1);
            border-left: 3px solid #00b8d9;
        }
        .log-entry.success {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
        }
        .log-entry.warning {
            background: rgba(255, 193, 7, 0.1);
            border-left: 3px solid #ffc107;
        }
        .log-entry.error {
            background: rgba(255, 71, 87, 0.1);
            border-left: 3px solid #ff4757;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // Vari√°veis globais
        window.auditSystemRef = null;
        window.debugAudit = true;
        
        // Fun√ß√£o de diagn√≥stico r√°pido
        window.auditDiag = function() {
            console.log('====== DIAGN√ìSTICO R√ÅPIDO ======');
            console.log('AuditSystem:', window.auditSystemRef ? 'OK' : 'ERRO');
            if (window.auditSystemRef) {
                console.log('Total de logs:', window.auditSystemRef.auditLogs.length);
                console.log('√öltimo log:', window.auditSystemRef.auditLogs[window.auditSystemRef.auditLogs.length - 1]);
            }
            console.log('================================');
        };

        /* ========================================
           SISTEMA DE AUDITORIA (CORRIGIDO)
           ======================================== */
        
        class AuditSystem {
            constructor() {
                this.auditLogs = [];
                this.performanceByHour = {};
                this.performanceByScore = {};
                this.indicatorPerformance = {};
                this.loadFromStorage();
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('audit_system_data');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.auditLogs = data.auditLogs || [];
                        this.performanceByHour = data.performanceByHour || {};
                        this.performanceByScore = data.performanceByScore || {};
                        this.indicatorPerformance = data.indicatorPerformance || {};
                        
                        if (window.debugAudit) {
                            console.log('üìÇ [AUDIT] Dados carregados:', {
                                logs: this.auditLogs.length,
                                lastSaved: data.lastSaved || 'N/A'
                            });
                        }
                    } else {
                        if (window.debugAudit) {
                            console.log('üìÇ [AUDIT] Nenhum dado anterior encontrado');
                        }
                    }
                } catch (e) {
                    console.error('‚ùå [AUDIT] Erro ao carregar auditoria:', e);
                }
            }

            saveToStorage() {
                try {
                    const data = {
                        auditLogs: this.auditLogs.slice(-500),
                        performanceByHour: this.performanceByHour,
                        performanceByScore: this.performanceByScore,
                        indicatorPerformance: this.indicatorPerformance,
                        lastSaved: new Date().toISOString()
                    };
                    localStorage.setItem('audit_system_data', JSON.stringify(data));
                    
                    if (window.debugAudit) {
                        console.log('üíæ [AUDIT] Dados salvos:', {
                            logs: this.auditLogs.length,
                            timestamp: data.lastSaved
                        });
                    }
                } catch (e) {
                    console.error('‚ùå [AUDIT] Erro ao salvar auditoria:', e);
                }
            }

            logSignalGeneration(signal, currentPrice, indicators) {
                if (window.debugAudit) {
                    console.log('üîç [AUDIT] logSignalGeneration chamado:', {
                        signalId: signal.id,
                        price: signal.price,
                        currentPrice: currentPrice.close
                    });
                }

                const candleCloseTime = new Date(signal.timestamp);
                candleCloseTime.setSeconds(0, 0);
                candleCloseTime.setMinutes(Math.floor(candleCloseTime.getMinutes() / 5) * 5 + 5);

                const log = {
                    signalId: signal.id,
                    generatedAt: signal.timestamp.toISOString(),
                    candleCloseTime: candleCloseTime.toISOString(),
                    timeDifference: (candleCloseTime - signal.timestamp) / 1000,
                    
                    prices: {
                        theoretical: signal.price,
                        actualEntry: null,
                        slippage: null,
                        actualExit: null,
                        finalPnL: null
                    },
                    
                    indicators: this.formatIndicators(signal, indicators),
                    
                    scoreRange: this.getScoreRange(signal.score),
                    hourOfDay: signal.timestamp.getHours(),
                    
                    outcome: null,
                    outcomeTime: null,
                    reason: null,
                    
                    metadata: {
                        direction: signal.direction,
                        symbol: signal.symbol,
                        timeframe: signal.timeframe,
                        dataSource: signal.dataSource,
                        hasDivergence: signal.divergence ? true : false
                    }
                };

                this.auditLogs.push(log);
                if (this.auditLogs.length > 500) {
                    this.auditLogs = this.auditLogs.slice(-500);
                }
                
                this.saveToStorage();
                
                if (window.debugAudit) {
                    console.log('‚úÖ [AUDIT] Log salvo. Total de logs:', this.auditLogs.length);
                }
                
                return log;
            }

            formatIndicators(signal, indicators) {
                const formatted = {};
                
                signal.contributors.forEach(indicator => {
                    formatted[indicator] = {
                        weight: indicators.weights ? indicators.weights[indicator] : 0,
                        contribution: 0
                    };
                });

                return formatted;
            }

            getScoreRange(score) {
                if (score >= 90) return '90-100';
                if (score >= 80) return '80-89';
                if (score >= 70) return '70-79';
                if (score >= 60) return '60-69';
                if (score >= 50) return '50-59';
                return '0-49';
            }

            updateSignalOutcome(signalId, outcome, finalPrice, pnl, executionDetails = null) {
                if (window.debugAudit) {
                    console.log('üîç [AUDIT] updateSignalOutcome chamado:', {
                        signalId,
                        outcome,
                        finalPrice,
                        pnl
                    });
                }

                const log = this.auditLogs.find(l => l.signalId === signalId);
                
                if (log) {
                    log.outcome = outcome;
                    log.outcomeTime = new Date().toISOString();
                    log.prices.actualExit = finalPrice;
                    log.prices.finalPnL = pnl;
                    
                    if (executionDetails) {
                        log.prices.actualEntry = executionDetails.executedPrice;
                        log.prices.slippage = Math.abs(executionDetails.executedPrice - log.prices.theoretical);
                    }

                    const duration = (new Date(log.outcomeTime) - new Date(log.generatedAt)) / 60000;
                    log.reason = this.determineReason(outcome, duration);

                    this.updateStatistics(log);
                    this.saveToStorage();
                    
                    if (window.debugAudit) {
                        console.log('‚úÖ [AUDIT] Outcome atualizado com sucesso');
                    }
                } else {
                    if (window.debugAudit) {
                        console.error('‚ùå [AUDIT] Log n√£o encontrado para signalId:', signalId);
                        console.log('Logs dispon√≠veis:', this.auditLogs.map(l => l.signalId));
                    }
                }
            }

            determineReason(outcome, durationMinutes) {
                if (outcome === 'ACERTO') {
                    return `Atingiu take profit em ${Math.floor(durationMinutes)}min`;
                } else if (outcome === 'ERRO') {
                    return `Atingiu stop loss em ${Math.floor(durationMinutes)}min`;
                } else if (outcome === 'EXPIRADO') {
                    return `Expirou ap√≥s ${Math.floor(durationMinutes)}min sem atingir alvos`;
                } else if (outcome === 'CANCELADO') {
                    return 'Cancelado manualmente';
                }
                return 'Desconhecido';
            }

            updateStatistics(log) {
                if (!log.outcome || log.outcome === 'PENDENTE') return;

                // Por hor√°rio
                const hour = log.hourOfDay;
                if (!this.performanceByHour[hour]) {
                    this.performanceByHour[hour] = { total: 0, wins: 0, losses: 0, expired: 0, totalPnL: 0 };
                }
                this.performanceByHour[hour].total++;
                if (log.outcome === 'ACERTO') this.performanceByHour[hour].wins++;
                else if (log.outcome === 'ERRO') this.performanceByHour[hour].losses++;
                else if (log.outcome === 'EXPIRADO') this.performanceByHour[hour].expired++;
                this.performanceByHour[hour].totalPnL += log.prices.finalPnL || 0;

                // Por faixa de score
                const scoreRange = log.scoreRange;
                if (!this.performanceByScore[scoreRange]) {
                    this.performanceByScore[scoreRange] = { total: 0, wins: 0, losses: 0, expired: 0 };
                }
                this.performanceByScore[scoreRange].total++;
                if (log.outcome === 'ACERTO') this.performanceByScore[scoreRange].wins++;
                else if (log.outcome === 'ERRO') this.performanceByScore[scoreRange].losses++;
                else if (log.outcome === 'EXPIRADO') this.performanceByScore[scoreRange].expired++;

                // Por indicador
                Object.keys(log.indicators).forEach(indicator => {
                    if (!this.indicatorPerformance[indicator]) {
                        this.indicatorPerformance[indicator] = { total: 0, wins: 0, losses: 0 };
                    }
                    this.indicatorPerformance[indicator].total++;
                    if (log.outcome === 'ACERTO') this.indicatorPerformance[indicator].wins++;
                    else if (log.outcome === 'ERRO') this.indicatorPerformance[indicator].losses++;
                });
            }

            getHealthAlerts() {
                const alerts = [];
                const recentLogs = this.auditLogs.slice(-20).filter(l => l.outcome && l.outcome !== 'PENDENTE');

                if (recentLogs.length >= 10) {
                    const winRate = (recentLogs.filter(l => l.outcome === 'ACERTO').length / recentLogs.length) * 100;
                    
                    if (winRate < 40) {
                        alerts.push({
                            type: 'error',
                            message: `Taxa de acerto cr√≠tica: ${winRate.toFixed(1)}% nos √∫ltimos ${recentLogs.length} sinais`
                        });
                    } else if (winRate < 50) {
                        alerts.push({
                            type: 'warning',
                            message: `Taxa de acerto baixa: ${winRate.toFixed(1)}% nos √∫ltimos ${recentLogs.length} sinais`
                        });
                    }

                    const expiredRate = (recentLogs.filter(l => l.outcome === 'EXPIRADO').length / recentLogs.length) * 100;
                    if (expiredRate > 50) {
                        alerts.push({
                            type: 'warning',
                            message: `${expiredRate.toFixed(1)}% dos sinais expiram sem resultado - ajuste os alvos`
                        });
                    }

                    const avgSlippage = recentLogs
                        .filter(l => l.prices.slippage !== null)
                        .reduce((sum, l) => sum + l.prices.slippage, 0) / recentLogs.length;
                    
                    if (avgSlippage > 50) {
                        alerts.push({
                            type: 'warning',
                            message: `Slippage m√©dio alto: R$ ${avgSlippage.toFixed(2)}`
                        });
                    }
                }

                return alerts;
            }

            getPerformanceByHour() {
                return this.performanceByHour;
            }

            getPerformanceByScore() {
                return this.performanceByScore;
            }

            getIndicatorPerformance() {
                return this.indicatorPerformance;
            }

            getRecentLogs(limit = 50) {
                return this.auditLogs.slice(-limit).reverse();
            }

            exportToCSV() {
                const headers = [
                    'ID', 'Gerado Em', 'Hor√°rio', 'S√≠mbolo', 'Dire√ß√£o', 'Score',
                    'Pre√ßo Te√≥rico', 'Pre√ßo Entrada', 'Slippage', 'Pre√ßo Sa√≠da',
                    'P&L', 'Resultado', 'Motivo', 'Fonte Dados'
                ];

                const rows = this.auditLogs.map(log => [
                    log.signalId,
                    new Date(log.generatedAt).toLocaleString('pt-BR'),
                    log.hourOfDay + 'h',
                    log.metadata.symbol,
                    log.metadata.direction,
                    log.scoreRange,
                    log.prices.theoretical.toFixed(2),
                    log.prices.actualEntry ? log.prices.actualEntry.toFixed(2) : 'N/A',
                    log.prices.slippage ? log.prices.slippage.toFixed(2) : 'N/A',
                    log.prices.actualExit ? log.prices.actualExit.toFixed(2) : 'N/A',
                    log.prices.finalPnL !== null ? log.prices.finalPnL.toFixed(2) : 'N/A',
                    log.outcome || 'PENDENTE',
                    log.reason || 'Em andamento',
                    log.metadata.dataSource
                ]);

                let csv = headers.join(',') + '\n';
                rows.forEach(row => {
                    csv += row.join(',') + '\n';
                });

                return csv;
            }

            clearOldData(daysToKeep = 7) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
                
                this.auditLogs = this.auditLogs.filter(log => 
                    new Date(log.generatedAt) > cutoffDate
                );
                
                this.saveToStorage();
            }
        }

        /* ========================================
           CLASSES SIMPLIFICADAS (MemoryDB, MarketData, Indicators, AlphaEngine)
           ======================================== */

        class MemoryDB {
            constructor() {
                this.signals_history = [];
                this.loadFromStorage();
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('alpha_learner_data');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.signals_history = data.signals_history || [];
                    }
                } catch (error) {
                    console.error('Erro ao carregar dados:', error);
                }
            }

            saveToStorage() {
                try {
                    localStorage.setItem('alpha_learner_data', JSON.stringify({
                        signals_history: this.signals_history
                    }));
                } catch (error) {
                    console.error('Erro ao salvar dados:', error);
                }
            }

            async saveSignal(signal) {
                this.signals_history.push({
                    ...signal,
                    savedAt: new Date().toISOString()
                });
                this.saveToStorage();
            }

            async getAllSignals() {
                return [...this.signals_history];
            }

            async getStatistics() {
                const signals = await this.getAllSignals();
                const completed = signals.filter(s => s.status !== 'PENDENTE');
                const successful = completed.filter(s => s.status === 'ACERTO');
                
                return {
                    total: signals.length,
                    completed: completed.length,
                    successful: successful.length,
                    winRate: completed.length > 0 ? (successful.length / completed.length) * 100 : 0,
                    totalPnL: completed.reduce((sum, s) => sum + (s.pnl || 0), 0)
                };
            }
        }

        class MarketDataSimulator {
            constructor() {
                this.prices = [];
                this.generateInitialData();
            }

            generateInitialData() {
                const basePrice = 50000;
                for (let i = 0; i < 200; i++) {
                    const timestamp = Date.now() - (200 - i) * 5 * 60 * 1000;
                    const price = basePrice + Math.sin(i * 0.1) * 1000 + Math.random() * 200 - 100;
                    this.prices.push({
                        timestamp,
                        open: price,
                        high: price + Math.random() * 50,
                        low: price - Math.random() * 50,
                        close: price + (Math.random() - 0.5) * 30,
                        volume: Math.random() * 1000000
                    });
                }
            }

            getLatestPrice() {
                return this.prices[this.prices.length - 1];
            }

            addNewCandle() {
                const lastCandle = this.prices[this.prices.length - 1];
                const newPrice = lastCandle.close + (Math.random() - 0.5) * 100;
                const newCandle = {
                    timestamp: Date.now(),
                    open: newPrice,
                    high: newPrice + Math.random() * 30,
                    low: newPrice - Math.random() * 30,
                    close: newPrice + (Math.random() - 0.5) * 20,
                    volume: Math.random() * 1000000
                };
                this.prices.push(newCandle);
                if (this.prices.length > 200) {
                    this.prices.shift();
                }
                return newCandle;
            }
        }

        class TechnicalIndicators {
            static calculateRSI(prices, period = 14) {
                if (prices.length < period + 1) return 50;
                
                let gains = 0;
                let losses = 0;
                
                for (let i = prices.length - period; i < prices.length; i++) {
                    const change = prices[i].close - prices[i - 1].close;
                    if (change > 0) gains += change;
                    else losses -= change;
                }
                
                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            static calculateMACD(prices) {
                if (prices.length < 26) return { macd: 0, signal: 0, histogram: 0 };
                
                const closes = prices.slice(-26).map(p => p.close);
                const fastEMA = closes.slice(-12).reduce((a, b) => a + b) / 12;
                const slowEMA = closes.reduce((a, b) => a + b) / 26;
                const macd = fastEMA - slowEMA;
                
                return { macd, signal: macd * 0.9, histogram: macd * 0.1 };
            }

            static calculateATR(prices, period = 14) {
                if (prices.length < period + 1) return prices[prices.length - 1].close * 0.02;
                
                let trSum = 0;
                for (let i = prices.length - period; i < prices.length; i++) {
                    const high = prices[i].high;
                    const low = prices[i].low;
                    const prevClose = prices[i - 1].close;
                    
                    const tr = Math.max(
                        high - low,
                        Math.abs(high - prevClose),
                        Math.abs(low - prevClose)
                    );
                    trSum += tr;
                }
                
                return trSum / period;
            }
        }

        class AlphaEngine {
            constructor(memoryDB) {
                this.memoryDB = memoryDB;
                this.weights = {
                    rsi: 0.25,
                    macd: 0.25,
                    stochastic: 0.25,
                    divergence: 0.25
                };
                this.performance = {
                    totalSignals: 0,
                    successfulSignals: 0,
                    winRate: 0,
                    totalPnL: 0
                };
            }

            analyzeMarket(marketData, dataSource) {
                const prices = marketData.prices;
                const currentPrice = marketData.getLatestPrice();
                
                const rsi = TechnicalIndicators.calculateRSI(prices);
                const macd = TechnicalIndicators.calculateMACD(prices);
                
                const features = {
                    rsi: { value: rsi, score: rsi < 30 ? 0.8 : rsi > 70 ? -0.8 : 0 },
                    macd: { score: macd.macd > macd.signal ? 0.7 : -0.7 }
                };
                
                const signal = this.generateSignal(features, currentPrice, dataSource);
                
                return signal;
            }

            generateSignal(features, currentPrice, dataSource) {
                let score = 0;
                const contributors = [];

                if (Math.abs(features.rsi.score) > 0.1) {
                    score += features.rsi.score * this.weights.rsi;
                    contributors.push('rsi');
                }

                if (Math.abs(features.macd.score) > 0.1) {
                    score += features.macd.score * this.weights.macd;
                    contributors.push('macd');
                }

                const normalizedScore = Math.max(0, Math.min(100, (score + 1) * 50));

                if (normalizedScore < 25) {
                    return null;
                }

                const direction = score > 0 ? 'BUY' : 'SELL';
                const atr = TechnicalIndicators.calculateATR([currentPrice]);
                
                const timeframeMinutes = 5;
                const entryTime = new Date();
                entryTime.setMinutes(entryTime.getMinutes() + Math.floor(Math.random() * timeframeMinutes) + 1);
                
                const signal = {
                    id: Date.now() + Math.random(),
                    timestamp: new Date(),
                    symbol: 'BTCUSDT',
                    direction,
                    timeframe: 'M5',
                    score: Math.round(normalizedScore),
                    price: currentPrice.close,
                    entryTime: entryTime,
                    stopLoss: direction === 'BUY' ? 
                        currentPrice.close - (atr * 2) : 
                        currentPrice.close + (atr * 2),
                    takeProfit: direction === 'BUY' ? 
                        currentPrice.close + (atr * 4) : 
                        currentPrice.close - (atr * 4),
                    contributors,
                    divergence: Math.random() < 0.3 ? { type: 'bullish', strength: 0.8 } : null,
                    features,
                    status: 'PENDENTE',
                    dataSource,
                    pnl: 0,
                    executed: false
                };

                this.memoryDB.saveSignal(signal);
                
                // LOG PARA AUDITORIA COM VERIFICA√á√ÉO
                if (window.auditSystemRef) {
                    try {
                        if (window.debugAudit) {
                            console.log('üîç [ENGINE] Chamando auditSystem.logSignalGeneration');
                        }
                        window.auditSystemRef.logSignalGeneration(signal, currentPrice, { weights: this.weights });
                    } catch (error) {
                        console.error('‚ùå [ENGINE] Erro ao registrar no auditSystem:', error);
                    }
                } else {
                    console.warn('‚ö†Ô∏è [ENGINE] auditSystemRef n√£o est√° dispon√≠vel!');
                }

                return signal;
            }

            async learnFromTrade(signal, result) {
                const successful = result === 'ACERTO';
                this.performance.totalSignals++;
                if (successful) this.performance.successfulSignals++;
                this.performance.winRate = (this.performance.successfulSignals / this.performance.totalSignals) * 100;

                signal.status = result;
                await this.memoryDB.saveSignal(signal);
            }
        }

        /* ========================================
           COMPONENTE PRINCIPAL APP
           ======================================== */

        function App() {
            const [currentView, setCurrentView] = useState('dashboard');
            const [mode, setMode] = useState('manual');
            const [isActive, setIsActive] = useState(false);
            const [signals, setSignals] = useState([]);
            const [marketData, setMarketData] = useState(null);
            const [alphaEngine, setAlphaEngine] = useState(null);
            const [notification, setNotification] = useState(null);
            const [minScore, setMinScore] = useState(50);
            const [riskAmount, setRiskAmount] = useState(100);
            const [dataSource, setDataSource] = useState('SIMULADO');
            const [memoryDB, setMemoryDB] = useState(null);
            const [auditSystem, setAuditSystem] = useState(null);

            const marketDataRef = useRef(null);
            const alphaEngineRef = useRef(null);
            const memoryDBRef = useRef(null);
            const auditSystemRef = useRef(null);
            const verificationTimers = useRef(new Map());

            useEffect(() => {
                try {
                    console.log('üöÄ Inicializando sistema...');
                    
                    // 1. MemoryDB
                    memoryDBRef.current = new MemoryDB();
                    setMemoryDB(memoryDBRef.current);
                    console.log('‚úÖ MemoryDB inicializado');
                    
                    // 2. MarketData
                    marketDataRef.current = new MarketDataSimulator();
                    setMarketData(marketDataRef.current);
                    console.log('‚úÖ MarketData inicializado');
                    
                    // 3. AuditSystem ANTES do AlphaEngine
                    auditSystemRef.current = new AuditSystem();
                    window.auditSystemRef = auditSystemRef.current;
                    setAuditSystem(auditSystemRef.current);
                    console.log('‚úÖ AuditSystem inicializado e dispon√≠vel globalmente');
                    
                    // 4. AlphaEngine
                    alphaEngineRef.current = new AlphaEngine(memoryDBRef.current);
                    setAlphaEngine(alphaEngineRef.current);
                    console.log('‚úÖ AlphaEngine inicializado');
                    
                    console.log('üéâ Sistema totalmente inicializado!');
                    console.log('%cüí° DICA: Digite auditDiag() no console para diagn√≥stico r√°pido', 'color: #00ff88; font-weight: bold;');
                    
                } catch (error) {
                    console.error('‚ùå Erro na inicializa√ß√£o:', error);
                }
            }, []);

            useEffect(() => {
                if (!isActive || !marketData || !alphaEngine) return;

                const interval = setInterval(() => {
                    try {
                        marketData.addNewCandle();
                        const signal = alphaEngine.analyzeMarket(marketData, 'SIMULADO');
                        
                        if (signal && signal.score >= minScore) {
                            setSignals(prev => [signal, ...prev.slice(0, 9)]);
                            showNotification(`Novo sinal ${signal.direction} - Score: ${signal.score}%`);
                            scheduleSignalVerification(signal);
                        }
                    } catch (error) {
                        console.log('Erro no loop:', error);
                    }
                }, 30000);

                return () => clearInterval(interval);
            }, [isActive, marketData, alphaEngine, minScore]);

            const scheduleSignalVerification = (signal) => {
                try {
                    const now = new Date().getTime();
                    const entryTime = new Date(signal.entryTime).getTime();
                    const timeframeMs = 5 * 60 * 1000;
                    
                    const timeUntilEntry = Math.max(0, entryTime - now);
                    const verificationDelay = timeUntilEntry + timeframeMs;
                    
                    const monitoringInterval = setInterval(() => {
                        const currentPrice = marketDataRef.current?.getLatestPrice()?.close;
                        if (!currentPrice) return;
                        
                        let shouldStop = false;
                        let result = null;
                        let pnl = 0;
                        
                        if (signal.direction === 'BUY') {
                            if (currentPrice >= signal.takeProfit) {
                                result = 'ACERTO';
                                pnl = riskAmount * 2;
                                shouldStop = true;
                            } else if (currentPrice <= signal.stopLoss) {
                                result = 'ERRO';
                                pnl = -riskAmount;
                                shouldStop = true;
                            }
                        } else {
                            if (currentPrice <= signal.takeProfit) {
                                result = 'ACERTO';
                                pnl = riskAmount * 2;
                                shouldStop = true;
                            } else if (currentPrice >= signal.stopLoss) {
                                result = 'ERRO';
                                pnl = -riskAmount;
                                shouldStop = true;
                            }
                        }
                        
                        if (shouldStop) {
                            clearInterval(monitoringInterval);
                            clearTimeout(verificationTimerId);
                            verificationTimers.current.delete(signal.id);

                            // ATUALIZAR AUDITORIA
                            if (window.auditSystemRef) {
                                try {
                                    if (window.debugAudit) {
                                        console.log('üîç [MONITOR] Atualizando auditoria');
                                    }
                                    window.auditSystemRef.updateSignalOutcome(
                                        signal.id,
                                        result,
                                        currentPrice,
                                        pnl,
                                        signal.executionDetails
                                    );
                                } catch (error) {
                                    console.error('‚ùå [MONITOR] Erro ao atualizar auditoria:', error);
                                }
                            }
                            
                            verifySignalOutcome(signal, result, pnl, currentPrice);
                        }
                    }, 5000);
                    
                    const verificationTimerId = setTimeout(() => {
                        clearInterval(monitoringInterval);
                        verifySignalOutcome(signal);
                    }, verificationDelay);

                    verificationTimers.current.set(signal.id, {
                        timer: verificationTimerId,
                        interval: monitoringInterval
                    });
                } catch (error) {
                    console.error('Erro ao agendar verifica√ß√£o:', error);
                }
            };

            const verifySignalOutcome = async (signal, forcedResult = null, forcedPnl = null, forcedPrice = null) => {
                try {
                    if (!marketData) return;

                    let result = forcedResult || 'EXPIRADO';
                    let pnl = forcedPnl || 0;
                    let currentPrice = forcedPrice || marketData.getLatestPrice().close;
                    
                    if (!forcedResult) {
                        if (signal.direction === 'BUY') {
                            if (currentPrice >= signal.takeProfit) {
                                result = 'ACERTO';
                                pnl = riskAmount * 2;
                            } else if (currentPrice <= signal.stopLoss) {
                                result = 'ERRO';
                                pnl = -riskAmount;
                            }
                        } else {
                            if (currentPrice <= signal.takeProfit) {
                                result = 'ACERTO';
                                pnl = riskAmount * 2;
                            } else if (currentPrice >= signal.stopLoss) {
                                result = 'ERRO';
                                pnl = -riskAmount;
                            }
                        }
                    }

                    signal.status = result;
                    signal.pnl = pnl;
                    signal.finalPrice = currentPrice;

                    // ATUALIZAR AUDITORIA
                    if (window.auditSystemRef) {
                        try {
                            if (window.debugAudit) {
                                console.log('üîç [VERIFY] Atualizando auditoria');
                            }
                            window.auditSystemRef.updateSignalOutcome(
                                signal.id,
                                result,
                                currentPrice,
                                pnl,
                                signal.executionDetails
                            );
                        } catch (error) {
                            console.error('‚ùå [VERIFY] Erro ao atualizar auditoria:', error);
                        }
                    }

                    if (alphaEngine && result !== 'EXPIRADO') {
                        await alphaEngine.learnFromTrade(signal, result);
                    }

                    setSignals(prev => prev.map(s => 
                        s.id === signal.id ? { ...s, status: result, pnl, finalPrice: currentPrice } : s
                    ));

                    showNotification(
                        result === 'ACERTO' 
                            ? `‚úÖ Sinal confirmado: +${formatBRL(pnl)}`
                            : result === 'ERRO'
                            ? `‚ùå Stop atingido: ${formatBRL(pnl)}`
                            : `‚è±Ô∏è Sinal expirado`
                    );

                    verificationTimers.current.delete(signal.id);
                } catch (error) {
                    console.log('Erro na verifica√ß√£o:', error);
                }
            };

            const showNotification = (message) => {
                setNotification(message);
                setTimeout(() => setNotification(null), 3000);
            };

            const dismissSignal = (signalId) => {
                const timerData = verificationTimers.current.get(signalId);
                if (timerData) {
                    if (timerData.timer) clearTimeout(timerData.timer);
                    if (timerData.interval) clearInterval(timerData.interval);
                    verificationTimers.current.delete(signalId);
                }
                
                setSignals(prev => prev.filter(s => s && s.id !== signalId));
            };

            const formatBRL = (value) => {
                if (value === null || value === undefined) return 'R$ 0,00';
                return value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            };

            return (
                <div className="app">
                    <Sidebar currentView={currentView} setCurrentView={setCurrentView} />
                    <div className="main-content">
                        <Header 
                            isActive={isActive} 
                            setIsActive={setIsActive}
                            mode={mode}
                            setMode={setMode}
                            dataSource={dataSource}
                        />
                        
                        {currentView === 'dashboard' && (
                            <Dashboard 
                                signals={signals}
                                alphaEngine={alphaEngine}
                                minScore={minScore}
                                setMinScore={setMinScore}
                                dismissSignal={dismissSignal}
                                riskAmount={riskAmount}
                                setRiskAmount={setRiskAmount}
                                formatBRL={formatBRL}
                                mode={mode}
                            />
                        )}
                        
                        {currentView === 'audit' && (
                            <AuditView 
                                auditSystem={auditSystem}
                                formatBRL={formatBRL}
                            />
                        )}
                        
                        {currentView === 'settings' && (
                            <Settings 
                                minScore={minScore}
                                setMinScore={setMinScore}
                            />
                        )}
                    </div>
                    
                    {notification && (
                        <div className="notification">
                            {notification}
                        </div>
                    )}
                </div>
            );
        }

        function Sidebar({ currentView, setCurrentView }) {
            const menuItems = [
                { id: 'dashboard', label: 'Dashboard', icon: 'üìä' },
                { id: 'audit', label: 'Auditoria', icon: 'üìã' },
                { id: 'settings', label: 'Configura√ß√µes', icon: '‚öôÔ∏è' }
            ];

            return (
                <div className="sidebar">
                    <div className="logo">‚ö° Alpha-Learner v2.2</div>
                    {menuItems.map(item => (
                        <div 
                            key={item.id}
                            className={`nav-item ${currentView === item.id ? 'active' : ''}`}
                            onClick={() => setCurrentView(item.id)}
                        >
                            {item.icon} {item.label}
                        </div>
                    ))}
                </div>
            );
        }

        function Header({ isActive, setIsActive, mode, setMode, dataSource }) {
            return (
                <div className="header">
                    <div>
                        <h2>Trading Console</h2>
                        <div className="mode-selector">
                            <div 
                                className={`mode-btn ${mode === 'manual' ? 'active' : ''}`}
                                onClick={() => setMode('manual')}
                            >
                                üéØ Modo Assistente
                            </div>
                            <div 
                                className={`mode-btn ${mode === 'auto' ? 'active' : ''}`}
                                onClick={() => setMode('auto')}
                            >
                                ü§ñ Modo Rob√¥
                            </div>
                        </div>
                    </div>
                    <div className="status-indicator">
                        <div className={`toggle-switch ${isActive ? 'active' : ''}`} 
                             onClick={() => setIsActive(!isActive)}>
                        </div>
                        <span>Alpha Engine: {isActive ? 'ATIVO' : 'INATIVO'}</span>
                        <div className="status-dot"></div>
                        
                        <div className={`data-source-badge ${dataSource === 'REAL' ? 'data-source-real' : 'data-source-simulated'}`}>
                            {dataSource === 'REAL' ? 'üü¢ DADOS EM TEMPO REAL' : 'üü† DADOS SIMULADOS'}
                        </div>
                    </div>
                </div>
            );
        }

        function Dashboard({ signals, alphaEngine, minScore, setMinScore, dismissSignal, riskAmount, setRiskAmount, formatBRL, mode }) {
            const getPerformanceMetrics = () => {
                if (!alphaEngine || !alphaEngine.performance) {
                    return { winRate: 0, totalPnL: 0, totalSignals: 0 };
                }
                return {
                    winRate: alphaEngine.performance.winRate || 0,
                    totalPnL: alphaEngine.performance.totalPnL || 0,
                    totalSignals: alphaEngine.performance.totalSignals || 0
                };
            };

            const metrics = getPerformanceMetrics();

            return (
                <div>
                    <div className="grid">
                        <div className="card">
                            <h3>‚öôÔ∏è Configura√ß√µes de Opera√ß√£o</h3>
                            <div className="form-group">
                                <label className="form-label">Score M√≠nimo: {minScore}%</label>
                                <input 
                                    type="range" 
                                    min="20" 
                                    max="95" 
                                    value={minScore}
                                    onChange={(e) => setMinScore(Number(e.target.value))}
                                    className="form-input"
                                />
                            </div>
                            <div className="form-group">
                                <label className="form-label">Valor de Risco (R$)</label>
                                <input 
                                    type="number"
                                    value={riskAmount}
                                    onChange={(e) => setRiskAmount(Number(e.target.value))}
                                    className="form-input"
                                />
                            </div>
                        </div>

                        <div className="card">
                            <h3>üìä M√©tricas em Tempo Real</h3>
                            <div className="metric-grid">
                                <div className="metric-card">
                                    <div className="metric-value">{signals ? signals.length : 0}</div>
                                    <div className="metric-label">Sinais Ativos</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value">{metrics.winRate.toFixed(1)}%</div>
                                    <div className="metric-label">Taxa de Acerto</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value" style={{ 
                                        color: metrics.totalPnL >= 0 ? '#00ff88' : '#ff4757',
                                        fontSize: '24px'
                                    }}>
                                        {formatBRL(metrics.totalPnL)}
                                    </div>
                                    <div className="metric-label">P&L Acumulado</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h3>üéØ Oportunidades de Trading</h3>
                        {!signals || signals.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '40px' }}>
                                üîç Aguardando sinais de alta qualidade...
                            </div>
                        ) : (
                            <div className="grid">
                                {signals.map(signal => (
                                    <SignalCard 
                                        key={signal ? signal.id : Math.random()}
                                        signal={signal}
                                        onDismiss={dismissSignal}
                                        formatBRL={formatBRL}
                                        mode={mode}
                                    />
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function SignalCard({ signal, onDismiss, formatBRL, mode }) {
            if (!signal) return null;

            return (
                <div className="signal-card">
                    <div className={`signal-direction ${(signal.direction || '').toLowerCase()}`}>
                        {signal.direction === 'BUY' ? 'üü¢' : 'üî¥'} {signal.direction || 'N/A'} {signal.symbol || 'N/A'}
                    </div>
                    
                    <div>
                        <span className="signal-score">Score: {signal.score || 0}%</span>
                        <span className={`signal-status ${signal.status?.toLowerCase() || 'pending'}`}>
                            {signal.status || 'PENDENTE'}
                        </span>
                    </div>
                    
                    <div className="signal-details">
                        <div><strong>Pre√ßo:</strong> {formatBRL(signal.price)}</div>
                        <div><strong>Timeframe:</strong> {signal.timeframe || 'N/A'}</div>
                        <div><strong>Stop Loss:</strong> {formatBRL(signal.stopLoss)}</div>
                        <div><strong>Take Profit:</strong> {formatBRL(signal.takeProfit)}</div>
                    </div>
                    
                    {signal.status !== 'PENDENTE' && signal.pnl !== undefined && (
                        <div style={{ 
                            padding: '12px', 
                            borderRadius: '8px', 
                            background: signal.pnl >= 0 ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 71, 87, 0.2)',
                            marginTop: '10px',
                            border: `1px solid ${signal.pnl >= 0 ? '#00ff88' : '#ff4757'}`
                        }}>
                            <strong>Resultado Final:</strong> 
                            <span style={{ 
                                color: signal.pnl >= 0 ? '#00ff88' : '#ff4757',
                                fontWeight: 'bold',
                                fontSize: '16px',
                                marginLeft: '10px'
                            }}>
                                {formatBRL(signal.pnl)}
                            </span>
                        </div>
                    )}
                    
                    <div style={{ marginTop: '15px' }}>
                        <button className="btn btn-secondary" onClick={() => onDismiss && onDismiss(signal.id)}>
                            ‚ùå Dispensar
                        </button>
                    </div>
                </div>
            );
        }

        function AuditView({ auditSystem, formatBRL }) {
            const [activeTab, setActiveTab] = useState('logs');
            const [logs, setLogs] = useState([]);
            const [alerts, setAlerts] = useState([]);
            const [perfByHour, setPerfByHour] = useState({});
            const [perfByScore, setPerfByScore] = useState({});

            useEffect(() => {
                if (!auditSystem) return;
                
                const updateData = () => {
                    setLogs(auditSystem.getRecentLogs(50));
                    setAlerts(auditSystem.getHealthAlerts());
                    setPerfByHour(auditSystem.getPerformanceByHour());
                    setPerfByScore(auditSystem.getPerformanceByScore());
                };

                updateData();
                const interval = setInterval(updateData, 5000);
                return () => clearInterval(interval);
            }, [auditSystem]);

            const handleExport = () => {
                if (!auditSystem) return;
                
                const csv = auditSystem.exportToCSV();
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `audit_${new Date().toISOString().split('T')[0]}.csv`;
                link.click();
            };

            const handleDiagnostic = () => {
                console.log('====== DIAGN√ìSTICO DO SISTEMA DE AUDITORIA ======');
                console.log('auditSystem existe?', !!auditSystem);
                console.log('window.auditSystemRef existe?', !!window.auditSystemRef);
                console.log('S√£o o mesmo objeto?', auditSystem === window.auditSystemRef);
                console.log('N√∫mero de logs:', auditSystem ? auditSystem.auditLogs.length : 0);
                console.log('Debug ativo?', window.debugAudit);
                console.log('===============================================');
                
                if (auditSystem) {
                    alert(`Sistema OK!\nLogs coletados: ${auditSystem.auditLogs.length}\nVerifique o console para detalhes.`);
                } else {
                    alert('ERRO: Sistema de auditoria n√£o inicializado!');
                }
            };

            const handleClearOldData = () => {
                if (!auditSystem) return;
                if (confirm('Limpar logs com mais de 7 dias?')) {
                    auditSystem.clearOldData(7);
                    setLogs(auditSystem.getRecentLogs(50));
                    alert('Dados antigos removidos!');
                }
            };

            if (!auditSystem) {
                return <div className="card"><h3>Carregando auditoria...</h3></div>;
            }

            return (
                <div>
                    <div className="warning-box">
                        üìä Sistema de Auditoria e Valida√ß√£o - Todos os sinais s√£o registrados para an√°lise
                        <div style={{ marginTop: '8px', fontSize: '11px' }}>
                            Logs coletados: <strong>{logs.length}</strong> | 
                            Debug: <strong>{window.debugAudit ? 'ATIVO' : 'INATIVO'}</strong> |
                            Sistema: <strong>{auditSystem ? 'OK' : 'ERRO'}</strong>
                        </div>
                    </div>

                    {logs.length === 0 && auditSystem && (
                        <div className="warning-box">
                            ‚ö†Ô∏è <strong>Nenhum log coletado ainda.</strong> O sistema registrar√° automaticamente quando sinais forem gerados.
                            <br/><small>Use o bot√£o "Diagn√≥stico" para verificar o status.</small>
                        </div>
                    )}

                    {alerts.length > 0 && (
                        <div className="card">
                            <h3>‚ö†Ô∏è Alertas de Integridade</h3>
                            {alerts.map((alert, idx) => (
                                <div key={idx} className={alert.type === 'error' ? 'error-box' : 'warning-box'} style={{ marginBottom: '10px' }}>
                                    {alert.type === 'error' ? '‚ùå' : '‚ö†Ô∏è'} {alert.message}
                                </div>
                            ))}
                        </div>
                    )}

                    <div className="card">
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
                            <h3>Dados de Auditoria</h3>
                            <div style={{ display: 'flex', gap: '10px' }}>
                                <button className="btn btn-secondary" onClick={handleDiagnostic}>
                                    üîç Diagn√≥stico
                                </button>
                                <button className="btn btn-secondary" onClick={handleClearOldData}>
                                    üóëÔ∏è Limpar Antigos
                                </button>
                                <button className="btn btn-primary" onClick={handleExport}>
                                    üì• Exportar CSV
                                </button>
                            </div>
                        </div>

                        <div className="mode-selector" style={{ marginBottom: '20px' }}>
                            <div className={`mode-btn ${activeTab === 'logs' ? 'active' : ''}`} onClick={() => setActiveTab('logs')}>
                                üìã Logs Detalhados
                            </div>
                            <div className={`mode-btn ${activeTab === 'hour' ? 'active' : ''}`} onClick={() => setActiveTab('hour')}>
                                ‚è∞ Por Hor√°rio
                            </div>
                            <div className={`mode-btn ${activeTab === 'score' ? 'active' : ''}`} onClick={() => setActiveTab('score')}>
                                üìä Score vs Resultado
                            </div>
                        </div>

                        {activeTab === 'logs' && (
                            <div style={{ maxHeight: '600px', overflowY: 'auto' }}>
                                {logs.length === 0 ? (
                                    <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '40px' }}>
                                        Nenhum log ainda
                                    </div>
                                ) : (
                                    logs.map((log, idx) => (
                                        <div key={idx} style={{
                                            padding: '15px',
                                            margin: '10px 0',
                                            border: '1px solid rgba(255, 255, 255, 0.1)',
                                            borderRadius: '8px',
                                            background: log.outcome === 'ACERTO' ? 'rgba(0, 255, 136, 0.05)' : 
                                                       log.outcome === 'ERRO' ? 'rgba(255, 71, 87, 0.05)' : 
                                                       'rgba(255, 255, 255, 0.02)'
                                        }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
                                                <strong>{log.metadata.direction} {log.metadata.symbol}</strong>
                                                <span style={{ fontSize: '12px', color: '#a0a0a0' }}>
                                                    {new Date(log.generatedAt).toLocaleString('pt-BR')}
                                                </span>
                                            </div>
                                            <div style={{ fontSize: '13px', color: '#c0c0c0' }}>
                                                <div>Score: {log.scoreRange} | Hor√°rio: {log.hourOfDay}h</div>
                                                <div>Pre√ßo Te√≥rico: {formatBRL(log.prices.theoretical)}</div>
                                                {log.outcome && (
                                                    <div style={{ marginTop: '8px', color: log.outcome === 'ACERTO' ? '#00ff88' : log.outcome === 'ERRO' ? '#ff4757' : '#ffc107' }}>
                                                        Resultado: {log.outcome} | P&L: {formatBRL(log.prices.finalPnL)}
                                                        <div style={{ fontSize: '11px', marginTop: '3px' }}>{log.reason}</div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    ))
                                )}
                            </div>
                        )}

                        {activeTab === 'hour' && (
                            <div>
                                {Object.keys(perfByHour).length === 0 ? (
                                    <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '40px' }}>
                                        Dados insuficientes
                                    </div>
                                ) : (
                                    Object.entries(perfByHour).sort((a, b) => Number(a[0]) - Number(b[0])).map(([hour, stats]) => {
                                        const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                                        return (
                                            <div key={hour} style={{
                                                padding: '15px',
                                                margin: '10px 0',
                                                border: '1px solid rgba(255, 255, 255, 0.1)',
                                                borderRadius: '8px'
                                            }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                    <div>
                                                        <strong>{hour}:00h - {hour}:59h</strong>
                                                        <div style={{ fontSize: '13px', color: '#a0a0a0', marginTop: '5px' }}>
                                                            Total: {stats.total} | Vit√≥rias: {stats.wins} | Derrotas: {stats.losses}
                                                        </div>
                                                    </div>
                                                    <div style={{ textAlign: 'right' }}>
                                                        <div style={{ fontSize: '24px', color: winRate >= 50 ? '#00ff88' : '#ff4757', fontWeight: 'bold' }}>
                                                            {winRate.toFixed(1)}%
                                                        </div>
                                                        <div style={{ fontSize: '14px', color: stats.totalPnL >= 0 ? '#00ff88' : '#ff4757' }}>
                                                            {formatBRL(stats.totalPnL)}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })
                                )}
                            </div>
                        )}

                        {activeTab === 'score' && (
                            <div>
                                {Object.keys(perfByScore).length === 0 ? (
                                    <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '40px' }}>
                                        Dados insuficientes
                                    </div>
                                ) : (
                                    Object.entries(perfByScore).sort((a, b) => b[0].localeCompare(a[0])).map(([range, stats]) => {
                                        const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                                        return (
                                            <div key={range} style={{
                                                padding: '15px',
                                                margin: '10px 0',
                                                border: '1px solid rgba(255, 255, 255, 0.1)',
                                                borderRadius: '8px'
                                            }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                    <div>
                                                        <strong>Score: {range}%</strong>
                                                        <div style={{ fontSize: '13px', color: '#a0a0a0', marginTop: '5px' }}>
                                                            Total: {stats.total} | Vit√≥rias: {stats.wins} | Derrotas: {stats.losses}
                                                        </div>
                                                    </div>
                                                    <div style={{ fontSize: '20px', color: winRate >= 50 ? '#00ff88' : '#ff4757', fontWeight: 'bold' }}>
                                                        {winRate.toFixed(1)}%
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function Settings({ minScore, setMinScore }) {
            return (
                <div>
                    <div className="card">
                        <h3>‚öôÔ∏è Configura√ß√µes Gerais</h3>
                        <div className="form-group">
                            <label className="form-label">Score M√≠nimo: {minScore}%</label>
                            <input 
                                type="range"
                                min="50"
                                max="95"
                                value={minScore}
                                onChange={(e) => setMinScore(Number(e.target.value))}
                                className="form-input"
                            />
                        </div>
                    </div>

                    <div className="card">
                        <h3>üìö Sobre o Alpha-Learner v2.2</h3>
                        <p style={{ lineHeight: '1.6', color: '#c0c0c0' }}>
                            Plataforma de trading algor√≠tmico com Machine Learning adaptativo 
                            e sistema de auditoria integrado.
                        </p>
                        <div style={{ marginTop: '15px', fontSize: '14px', color: '#00ff88' }}>
                            Vers√£o: 2.2.0 | Build: 2024.005 | Sistema de Auditoria Corrigido
                        </div>
                    </div>
                </div>
            );
        }

        // Renderizar aplica√ß√£o
        try {
            const rootElement = document.getElementById('root');
            if (rootElement) {
                ReactDOM.render(<App />, rootElement);
            }
        } catch (error) {
            console.error('Erro ao renderizar:', error);
        }
    </script>
</body>
</html>
