<artifact identifier="alpha-learner-v2.2-protected" type="text/html" title="Alpha-Learner Trading Platform v2.2 - Protected Robot Mode">
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpha-Learner Trading Platform v2.2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.5/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
        color: #e0e0e0;
        min-height: 100vh;
    }

    .app {
        display: flex;
        min-height: 100vh;
    }

    .sidebar {
        width: 250px;
        background: rgba(20, 20, 40, 0.9);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-right: 1px solid rgba(255, 255, 255, 0.1);
    }

    .logo {
        font-size: 24px;
        font-weight: bold;
        color: #00ff88;
        margin-bottom: 30px;
        text-align: center;
    }

    .nav-item {
        padding: 12px 16px;
        margin: 8px 0;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 1px solid transparent;
    }

    .nav-item:hover {
        background: rgba(0, 255, 136, 0.1);
        border-color: rgba(0, 255, 136, 0.3);
    }

    .nav-item.active {
        background: rgba(0, 255, 136, 0.2);
        border-color: #00ff88;
    }

    .main-content {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        backdrop-filter: blur(10px);
        flex-wrap: wrap;
        gap: 15px;
    }

    .status-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
    }

    .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #00ff88;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    .data-source-badge {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 5px;
        animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: scale(0.9); }
        to { opacity: 1; transform: scale(1); }
    }

    .data-source-real {
        background: rgba(0, 255, 136, 0.2);
        border: 1px solid #00ff88;
        color: #00ff88;
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }

    .data-source-simulated {
        background: rgba(255, 165, 0, 0.2);
        border: 1px solid #ffa500;
        color: #ffa500;
    }

    .card {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 24px;
        margin-bottom: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
    }

    .card h3 {
        color: #00ff88;
        margin-bottom: 16px;
        font-size: 18px;
    }

    .warning-box {
        background: rgba(255, 193, 7, 0.1);
        border: 1px solid rgba(255, 193, 7, 0.3);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 20px;
        font-size: 13px;
        color: #ffc107;
    }

    .success-box {
        background: rgba(0, 255, 136, 0.1);
        border: 1px solid rgba(0, 255, 136, 0.3);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 20px;
        font-size: 13px;
        color: #00ff88;
    }

    .error-box {
        background: rgba(255, 71, 87, 0.1);
        border: 1px solid rgba(255, 71, 87, 0.3);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 20px;
        font-size: 13px;
        color: #ff4757;
    }

    .api-provider-card {
        margin-bottom: 30px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        transition: all 0.3s ease;
    }

    .api-provider-card:hover {
        border-color: rgba(0, 255, 136, 0.3);
        box-shadow: 0 4px 12px rgba(0, 255, 136, 0.1);
    }

    .api-provider-card.connected {
        border-color: #00ff88;
        background: rgba(0, 255, 136, 0.05);
    }

    .api-status-badge {
        margin-left: auto;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
    }

    .api-status-connected {
        background: rgba(0, 255, 136, 0.2);
        color: #00ff88;
    }

    .api-status-disconnected {
        background: rgba(255, 71, 87, 0.2);
        color: #ff4757;
    }

    .api-status-testing {
        background: rgba(255, 193, 7, 0.2);
        color: #ffc107;
    }

    .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
    }

    .signal-card {
        background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.05) 100%);
        border: 1px solid #00ff88;
        border-radius: 16px;
        padding: 20px;
        position: relative;
        animation: slideIn 0.5s ease-out;
    }

    .signal-card.urgent {
        animation: pulse-urgent 1s infinite;
    }

    .signal-card.success {
        border-color: #00ff88;
        background: linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 255, 136, 0.1) 100%);
    }

    .signal-card.error {
        border-color: #ff4757;
        background: linear-gradient(135deg, rgba(255, 71, 87, 0.2) 0%, rgba(255, 71, 87, 0.1) 100%);
    }

    @keyframes pulse-urgent {
        0%, 100% { 
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        50% { 
            border-color: #ffed4e;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
    }

    @keyframes slideIn {
        from { transform: translateX(-20px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    .signal-direction {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 10px;
    }

    .signal-direction.buy {
        color: #00ff88;
    }

    .signal-direction.sell {
        color: #ff4757;
    }

    .signal-score {
        background: rgba(0, 255, 136, 0.2);
        padding: 8px 16px;
        border-radius: 20px;
        display: inline-block;
        margin-bottom: 15px;
        font-weight: bold;
    }

    .signal-status {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        display: inline-block;
        margin-left: 10px;
    }

    .signal-status.pending {
        background: rgba(255, 193, 7, 0.2);
        color: #ffc107;
    }

    .signal-status.success {
        background: rgba(0, 255, 136, 0.2);
        color: #00ff88;
    }

    .signal-status.error {
        background: rgba(255, 71, 87, 0.2);
        color: #ff4757;
    }

    .signal-status.expired {
        background: rgba(158, 158, 158, 0.2);
        color: #9e9e9e;
    }

    .signal-details {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 15px;
        font-size: 14px;
    }

    .signal-actions {
        display: flex;
        gap: 10px;
    }

    .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.3s ease;
        font-size: 14px;
    }

    .btn-primary {
        background: #00ff88;
        color: #000;
    }

    .btn-primary:hover:not(:disabled) {
        background: #00cc6a;
        transform: translateY(-2px);
    }

    .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-secondary:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.2);
    }

    .btn-danger {
        background: rgba(255, 71, 87, 0.2);
        color: #ff4757;
        border: 1px solid #ff4757;
    }

    .btn-danger:hover:not(:disabled) {
        background: rgba(255, 71, 87, 0.3);
    }

    .btn-emergency {
        background: rgba(255, 0, 0, 0.8);
        color: white;
        border: 2px solid #ff0000;
        font-weight: bold;
        font-size: 16px;
        padding: 15px 30px;
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    }

    .btn-emergency:hover:not(:disabled) {
        background: rgba(255, 0, 0, 1);
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
    }

    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .metric-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
    }

    .metric-card {
        background: rgba(255, 255, 255, 0.05);
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .metric-value {
        font-size: 32px;
        font-weight: bold;
        color: #00ff88;
        margin-bottom: 8px;
    }

    .metric-label {
        font-size: 14px;
        color: #a0a0a0;
    }

    .form-group {
        margin-bottom: 20px;
    }

    .form-label {
        display: block;
        margin-bottom: 8px;
        color: #c0c0c0;
        font-weight: 500;
    }

    .form-input, .form-select {
        width: 100%;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: #e0e0e0;
        font-size: 16px;
    }

    .form-select {
        cursor: pointer;
    }

    .form-input:focus, .form-select:focus {
        outline: none;
        border-color: #00ff88;
        box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.2);
    }

    .toggle-switch {
        position: relative;
        width: 60px;
        height: 30px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .toggle-switch.active {
        background: #00ff88;
    }

    .toggle-switch::after {
        content: '';
        position: absolute;
        top: 3px;
        left: 3px;
        width: 24px;
        height: 24px;
        background: white;
        border-radius: 50%;
        transition: transform 0.3s ease;
    }

    .toggle-switch.active::after {
        transform: translateX(30px);
    }

    .weight-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .weight-bar {
        width: 100px;
        height: 8px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        overflow: hidden;
    }

    .weight-fill {
        height: 100%;
        background: #00ff88;
        transition: width 0.3s ease;
    }

    .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 255, 136, 0.9);
        color: #000;
        padding: 16px 20px;
        border-radius: 8px;
        font-weight: 500;
        animation: slideInRight 0.5s ease-out;
        z-index: 1000;
        max-width: 400px;
    }

    @keyframes slideInRight {
        from { transform: translateX(100px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    .mode-selector {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
    }

    .mode-btn {
        flex: 1;
        padding: 15px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        color: #e0e0e0;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
    }

    .mode-btn.active {
        border-color: #00ff88;
        background: rgba(0, 255, 136, 0.1);
        color: #00ff88;
    }

    .connection-status-line {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        margin-top: 15px;
    }

    .spinner {
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-top: 2px solid #00ff88;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .robot-status-panel {
        background: rgba(255, 193, 7, 0.15);
        border: 2px solid #ffc107;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .position-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 10px;
    }

    .log-entry {
        padding: 8px 12px;
        margin: 5px 0;
        border-radius: 6px;
        font-size: 12px;
        font-family: 'Courier New', monospace;
    }

    .log-entry.info {
        background: rgba(0, 184, 217, 0.1);
        border-left: 3px solid #00b8d9;
    }

    .log-entry.success {
        background: rgba(0, 255, 136, 0.1);
        border-left: 3px solid #00ff88;
    }

    .log-entry.warning {
        background: rgba(255, 193, 7, 0.1);
        border-left: 3px solid #ffc107;
    }

    .log-entry.error {
        background: rgba(255, 71, 87, 0.1);
        border-left: 3px solid #ff4757;
    }
</style>
</head>
<body>
    <div id="root"></div>
<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    /* ========================================
       MÃ“DULO DE INTEGRAÃ‡ÃƒO DE APIs
       ======================================== */

    const API_PROVIDERS = {
        ALPHA_VANTAGE: {
            name: 'Alpha Vantage',
            icon: 'ðŸ“ˆ',
            requiresSecret: false,
            baseUrl: 'https://www.alphavantage.co/query',
            description: 'Dados de aÃ§Ãµes, forex e cripto (500 calls/dia grÃ¡tis)'
        },
        BINANCE: {
            name: 'Binance',
            icon: 'ðŸŸ¡',
            requiresSecret: true,
            baseUrl: 'https://api.binance.com/api/v3',
            description: 'Dados de criptomoedas em tempo real'
        },
        COINGECKO: {
            name: 'CoinGecko',
            icon: 'ðŸ¦Ž',
            requiresSecret: false,
            baseUrl: 'https://api.coingecko.com/api/v3',
            description: 'Dados de cripto (requer chave Demo API gratuita)'
        },
        POLYGON: {
            name: 'Polygon.io',
            icon: 'ðŸ”º',
            requiresSecret: false,
            baseUrl: 'https://api.polygon.io/v2',
            description: 'Dados de aÃ§Ãµes e forex premium'
        }
    };

    class APIConnectionManager {
        constructor() {
            this.connections = new Map();
            this.activeProvider = null;
            this.loadFromStorage();
        }

        loadFromStorage() {
            try {
                const saved = localStorage.getItem('api_connections');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.connections = new Map(Object.entries(data.connections || data));
                    this.activeProvider = data.activeProvider || null;
                }
            } catch (error) {
                console.log('Erro ao carregar conexÃµes:', error);
            }
        }

        saveToStorage() {
            try {
                const data = {
                    connections: Object.fromEntries(this.connections),
                    activeProvider: this.activeProvider
                };
                localStorage.setItem('api_connections', JSON.stringify(data));
            } catch (error) {
                console.log('Erro ao salvar conexÃµes:', error);
            }
        }

        addConnection(provider, apiKey, secretKey = null) {
            this.connections.set(provider, {
                apiKey,
                secretKey,
                status: 'disconnected',
                lastTested: null
            });
            this.saveToStorage();
        }

        removeConnection(provider) {
            this.connections.delete(provider);
            if (this.activeProvider === provider) {
                this.activeProvider = null;
            }
            this.saveToStorage();
        }

        setActive(provider) {
            if (this.connections.has(provider)) {
                this.activeProvider = provider;
                this.saveToStorage();
                return true;
            }
            return false;
        }

        getActiveConnection() {
            if (!this.activeProvider) return null;
            return {
                provider: this.activeProvider,
                ...this.connections.get(this.activeProvider)
            };
        }

        updateStatus(provider, status) {
            const conn = this.connections.get(provider);
            if (conn) {
                conn.status = status;
                conn.lastTested = new Date();
                this.saveToStorage();
            }
        }
    }

    /* ========================================
       MÃ“DULO DE EXECUÃ‡ÃƒO DE ORDENS (PROTEGIDO)
       ======================================== */

    class OrderExecutionManager {
        constructor(apiManager) {
            this.apiManager = apiManager;
            this.activePositions = new Map();
            this.executionHistory = [];
            this.systemLogs = [];
            this.maxPositions = 3;
            this.virtualBalance = 10000; // Saldo virtual inicial
            this.loadFromStorage();
        }

        loadFromStorage() {
            try {
                const saved = localStorage.getItem('execution_manager_data');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.executionHistory = data.executionHistory || [];
                    this.virtualBalance = data.virtualBalance || 10000;
                    this.systemLogs = data.systemLogs || [];
                    console.log(`ðŸ“¦ Gerenciador carregado: ${this.executionHistory.length} execuÃ§Ãµes`);
                }
            } catch (error) {
                console.error('Erro ao carregar gerenciador:', error);
            }
        }

        saveToStorage() {
            try {
                const data = {
                    executionHistory: this.executionHistory.slice(-100),
                    virtualBalance: this.virtualBalance,
                    systemLogs: this.systemLogs.slice(-200)
                };
                localStorage.setItem('execution_manager_data', JSON.stringify(data));
            } catch (error) {
                console.error('Erro ao salvar gerenciador:', error);
            }
        }

        log(message, type = 'info') {
            const logEntry = {
                timestamp: new Date().toISOString(),
                message,
                type
            };
            this.systemLogs.push(logEntry);
            
            if (this.systemLogs.length > 200) {
                this.systemLogs = this.systemLogs.slice(-200);
            }
            
            this.saveToStorage();
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        async executeSignalAuto(signal, mode, riskAmount) {
            if (mode !== 'auto') {
                this.log('Modo manual - execuÃ§Ã£o nÃ£o automÃ¡tica', 'info');
                return {
                    success: false,
                    reason: 'manual_mode',
                    message: 'Modo manual ativo'
                };
            }

            // PROTEÃ‡ÃƒO 1: Verificar limite de posiÃ§Ãµes
            if (this.activePositions.size >= this.maxPositions) {
                this.log(`Limite de ${this.maxPositions} posiÃ§Ãµes atingido`, 'warning');
                return {
                    success: false,
                    reason: 'max_positions',
                    message: `MÃ¡ximo de ${this.maxPositions} posiÃ§Ãµes simultÃ¢neas atingido`
                };
            }

            // PROTEÃ‡ÃƒO 2: Verificar saldo disponÃ­vel
            if (riskAmount > this.virtualBalance * 0.02) {
                this.log(`Risco muito alto: R$${riskAmount} > 2% do saldo`, 'warning');
                return {
                    success: false,
                    reason: 'risk_too_high',
                    message: 'Risco excede 2% do saldo disponÃ­vel'
                };
            }

            if (riskAmount > this.virtualBalance) {
                this.log('Saldo insuficiente', 'error');
                return {
                    success: false,
                    reason: 'insufficient_balance',
                    message: 'Saldo insuficiente para executar ordem'
                };
            }

            const activeConn = this.apiManager.getActiveConnection();
            
            if (!activeConn) {
                this.log('Sem conexÃ£o ativa', 'error');
                return {
                    success: false,
                    reason: 'no_connection',
                    message: 'Nenhuma conexÃ£o de API ativa'
                };
            }

            this.log(`ðŸ¤– Iniciando execuÃ§Ã£o: ${signal.direction} ${signal.symbol}`, 'info');

            try {
                let orderResult;
                
                switch(activeConn.provider) {
                    case 'BINANCE':
                        orderResult = await this.executeBinanceTestnetOrder(signal, activeConn, riskAmount);
                        break;
                    default:
                        orderResult = await this.executeSimulatedOrder(signal, riskAmount);
                        break;
                }

                if (orderResult.success) {
                    // Registrar posiÃ§Ã£o ativa
                    this.activePositions.set(signal.id, {
                        signal,
                        orderResult,
                        openTime: new Date(),
                        riskAmount
                    });

                    // Deduzir do saldo virtual
                    this.virtualBalance -= riskAmount;

                    this.recordExecution(signal, orderResult);
                    this.log(`âœ… Ordem executada: ${orderResult.orderId}`, 'success');
                    this.saveToStorage();
                }

                return orderResult;

            } catch (error) {
                this.log(`âŒ Erro na execuÃ§Ã£o: ${error.message}`, 'error');
                return {
                    success: false,
                    reason: 'execution_error',
                    message: error.message
                };
            }
        }

        async executeBinanceTestnetOrder(signal, connection, riskAmount) {
            const TESTNET_URL = 'https://testnet.binance.vision/api/v3';
            
            try {
                const quantity = this.calculatePositionSize(signal, riskAmount);
                
                const params = new URLSearchParams({
                    symbol: signal.symbol,
                    side: signal.direction,
                    type: 'MARKET',
                    quantity: quantity.toString(),
                    timestamp: Date.now()
                });

                const signature = await this.signBinanceRequest(params.toString(), connection.secretKey);
                params.append('signature', signature);

                const response = await fetch(`${TESTNET_URL}/order?${params.toString()}`, {
                    method: 'POST',
                    headers: {
                        'X-MBX-APIKEY': connection.apiKey
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    return {
                        success: true,
                        orderId: data.orderId,
                        executedQty: data.executedQty,
                        executedPrice: data.fills?.[0]?.price || signal.price,
                        commission: data.fills?.[0]?.commission || 0,
                        timestamp: data.transactTime
                    };
                } else {
                    throw new Error(data.msg || 'Erro ao executar ordem Binance');
                }

            } catch (error) {
                this.log(`Fallback para simulaÃ§Ã£o: ${error.message}`, 'warning');
                return await this.executeSimulatedOrder(signal, riskAmount);
            }
        }

        async executeSimulatedOrder(signal, riskAmount) {
            const slippage = (Math.random() * 0.001) + 0.0005;
            const executedPrice = signal.direction === 'BUY' 
                ? signal.price * (1 + slippage)
                : signal.price * (1 - slippage);

            const quantity = this.calculatePositionSize(signal, riskAmount);

            await new Promise(resolve => setTimeout(resolve, 100));

            return {
                success: true,
                orderId: 'SIM-' + Date.now(),
                executedQty: quantity,
                executedPrice: executedPrice,
                commission: (executedPrice * quantity) * 0.001,
                timestamp: Date.now(),
                simulated: true
            };
        }

        calculatePositionSize(signal, riskAmount) {
            const riskPercentage = Math.abs((signal.price - signal.stopLoss) / signal.price);
            const quantity = (riskAmount / signal.price) / riskPercentage;
            return Math.floor(quantity * 1000000) / 1000000;
        }

        async signBinanceRequest(queryString, secretKey) {
            const encoder = new TextEncoder();
            const keyData = encoder.encode(secretKey);
            const messageData = encoder.encode(queryString);
            
            const key = await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'HMAC', hash: 'SHA-256' },
                false,
                ['sign']
            );
            
            const signature = await crypto.subtle.sign('HMAC', key, messageData);
            const hashArray = Array.from(new Uint8Array(signature));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        closePosition(signalId, result, pnl) {
            const position = this.activePositions.get(signalId);
            
            if (position) {
                // Retornar saldo (risco + P&L)
                this.virtualBalance += position.riskAmount + pnl;
                
                this.activePositions.delete(signalId);
                this.log(`ðŸ“Š PosiÃ§Ã£o fechada: ${result} | P&L: R$${pnl.toFixed(2)}`, 
                    pnl >= 0 ? 'success' : 'warning');
                this.saveToStorage();
            }
        }

        emergencyCloseAll() {
            this.log('ðŸš¨ FECHAMENTO DE EMERGÃŠNCIA ACIONADO', 'error');
            
            const closedPositions = [];
            this.activePositions.forEach((position, signalId) => {
                this.virtualBalance += position.riskAmount;
                closedPositions.push(signalId);
                this.log(`ðŸ›‘ PosiÃ§Ã£o ${signalId} fechada por emergÃªncia`, 'warning');
            });

            this.activePositions.clear();
            this.saveToStorage();

            return closedPositions;
        }

        recordExecution(signal, orderResult) {
            const execution = {
                signalId: signal.id,
                timestamp: new Date().toISOString(),
                symbol: signal.symbol,
                direction: signal.direction,
                orderResult: orderResult,
                signal: {
                    score: signal.score,
                    price: signal.price,
                    stopLoss: signal.stopLoss,
                    takeProfit: signal.takeProfit
                }
            };

            this.executionHistory.push(execution);
            
            if (this.executionHistory.length > 100) {
                this.executionHistory = this.executionHistory.slice(-100);
            }
            
            this.saveToStorage();
        }

        getExecutionHistory() {
            return [...this.executionHistory];
        }

        getSystemLogs() {
            return [...this.systemLogs];
        }

        getActivePositions() {
            return Array.from(this.activePositions.values());
        }

        getVirtualBalance() {
            return this.virtualBalance;
        }

        setMaxPositions(max) {
            this.maxPositions = Math.max(1, Math.min(10, max));
            this.log(`Limite de posiÃ§Ãµes alterado para ${this.maxPositions}`, 'info');
            this.saveToStorage();
        }
    }

    /* ========================================
       FUNÃ‡Ã•ES DE API (mantidas do cÃ³digo original)
       ======================================== */

    async function fetchRealMarketData(provider, apiKey, symbol, timeframe, secretKey = null) {
        try {
            let url, response, data;

            switch(provider) {
                case 'ALPHA_VANTAGE':
                    const avInterval = timeframe === 'M5' ? '5min' : '15min';
                    url = `${API_PROVIDERS.ALPHA_VANTAGE.baseUrl}?function=TIME_SERIES_INTRADAY&symbol=${symbol}&interval=${avInterval}&apikey=${apiKey}`;
                    response = await fetch(url);
                    data = await response.json();
                    
                    if (data['Error Message'] || data['Note']) {
                        throw new Error(data['Error Message'] || 'Limite de API atingido');
                    }

                    return parseAlphaVantageData(data, avInterval);

                case 'BINANCE':
                    const interval = timeframe === 'M5' ? '5m' : '15m';
                    url = `${API_PROVIDERS.BINANCE.baseUrl}/klines?symbol=${symbol}&interval=${interval}&limit=200`;
                    response = await fetch(url);
                    data = await response.json();
                    
                    if (data.code) {
                        throw new Error(data.msg || 'Erro na API Binance');
                    }

                    return parseBinanceData(data);

                case 'COINGECKO':
                    const symbolMap = {
                        'BTC': 'bitcoin', 'BTCUSDT': 'bitcoin',
                        'ETH': 'ethereum', 'ETHUSDT': 'ethereum',
                        'BNB': 'binancecoin', 'BNBUSDT': 'binancecoin'
                    };
                    
                    const coinId = symbolMap[symbol.toUpperCase()] || 'bitcoin';
                    url = `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=1`;
                    
                    response = await fetch(url);
                    if (response.ok) {
                        data = await response.json();
                        if (data.prices && data.prices.length > 0) {
                            return parseCoinGeckoData(data);
                        }
                    }
                    throw new Error('CoinGecko: Dados nÃ£o disponÃ­veis');

                case 'POLYGON':
                    const multiplier = timeframe === 'M5' ? 5 : 15;
                    const to = new Date().toISOString().split('T')[0];
                    const from = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                    url = `${API_PROVIDERS.POLYGON.baseUrl}/aggs/ticker/${symbol}/range/${multiplier}/minute/${from}/${to}?apiKey=${apiKey}`;
                    response = await fetch(url);
                    data = await response.json();
                    
                    if (data.status === 'ERROR') {
                        throw new Error(data.error || 'Erro na API Polygon');
                    }

                    return parsePolygonData(data);

                default:
                    throw new Error('Provider nÃ£o suportado');
            }
        } catch (error) {
            console.error('Erro ao buscar dados reais:', error);
            throw error;
        }
    }

    function parseAlphaVantageData(data, interval) {
        const timeSeriesKey = `Time Series (${interval})`;
        const timeSeries = data[timeSeriesKey];
        
        if (!timeSeries) {
            throw new Error('Dados nÃ£o encontrados');
        }

        const candles = [];
        for (const [timestamp, values] of Object.entries(timeSeries)) {
            candles.push({
                timestamp: new Date(timestamp).getTime(),
                open: parseFloat(values['1. open']),
                high: parseFloat(values['2. high']),
                low: parseFloat(values['3. low']),
                close: parseFloat(values['4. close']),
                volume: parseFloat(values['5. volume'])
            });
        }

        return candles.sort((a, b) => a.timestamp - b.timestamp).slice(-200);
    }

    function parseBinanceData(data) {
        return data.map(candle => ({
            timestamp: candle[0],
            open: parseFloat(candle[1]),
            high: parseFloat(candle[2]),
            low: parseFloat(candle[3]),
            close: parseFloat(candle[4]),
            volume: parseFloat(candle[5])
        }));
    }

    function parseCoinGeckoData(data) {
        return data.prices.slice(-200).map(point => {
            const price = point[1];
            return {
                timestamp: point[0],
                open: price,
                high: price * 1.005,
                low: price * 0.995,
                close: price,
                volume: 1000000
            };
        });
    }

    function parsePolygonData(data) {
        if (!data.results) throw new Error('Resultados nÃ£o encontrados');
        return data.results.map(candle => ({
            timestamp: candle.t,
            open: candle.o,
            high: candle.h,
            low: candle.l,
            close: candle.c,
            volume: candle.v
        }));
    }

    async function testAPIConnection(provider, apiKey, secretKey = null) {
        try {
            let testSymbol = 'BTCUSDT';
            if (provider === 'ALPHA_VANTAGE') testSymbol = 'IBM';
            else if (provider === 'COINGECKO') testSymbol = 'BTC';
            else if (provider === 'POLYGON') testSymbol = 'AAPL';
            
            await fetchRealMarketData(provider, apiKey, testSymbol, 'M5', secretKey);
            return { success: true, message: 'ConexÃ£o bem-sucedida!' };
        } catch (error) {
            return { 
                success: false, 
                message: `Falha na conexÃ£o: ${error.message}` 
            };
        }
    }

    /* ========================================
       CLASSES EXISTENTES (mantidas)
       ======================================== */

    class MemoryDB {
        constructor() {
            this.signals_history = [];
            this.ml_weights_evolution = [];
            this.config_snapshots = [];
            this.loadFromStorage();
        }

        loadFromStorage() {
            try {
                const saved = localStorage.getItem('alpha_learner_data');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.signals_history = data.signals_history || [];
                    this.ml_weights_evolution = data.ml_weights_evolution || [];
                    this.config_snapshots = data.config_snapshots || [];
                }
            } catch (error) {
                console.error('Erro ao carregar dados:', error);
            }
        }

        saveToStorage() {
            try {
                const data = {
                    signals_history: this.signals_history,
                    ml_weights_evolution: this.ml_weights_evolution,
                    config_snapshots: this.config_snapshots
                };
                localStorage.setItem('alpha_learner_data', JSON.stringify(data));
            } catch (error) {
                console.error('Erro ao salvar dados:', error);
            }
        }

        async saveSignal(signal) {
            this.signals_history.push({
                ...signal,
                savedAt: new Date().toISOString()
            });
            this.saveToStorage();
        }

        async getAllSignals() {
            return [...this.signals_history];
        }

        async saveWeightsSnapshot(weights, performance) {
            const snapshot = {
                date: new Date().toISOString(),
                weights: { ...weights },
                performance: { ...performance }
            };
            this.ml_weights_evolution.push(snapshot);
            this.saveToStorage();
        }

        async getWeightsHistory() {
            return [...this.ml_weights_evolution];
        }

        async getStatistics() {
            const signals = await this.getAllSignals();
            const completed = signals.filter(s => s.status !== 'PENDENTE');
            const successful = completed.filter(s => s.status === 'ACERTO');
            
            return {
                total: signals.length,
                completed: completed.length,
                successful: successful.length,
                winRate: completed.length > 0 ? (successful.length / completed.length) * 100 : 0,
                totalPnL: completed.reduce((sum, s) => sum + (s.pnl || 0), 0)
            };
        }
    }

    class MarketDataSimulator {
        constructor() {
            this.prices = [];
            this.timeframe = 'M5';
            this.generateInitialData();
        }

        generateInitialData() {
            const basePrice = 50000;
            for (let i = 0; i < 200; i++) {
                const timestamp = Date.now() - (200 - i) * 5 * 60 * 1000;
                const price = basePrice + Math.sin(i * 0.1) * 1000 + Math.random() * 200 - 100;
                this.prices.push({
                    timestamp,
                    open: price,
                    high: price + Math.random() * 50,
                    low: price - Math.random() * 50,
                    close: price + (Math.random() - 0.5) * 30,
                    volume: Math.random() * 1000000
                });
            }
        }

        getLatestPrice() {
            return this.prices[this.prices.length - 1];
        }

        addNewCandle() {
            const lastCandle = this.prices[this.prices.length - 1];
            const newPrice = lastCandle.close + (Math.random() - 0.5) * 100;
            const newCandle = {
                timestamp: Date.now(),
                open: newPrice,
                high: newPrice + Math.random() * 30,
                low: newPrice - Math.random() * 30,
                close: newPrice + (Math.random() - 0.5) * 20,
                volume: Math.random() * 1000000
            };
            this.prices.push(newCandle);
            if (this.prices.length > 200) {
                this.prices.shift();
            }
            return newCandle;
        }

        replaceWithRealData(realData) {
            if (realData && realData.length > 0) {
                this.prices = [...realData];
                return true;
            }
            return false;
        }
    }

    class TechnicalIndicators {
        static calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return 50;
            
            let gains = 0;
            let losses = 0;
            
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i].close - prices[i - 1].close;
                if (change > 0) gains += change;
                else losses -= change;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        static calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            if (prices.length < slowPeriod) return { macd: 0, signal: 0, histogram: 0 };
            
            const fastEMA = this.calculateEMA(prices.slice(-fastPeriod).map(p => p.close), fastPeriod);
            const slowEMA = this.calculateEMA(prices.slice(-slowPeriod).map(p => p.close), slowPeriod);
            const macd = fastEMA - slowEMA;
            
            return { macd, signal: macd * 0.9, histogram: macd * 0.1 };
        }

        static calculateEMA(values, period) {
            const k = 2 / (period + 1);
            let ema = values[0];
            for (let i = 1; i < values.length; i++) {
                ema = values[i] * k + ema * (1 - k);
            }
            return ema;
        }

        static calculateBollingerBands(prices, period = 20, stdDev = 2) {
            if (prices.length < period) return { upper: 0, middle: 0, lower: 0 };
            
            const recentPrices = prices.slice(-period).map(p => p.close);
            const sma = recentPrices.reduce((a, b) => a + b) / period;
            
            const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
            const sd = Math.sqrt(variance);
            
            return {
                upper: sma + (sd * stdDev),
                middle: sma,
                lower: sma - (sd * stdDev)
            };
        }

        static calculateStochastic(prices, kPeriod = 14, dPeriod = 3) {
            if (prices.length < kPeriod) return { k: 50, d: 50 };
            
            const recentPrices = prices.slice(-kPeriod);
            const highestHigh = Math.max(...recentPrices.map(p => p.high));
            const lowestLow = Math.min(...recentPrices.map(p => p.low));
            const currentClose = prices[prices.length - 1].close;
            
            const k = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
            const d = k * 0.95;
            
            return { k, d };
        }

        static calculateATR(prices, period = 14) {
            if (prices.length < period + 1) return prices[prices.length - 1].close * 0.02;
            
            let trSum = 0;
            for (let i = prices.length - period; i < prices.length; i++) {
                const high = prices[i].high;
                const low = prices[i].low;
                const prevClose = prices[i - 1].close;
                
                const tr = Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                );
                trSum += tr;
            }
            
            return trSum / period;
        }
    }

    class AlphaEngine {
        constructor(memoryDB) {
            this.memoryDB = memoryDB;
            this.weights = {
                rsi: 0.20,
                macd: 0.15,
                bollinger: 0.15,
                stochastic_events: 0.20,
                stochastic_divergence: 0.30
            };
            this.performance = {
                totalSignals: 0,
                successfulSignals: 0,
                winRate: 0,
                totalPnL: 0
            };
            this.warmUpModel();
        }

        async warmUpModel() {
            try {
                const stats = await this.memoryDB.getStatistics();
                if (stats.total > 0) {
                    this.performance = {
                        totalSignals: stats.total,
                        successfulSignals: stats.successful,
                        winRate: stats.winRate,
                        totalPnL: stats.totalPnL
                    };
                }
            } catch (error) {
                console.log('Erro ao aquecer modelo:', error);
            }
        }

        analyzeMarket(marketData, dataSource) {
            const prices = marketData.prices;
            const currentPrice = marketData.getLatestPrice();
            
            const rsi = TechnicalIndicators.calculateRSI(prices);
            const macd = TechnicalIndicators.calculateMACD(prices);
            const bollinger = TechnicalIndicators.calculateBollingerBands(prices);
            const stochastic = TechnicalIndicators.calculateStochastic(prices);
            
            const features = this.extractFeatures(currentPrice, rsi, macd, bollinger, stochastic);
            const signal = this.generateSignal(features, currentPrice, dataSource);
            
            return signal;
        }

        extractFeatures(currentPrice, rsi, macd, bollinger, stochastic) {
            return {
                rsi: {
                    value: rsi,
                    overbought: rsi > 70,
                    oversold: rsi < 30,
                    score: this.calculateRSIScore(rsi)
                },
                macd: {
                    value: macd.macd,
                    signal: macd.signal,
                    histogram: macd.histogram,
                    bullish: macd.macd > macd.signal,
                    score: this.calculateMACDScore(macd)
                },
                bollinger: {
                    position: (currentPrice.close - bollinger.lower) / (bollinger.upper - bollinger.lower),
                    squeeze: (bollinger.upper - bollinger.lower) / bollinger.middle < 0.1,
                    score: this.calculateBollingerScore(currentPrice.close, bollinger)
                },
                stochastic: {
                    k: stochastic.k,
                    d: stochastic.d,
                    overbought: stochastic.k > 80,
                    oversold: stochastic.k < 20,
                    crossover: this.detectStochasticCrossover(stochastic),
                    divergence: this.detectDivergence(),
                    score: this.calculateStochasticScore(stochastic)
                }
            };
        }

        calculateRSIScore(rsi) {
            if (rsi < 30) return 0.8;
            if (rsi > 70) return -0.8;
            return 0;
        }

        calculateMACDScore(macd) {
            if (macd.macd > macd.signal && macd.histogram > 0) return 0.7;
            if (macd.macd < macd.signal && macd.histogram < 0) return -0.7;
            return 0;
        }

        calculateBollingerScore(price, bollinger) {
            const position = (price - bollinger.lower) / (bollinger.upper - bollinger.lower);
            if (position < 0.2) return 0.6;
            if (position > 0.8) return -0.6;
            return 0;
        }

        calculateStochasticScore(stochastic) {
            let score = 0;
            if (stochastic.k < 20) score += 0.5;
            if (stochastic.k > 80) score -= 0.5;
            if (stochastic.k > stochastic.d) score += 0.3;
            else score -= 0.3;
            return score;
        }

        detectStochasticCrossover(stochastic) {
            return Math.abs(stochastic.k - stochastic.d) < 5;
        }

        detectDivergence() {
            return {
                present: Math.random() < 0.3,
                type: Math.random() > 0.5 ? 'bullish' : 'bearish',
                strength: Math.random() * 0.5 + 0.5
            };
        }

        generateSignal(features, currentPrice, dataSource) {
            let score = 0;
            const contributors = [];

            Object.keys(this.weights).forEach(indicator => {
                let indicatorScore = 0;
                
                switch(indicator) {
                    case 'rsi':
                        indicatorScore = features.rsi.score;
                        break;
                    case 'macd':
                        indicatorScore = features.macd.score;
                        break;
                    case 'bollinger':
                        indicatorScore = features.bollinger.score;
                        break;
                    case 'stochastic_events':
                        indicatorScore = features.stochastic.score;
                        break;
                    case 'stochastic_divergence':
                        if (features.stochastic.divergence.present) {
                            indicatorScore = features.stochastic.divergence.type === 'bullish' ? 0.8 : -0.8;
                            indicatorScore *= features.stochastic.divergence.strength;
                        }
                        break;
                }
                
                score += indicatorScore * this.weights[indicator];
                if (Math.abs(indicatorScore) > 0.1) {
                    contributors.push(indicator);
                }
            });

            const normalizedScore = Math.max(0, Math.min(100, (score + 1) * 50));

            if (normalizedScore < 25) {
                return null;
            }

            const direction = score > 0 ? 'BUY' : 'SELL';
            const atr = TechnicalIndicators.calculateATR([currentPrice]);
            
            const timeframeMinutes = direction === 'BUY' ? 5 : 15;
            const entryTime = new Date();
            entryTime.setMinutes(entryTime.getMinutes() + Math.floor(Math.random() * timeframeMinutes) + 1);
            
            const signal = {
                id: Date.now() + Math.random(),
                timestamp: new Date(),
                symbol: 'BTCUSDT',
                direction,
                timeframe: timeframeMinutes === 5 ? 'M5' : 'M15',
                score: Math.round(normalizedScore),
                price: currentPrice.close,
                entryTime: entryTime,
                stopLoss: direction === 'BUY' ? 
                    currentPrice.close - (atr * 2) : 
                    currentPrice.close + (atr * 2),
                takeProfit: direction === 'BUY' ? 
                    currentPrice.close + (atr * 4) : 
                    currentPrice.close - (atr * 4),
                contributors,
                divergence: features.stochastic.divergence.present ? features.stochastic.divergence : null,
                features,
                status: 'PENDENTE',
                dataSource,
                pnl: 0,
                executed: false
            };

            this.memoryDB.saveSignal(signal);

            return signal;
        }

        async learnFromTrade(signal, result) {
            const successful = result === 'ACERTO';
            const learningRate = 0.1;
            const multiplier = signal.divergence ? 2 : 1;
            
            signal.contributors.forEach(indicator => {
                if (successful) {
                    this.weights[indicator] = Math.min(1, this.weights[indicator] + learningRate * multiplier);
                } else {
                    this.weights[indicator] = Math.max(0, this.weights[indicator] - learningRate * multiplier);
                }
            });

            const totalWeight = Object.values(this.weights).reduce((a, b) => a + b, 0);
            Object.keys(this.weights).forEach(key => {
                this.weights[key] /= totalWeight;
            });

            this.performance.totalSignals++;
            if (successful) this.performance.successfulSignals++;
            this.performance.winRate = (this.performance.successfulSignals / this.performance.totalSignals) * 100;

            signal.status = result;
            await this.memoryDB.saveSignal(signal);

            if (this.performance.totalSignals % 10 === 0) {
                await this.memoryDB.saveWeightsSnapshot(this.weights, this.performance);
            }
        }
    }

    /* ========================================
       COMPONENTE APP PRINCIPAL (COM INTEGRAÃ‡ÃƒO DO ROBÃ”)
       ======================================== */

    function App() {
        const [currentView, setCurrentView] = useState('dashboard');
        const [mode, setMode] = useState('manual');
        const [isActive, setIsActive] = useState(false);
        const [signals, setSignals] = useState([]);
        const [marketData, setMarketData] = useState(null);
        const [alphaEngine, setAlphaEngine] = useState(null);
        const [notification, setNotification] = useState(null);
        const [minScore, setMinScore] = useState(50);
        const [riskAmount, setRiskAmount] = useState(100);
        const [dataSource, setDataSource] = useState('SIMULADO');
        const [memoryDB, setMemoryDB] = useState(null);
        const [apiManager, setApiManager] = useState(null);
        const [orderExecutor, setOrderExecutor] = useState(null);
        const [maxPositions, setMaxPositions] = useState(3);

        const marketDataRef = useRef(null);
        const alphaEngineRef = useRef(null);
        const memoryDBRef = useRef(null);
        const apiManagerRef = useRef(null);
        const orderExecutorRef = useRef(null);
        const verificationTimers = useRef(new Map());

        useEffect(() => {
            try {
                const savedConfig = localStorage.getItem('alpha_config');
                if (savedConfig) {
                    const config = JSON.parse(savedConfig);
                    setMinScore(config.minScore || 50);
                    setRiskAmount(config.riskAmount || 100);
                    setMaxPositions(config.maxPositions || 3);
                }

                memoryDBRef.current = new MemoryDB();
                marketDataRef.current = new MarketDataSimulator();
                alphaEngineRef.current = new AlphaEngine(memoryDBRef.current);
                apiManagerRef.current = new APIConnectionManager();
                orderExecutorRef.current = new OrderExecutionManager(apiManagerRef.current);
                
                setMemoryDB(memoryDBRef.current);
                setMarketData(marketDataRef.current);
                setAlphaEngine(alphaEngineRef.current);
                setApiManager(apiManagerRef.current);
                setOrderExecutor(orderExecutorRef.current);
            } catch (error) {
                console.log('Erro na inicializaÃ§Ã£o:', error);
            }
        }, []);

        useEffect(() => {
            const loadSavedSignals = async () => {
                if (memoryDB) {
                    const savedSignals = await memoryDB.getAllSignals();
                    const pendingSignals = savedSignals.filter(s => s.status === 'PENDENTE');
                    if (pendingSignals.length > 0) {
                        setSignals(pendingSignals);
                        pendingSignals.forEach(signal => {
                            scheduleSignalVerification(signal);
                        });
                    }
                }
            };
            
            if (memoryDB) {
                loadSavedSignals();
            }
        }, [memoryDB]);

        useEffect(() => {
            const config = {
                minScore,
                riskAmount,
                maxPositions
            };
            localStorage.setItem('alpha_config', JSON.stringify(config));
        }, [minScore, riskAmount, maxPositions]);

        useEffect(() => {
            if (!isActive || !marketData || !alphaEngine || !apiManager) return;

            const interval = setInterval(async () => {
                try {
                    const activeConn = apiManager.getActiveConnection();
                    let currentDataSource = 'SIMULADO';
                    
                    if (activeConn && activeConn.status === 'connected') {
                        try {
                            let symbolToFetch = 'BTCUSDT';
                            if (activeConn.provider === 'ALPHA_VANTAGE') {
                                symbolToFetch = 'IBM';
                            } else if (activeConn.provider === 'COINGECKO') {
                                symbolToFetch = 'BTC';
                            }
                            
                            const realData = await fetchRealMarketData(
                                activeConn.provider,
                                activeConn.apiKey,
                                symbolToFetch,
                                'M5',
                                activeConn.secretKey
                            );
                            
                            if (realData && realData.length > 0) {
                                marketData.replaceWithRealData(realData);
                                currentDataSource = 'REAL';
                                setDataSource('REAL');
                            } else {
                                throw new Error('Array de dados vazio');
                            }
                        } catch (error) {
                            if (dataSource === 'REAL') {
                                marketData.generateInitialData();
                            } else {
                                marketData.addNewCandle();
                            }
                            currentDataSource = 'SIMULADO';
                            setDataSource('SIMULADO');
                        }
                    } else {
                        marketData.addNewCandle();
                        currentDataSource = 'SIMULADO';
                        setDataSource('SIMULADO');
                    }
                    
                    const signal = alphaEngine.analyzeMarket(marketData, currentDataSource);
                    
                    if (signal && signal.score >= minScore) {
                        setSignals(prev => [signal, ...prev.slice(0, 9)]);
                        showNotification(`Novo sinal ${signal.direction} - Score: ${signal.score}%`);
                        playAlert();
                        scheduleSignalVerification(signal);
                        
                        // EXECUÃ‡ÃƒO AUTOMÃTICA SE MODO ROBÃ”
                        if (mode === 'auto' && orderExecutorRef.current) {
                            const executionResult = await orderExecutorRef.current.executeSignalAuto(
                                signal,
                                mode,
                                riskAmount
                            );
                            
                            if (executionResult.success) {
                                showNotification(
                                    `ðŸ¤– ORDEM EXECUTADA: ${signal.direction} @ ${
                                        executionResult.executedPrice.toFixed(2)
                                    } | ID: ${executionResult.orderId}`
                                );
                                
                                signal.executed = true;
                                signal.executionDetails = executionResult;
                                
                                setSignals(prev => prev.map(s => 
                                    s.id === signal.id ? signal : s
                                ));
                            } else {
                                showNotification(`âš ï¸ Falha: ${executionResult.message}`);
                            }
                        }
                    }
                } catch (error) {
                    console.log('Erro no loop:', error);
                }
            }, 30000);

            return () => clearInterval(interval);
        }, [isActive, marketData, alphaEngine, minScore, apiManager, dataSource, mode, riskAmount]);

        useEffect(() => {
            if (!isActive) return;
            
            const countdownInterval = setInterval(() => {
                setSignals(prev => [...prev]);
            }, 1000);

            return () => clearInterval(countdownInterval);
        }, [isActive]);

        const scheduleSignalVerification = (signal) => {
            try {
                const now = new Date().getTime();
                const entryTime = new Date(signal.entryTime).getTime();
                const timeframeMs = signal.timeframe === 'M5' ? 5 * 60 * 1000 : 15 * 60 * 1000;
                
                const timeUntilEntry = Math.max(0, entryTime - now);
                const verificationDelay = timeUntilEntry + timeframeMs;
                
                const monitoringInterval = setInterval(() => {
                    const currentPrice = marketDataRef.current?.getLatestPrice()?.close;
                    if (!currentPrice) return;
                    
                    let shouldStop = false;
                    let result = null;
                    let pnl = 0;
                    
                    if (signal.direction === 'BUY') {
                        if (currentPrice >= signal.takeProfit) {
                            result = 'ACERTO';
                            pnl = riskAmount * 2;
                            shouldStop = true;
                        } else if (currentPrice <= signal.stopLoss) {
                            result = 'ERRO';
                            pnl = -riskAmount;
                            shouldStop = true;
                        }
                    } else {
                        if (currentPrice <= signal.takeProfit) {
                            result = 'ACERTO';
                            pnl = riskAmount * 2;
                            shouldStop = true;
                        } else if (currentPrice >= signal.stopLoss) {
                            result = 'ERRO';
                            pnl = -riskAmount;
                            shouldStop = true;
                        }
                    }
                    
                    if (shouldStop) {
                        clearInterval(monitoringInterval);
                        clearTimeout(verificationTimerId);
                        verificationTimers.current.delete(signal.id);
                        
                        // Fechar posiÃ§Ã£o se foi executada automaticamente
                        if (orderExecutorRef.current && signal.executed) {
                            orderExecutorRef.current.closePosition(signal.id, result, pnl);
                        }
                        
                        verifySignalOutcome(signal, result, pnl, currentPrice);
                    }
                }, 5000);
                
                const verificationTimerId = setTimeout(() => {
                    clearInterval(monitoringInterval);
                    
                    // Fechar posiÃ§Ã£o se expirou
                    if (orderExecutorRef.current && signal.executed) {
                        orderExecutorRef.current.closePosition(signal.id, 'EXPIRADO', 0);
                    }
                    
                    verifySignalOutcome(signal);
                }, verificationDelay);

                verificationTimers.current.set(signal.id, {
                    timer: verificationTimerId,
                    interval: monitoringInterval
                });
            } catch (error) {
                console.error('Erro ao agendar verificaÃ§Ã£o:', error);
            }
        };

        const verifySignalOutcome = async (signal, forcedResult = null, forcedPnl = null, forcedPrice = null) => {
            try {
                if (!marketData) return;

                let result = forcedResult || 'EXPIRADO';
                let pnl = forcedPnl || 0;
                let currentPrice = forcedPrice || marketData.getLatestPrice().close;
                
                if (!forcedResult) {
                    if (signal.direction === 'BUY') {
                        if (currentPrice >= signal.takeProfit) {
                            result = 'ACERTO';
                            pnl = riskAmount * 2;
                        } else if (currentPrice <= signal.stopLoss) {
                            result = 'ERRO';
                            pnl = -riskAmount;
                        }
                    } else {
                        if (currentPrice <= signal.takeProfit) {
                            result = 'ACERTO';
                            pnl = riskAmount * 2;
                        } else if (currentPrice >= signal.stopLoss) {
                            result = 'ERRO';
                            pnl = -riskAmount;
                        }
                    }
                }

                signal.status = result;
                signal.pnl = pnl;
                signal.finalPrice = currentPrice;

                if (alphaEngine && result !== 'EXPIRADO') {
                    await alphaEngine.learnFromTrade(signal, result);
                }

                setSignals(prev => prev.map(s => 
                    s.id === signal.id ? { ...s, status: result, pnl, finalPrice: currentPrice } : s
                ));

                showNotification(
                    result === 'ACERTO' 
                        ? `âœ… Sinal confirmado: +${formatBRL(pnl)}`
                        : result === 'ERRO'
                        ? `âŒ Stop atingido: ${formatBRL(pnl)}`
                        : `â±ï¸ Sinal expirado`
                );

                verificationTimers.current.delete(signal.id);
            } catch (error) {
                console.log('Erro na verificaÃ§Ã£o:', error);
            }
        };

        const handleEmergencyStop = () => {
            if (orderExecutorRef.current) {
                const closedPositions = orderExecutorRef.current.emergencyCloseAll();
                showNotification(`ðŸš¨ EMERGÃŠNCIA: ${closedPositions.length} posiÃ§Ãµes fechadas`);
                
                // Atualizar sinais fechados
                setSignals(prev => prev.map(s => {
                    if (closedPositions.includes(s.id)) {
                        return { ...s, status: 'CANCELADO', pnl: 0 };
                    }
                    return s;
                }));
            }
        };

        const playAlert = () => {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (error) {
                console.log('Audio not available');
            }
        };

        const showNotification = (message) => {
            try {
                if (!message) return;
                setNotification(message);
                setTimeout(() => setNotification(null), 3000);
            } catch (error) {
                console.log('Erro ao mostrar notificaÃ§Ã£o:', error);
            }
        };

        const dismissSignal = (signalId) => {
            try {
                if (!signalId) return;
                
                const timerData = verificationTimers.current.get(signalId);
                if (timerData) {
                    if (timerData.timer) clearTimeout(timerData.timer);
                    if (timerData.interval) clearInterval(timerData.interval);
                    verificationTimers.current.delete(signalId);
                }
                
                setSignals(prev => prev.filter(s => s && s.id !== signalId));
            } catch (error) {
                console.log('Erro ao dispensar sinal:', error);
            }
        };

        const copySignalDetails = (signal) => {
            try {
                if (!signal) {
                    showNotification('Erro: Sinal nÃ£o encontrado');
                    return;
                }

           const details = `
Sinal: ${signal.direction || 'N/A'} ${signal.symbol || 'N/A'}
Score: ${signal.score || 0}%
PreÃ§o: ${formatBRL(signal.price)}
Stop: ${formatBRL(signal.stopLoss)}
Alvo: ${formatBRL(signal.takeProfit)}
TF: ${signal.timeframe || 'N/A'}
Status: ${signal.status || 'PENDENTE'}
Fonte: ${signal.dataSource || 'N/A'}
${signal.divergence ? `Divergencia: ${signal.divergence.type}` : ''}
`.trim();
                if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                    navigator.clipboard.writeText(details)
                        .then(() => showNotification('Detalhes copiados!'))
                        .catch(() => showNotification('Erro ao copiar'));
                }
            } catch (error) {
                console.log('Erro ao copiar:', error);
            }
        };

        const formatBRL = (value) => {
            if (value === null || value === undefined) return 'R$ 0,00';
            return value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
        };

        return (
            <div className="app">
                <Sidebar currentView={currentView} setCurrentView={setCurrentView} />
                <div className="main-content">
                    <Header 
                        isActive={isActive} 
                        setIsActive={setIsActive}
                        mode={mode}
                        setMode={setMode}
                        dataSource={dataSource}
                        orderExecutor={orderExecutor}
                        onEmergencyStop={handleEmergencyStop}
                    />
                    
                    {currentView === 'dashboard' && (
                        <Dashboard 
                            signals={signals}
                            alphaEngine={alphaEngine}
                            minScore={minScore}
                            setMinScore={setMinScore}
                            dismissSignal={dismissSignal}
                            copySignalDetails={copySignalDetails}
                            riskAmount={riskAmount}
                            setRiskAmount={setRiskAmount}
                            maxPositions={maxPositions}
                            setMaxPositions={setMaxPositions}
                            formatBRL={formatBRL}
                            orderExecutor={orderExecutor}
                            mode={mode}
                        />
                    )}
                    
                    {currentView === 'performance' && (
                        <Performance 
                            alphaEngine={alphaEngine} 
                            signals={signals} 
                            memoryDB={memoryDB} 
                            formatBRL={formatBRL} 
                        />
                    )}
                    
                    {currentView === 'ml-engine' && (
                        <MLEngine alphaEngine={alphaEngine} memoryDB={memoryDB} />
                    )}
                    
                    {currentView === 'robot' && (
                        <RobotView 
                            orderExecutor={orderExecutor}
                            formatBRL={formatBRL}
                            maxPositions={maxPositions}
                            setMaxPositions={setMaxPositions}
                        />
                    )}
                    
                    {currentView === 'connections' && (
                        <ConnectionsView 
                            apiManager={apiManager}
                            showNotification={showNotification}
                        />
                    )}
                    
                    {currentView === 'settings' && (
                        <Settings 
                            minScore={minScore}
                            setMinScore={setMinScore}
                        />
                    )}
                </div>
                
                {notification && (
                    <div className="notification">
                        {notification}
                    </div>
                )}
            </div>
        );
    }

    function Sidebar({ currentView, setCurrentView }) {
        const menuItems = [
            { id: 'dashboard', label: 'Dashboard', icon: 'ðŸ“Š' },
            { id: 'robot', label: 'Painel do RobÃ´', icon: 'ðŸ¤–' },
            { id: 'performance', label: 'Performance', icon: 'ðŸ“ˆ' },
            { id: 'ml-engine', label: 'ML Engine', icon: 'ðŸ§ ' },
            { id: 'connections', label: 'ConexÃµes', icon: 'ðŸ”—' },
            { id: 'settings', label: 'ConfiguraÃ§Ãµes', icon: 'âš™ï¸' }
        ];

        return (
            <div className="sidebar">
                <div className="logo">âš¡ Alpha-Learner v2.2</div>
                {menuItems.map(item => (
                    <div 
                        key={item.id}
                        className={`nav-item ${currentView === item.id ? 'active' : ''}`}
                        onClick={() => setCurrentView(item.id)}
                    >
                        {item.icon} {item.label}
                    </div>
                ))}
            </div>
        );
    }

    function Header({ isActive, setIsActive, mode, setMode, dataSource, orderExecutor, onEmergencyStop }) {
        return (
            <div className="header">
                <div>
                    <h2>Trading Console</h2>
                    <div className="mode-selector">
                        <div 
                            className={`mode-btn ${mode === 'manual' ? 'active' : ''}`}
                            onClick={() => setMode('manual')}
                        >
                            ðŸŽ¯ Modo Assistente
                        </div>
                        <div 
                            className={`mode-btn ${mode === 'auto' ? 'active' : ''}`}
                            onClick={() => setMode('auto')}
                        >
                            ðŸ¤– Modo RobÃ´
                        </div>
                    </div>
                </div>
                <div className="status-indicator">
                    <div className={`toggle-switch ${isActive ? 'active' : ''}`} 
                         onClick={() => setIsActive(!isActive)}>
                    </div>
                    <span>Alpha Engine: {isActive ? 'ATIVO' : 'INATIVO'}</span>
                    <div className="status-dot"></div>
                    
                    <div className={`data-source-badge ${dataSource === 'REAL' ? 'data-source-real' : 'data-source-simulated'}`}>
                        {dataSource === 'REAL' ? 'ðŸŸ¢ DADOS EM TEMPO REAL' : 'ðŸŸ  DADOS SIMULADOS'}
                    </div>
                    
                    {mode === 'auto' && isActive && orderExecutor && (
                        <>
                            <div style={{
                                background: 'rgba(255, 193, 7, 0.2)',
                                border: '1px solid #ffc107',
                                padding: '8px 12px',
                                borderRadius: '8px',
                                fontSize: '12px',
                                fontWeight: 'bold',
                                color: '#ffc107'
                            }}>
                                ðŸ¤– EXECUTANDO AUTOMATICAMENTE
                            </div>
                            
                            <button 
                                className="btn btn-emergency"
                                onClick={onEmergencyStop}
                            >
                                ðŸš¨ PARAR TUDO
                            </button>
                        </>
                    )}
                </div>
            </div>
        );
    }

    /* CONTINUA NA PRÃ“XIMA PARTE... */

    // Devido ao tamanho, continuarei com os componentes restantes em mensagens subsequentes
    // Os componentes Dashboard, SignalCard, Performance, MLEngine, RobotView, ConnectionsView e Settings seguem...


    /* COMPONENTES REACT - CONTINUAÃ‡ÃƒO */

        function Dashboard({ signals, alphaEngine, minScore, setMinScore, dismissSignal, copySignalDetails, riskAmount, setRiskAmount, maxPositions, setMaxPositions, formatBRL, orderExecutor, mode }) {
            const getPerformanceMetrics = () => {
                try {
                    if (!alphaEngine || !alphaEngine.performance) {
                        return { winRate: 0, totalPnL: 0, totalSignals: 0 };
                    }
                    return {
                        winRate: alphaEngine.performance.winRate || 0,
                        totalPnL: alphaEngine.performance.totalPnL || 0,
                        totalSignals: alphaEngine.performance.totalSignals || 0
                    };
                } catch (error) {
                    return { winRate: 0, totalPnL: 0, totalSignals: 0 };
                }
            };

            const metrics = getPerformanceMetrics();

            return (
                <div>
                    {mode === 'auto' && (
                        <div className="robot-status-panel">
                            <h3>ðŸ¤– Status do RobÃ´</h3>
                            <div className="metric-grid">
                                <div className="metric-card">
                                    <div className="metric-value">
                                        {orderExecutor ? orderExecutor.getActivePositions().length : 0}
                                    </div>
                                    <div className="metric-label">PosiÃ§Ãµes Abertas</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value">
                                        {formatBRL(orderExecutor ? orderExecutor.getVirtualBalance() : 0)}
                                    </div>
                                    <div className="metric-label">Saldo Virtual</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value">
                                        {orderExecutor ? orderExecutor.getExecutionHistory().length : 0}
                                    </div>
                                    <div className="metric-label">Ordens Executadas</div>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="grid">
                        <div className="card">
                            <h3>âš™ï¸ ConfiguraÃ§Ãµes de OperaÃ§Ã£o</h3>
                            <div className="form-group">
                                <label className="form-label">Score MÃ­nimo: {minScore}%</label>
                                <input 
                                    type="range" 
                                    min="50" 
                                    max="95" 
                                    value={minScore}
                                    onChange={(e) => setMinScore(Number(e.target.value))}
                                    className="form-input"
                                />
                            </div>
                            <div className="form-group">
                                <label className="form-label">Valor de Risco (R$)</label>
                                <input 
                                    type="number"
                                    value={riskAmount}
                                    onChange={(e) => setRiskAmount(Number(e.target.value))}
                                    className="form-input"
                                />
                            </div>
                            {mode === 'auto' && (
                                <div className="form-group">
                                    <label className="form-label">MÃ¡ximo de PosiÃ§Ãµes SimultÃ¢neas</label>
                                    <input 
                                        type="number"
                                        min="1"
                                        max="10"
                                        value={maxPositions}
                                        onChange={(e) => {
                                            const val = Number(e.target.value);
                                            setMaxPositions(val);
                                            if (orderExecutor) {
                                                orderExecutor.setMaxPositions(val);
                                            }
                                        }}
                                        className="form-input"
                                    />
                                </div>
                            )}
                        </div>

                        <div className="card">
                            <h3>ðŸ“Š MÃ©tricas em Tempo Real</h3>
                            <div className="metric-grid">
                                <div className="metric-card">
                                    <div className="metric-value">{signals ? signals.length : 0}</div>
                                    <div className="metric-label">Sinais Ativos</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value">{metrics.winRate.toFixed(1)}%</div>
                                    <div className="metric-label">Taxa de Acerto</div>
                                </div>
                                <div className="metric-card">
                                    <div className="metric-value" style={{ 
                                        color: metrics.totalPnL >= 0 ? '#00ff88' : '#ff4757',
                                        fontSize: '24px'
                                    }}>
                                        {formatBRL(metrics.totalPnL)}
                                    </div>
                                    <div className="metric-label">P&L Acumulado</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸŽ¯ Oportunidades de Trading</h3>
                        {!signals || signals.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '40px' }}>
                                ðŸ” Aguardando sinais de alta qualidade...
                            </div>
                        ) : (
                            <div className="grid">
                                {signals.map(signal => (
                                    <SignalCard 
                                        key={signal ? signal.id : Math.random()}
                                        signal={signal}
                                        onDismiss={dismissSignal}
                                        onCopy={copySignalDetails}
                                        formatBRL={formatBRL}
                                        mode={mode}
                                    />
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function SignalCard({ signal, onDismiss, onCopy, formatBRL, mode }) {
            if (!signal) return null;

            const getStatusClass = () => {
                if (signal.status === 'ACERTO') return 'success';
                if (signal.status === 'ERRO') return 'error';
                return '';
            };

            let timeToEntry = 0;
            let minutes = 0;
            let seconds = 0;
            
            try {
                if (signal.entryTime) {
                    const now = new Date();
                    const entryTime = new Date(signal.entryTime);
                    timeToEntry = Math.max(0, Math.floor((entryTime - now) / 1000));
                    minutes = Math.floor(timeToEntry / 60);
                    seconds = timeToEntry % 60;
                }
            } catch (error) {
                timeToEntry = 0;
            }
            
            const formatEntryTime = () => {
                if (signal.status !== 'PENDENTE') return `Status: ${signal.status}`;
                if (timeToEntry <= 0) return "â° ENTRAR AGORA";
                if (timeToEntry < 60) return `â±ï¸ ${seconds}s para entrada`;
                return `â±ï¸ ${minutes}m ${seconds}s para entrada`;
            };

            const getExactEntryTime = () => {
                try {
                    const entryDate = new Date(signal.entryTime);
                    return entryDate.toLocaleTimeString('pt-BR', { 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        second: '2-digit' 
                    });
                } catch {
                    return 'N/A';
                }
            };
            
            return (
                <div className={`signal-card ${timeToEntry <= 30 && timeToEntry > 0 ? 'urgent' : ''} ${getStatusClass()}`}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                        <div className={`signal-direction ${(signal.direction || '').toLowerCase()}`}>
                            {signal.direction === 'BUY' ? 'ðŸŸ¢' : 'ðŸ”´'} {signal.direction || 'N/A'} {signal.symbol || 'N/A'}
                        </div>
                        
                        <div style={{
                            padding: '4px 8px',
                            borderRadius: '12px',
                            fontSize: '10px',
                            fontWeight: 'bold',
                            background: signal.dataSource === 'REAL' ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 165, 0, 0.2)',
                            color: signal.dataSource === 'REAL' ? '#00ff88' : '#ffa500',
                            border: `1px solid ${signal.dataSource === 'REAL' ? '#00ff88' : '#ffa500'}`
                        }}>
                            {signal.dataSource === 'REAL' ? 'ðŸ“¡ Real' : 'ðŸ”® Simulado'}
                        </div>
                    </div>
                    
                    <div>
                        <span className="signal-score">Score: {signal.score || 0}%</span>
                        <span className={`signal-status ${signal.status?.toLowerCase() || 'pending'}`}>
                            {signal.status === 'ACERTO' && 'âœ… ACERTO'}
                            {signal.status === 'ERRO' && 'âŒ ERRO'}
                            {signal.status === 'EXPIRADO' && 'â±ï¸ EXPIRADO'}
                            {signal.status === 'PENDENTE' && 'â³ PENDENTE'}
                            {signal.status === 'CANCELADO' && 'ðŸš« CANCELADO'}
                        </span>
                        {mode === 'auto' && signal.executed && (
                            <span className="signal-status success" style={{ marginLeft: '5px' }}>
                                ðŸ¤– EXECUTADO
                            </span>
                        )}
                    </div>
                    
                    <div style={{ 
                        background: timeToEntry <= 30 && signal.status === 'PENDENTE' ? 'rgba(255, 215, 0, 0.2)' : 'rgba(0, 255, 136, 0.1)',
                        border: `1px solid ${timeToEntry <= 30 && signal.status === 'PENDENTE' ? '#ffd700' : 'rgba(0, 255, 136, 0.3)'}`,
                        padding: '8px 12px',
                        borderRadius: '8px',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        color: timeToEntry <= 30 && signal.status === 'PENDENTE' ? '#ffd700' : '#00ff88',
                        marginBottom: '10px',
                        marginTop: '10px',
                        textAlign: 'center'
                    }}>
                        {formatEntryTime()}
                    </div>

                    {signal.status === 'PENDENTE' && (
                        <div style={{
                            background: 'rgba(0, 184, 217, 0.15)',
                            border: '1px solid rgba(0, 184, 217, 0.4)',
                            borderRadius: '8px',
                            padding: '10px 12px',
                            marginBottom: '10px',
                            fontSize: '13px',
                            fontWeight: 'bold',
                            color: '#00b8d9',
                            textAlign: 'center',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: '8px'
                        }}>
                            <span style={{ fontSize: '16px' }}>ðŸŽ¯</span>
                            <div>
                                <div style={{ fontSize: '11px', opacity: 0.8, marginBottom: '2px' }}>
                                    HORÃRIO EXATO DE ENTRADA
                                </div>
                                <div style={{ fontSize: '16px', letterSpacing: '1px' }}>
                                    {getExactEntryTime()}
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {signal.divergence && (
                        <div style={{
                            background: 'rgba(255, 215, 0, 0.2)',
                            border: '1px solid #ffd700',
                            borderRadius: '8px',
                            padding: '8px 12px',
                            fontSize: '12px',
                            fontWeight: 'bold',
                            color: '#ffd700',
                            marginBottom: '10px'
                        }}>
                            âš¡ DivergÃªncia {signal.divergence.type || 'N/A'}
                        </div>
                    )}
                    
                    {signal.executionDetails && (
                        <div style={{
                            background: 'rgba(0, 255, 136, 0.1)',
                            border: '1px solid #00ff88',
                            borderRadius: '8px',
                            padding: '10px',
                            marginBottom: '10px',
                            fontSize: '12px'
                        }}>
                            <strong>Detalhes da ExecuÃ§Ã£o:</strong>
                            <div>Order ID: {signal.executionDetails.orderId}</div>
                            <div>PreÃ§o Executado: {formatBRL(signal.executionDetails.executedPrice)}</div>
                            <div>Quantidade: {signal.executionDetails.executedQty}</div>
                        </div>
                    )}
                    
                    <div className="signal-details">
                        <div><strong>PreÃ§o:</strong> {formatBRL(signal.price)}</div>
                        <div><strong>Timeframe:</strong> {signal.timeframe || 'N/A'}</div>
                        <div><strong>Stop Loss:</strong> {formatBRL(signal.stopLoss)}</div>
                        <div><strong>Take Profit:</strong> {formatBRL(signal.takeProfit)}</div>
                        <div><strong>R/R:</strong> 1:2</div>
                        <div><strong>Risco:</strong> R$ 100</div>
                    </div>
                    
                    {signal.status !== 'PENDENTE' && signal.pnl !== undefined && (
                        <div style={{ 
                            padding: '12px', 
                            borderRadius: '8px', 
                            background: signal.pnl >= 0 ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 71, 87, 0.2)',
                            marginTop: '10px',
                            border: `1px solid ${signal.pnl >= 0 ? '#00ff88' : '#ff4757'}`
                        }}>
                            <strong>Resultado Final:</strong> 
                            <span style={{ 
                                color: signal.pnl >= 0 ? '#00ff88' : '#ff4757',
                                fontWeight: 'bold',
                                fontSize: '16px',
                                marginLeft: '10px'
                            }}>
                                {formatBRL(signal.pnl)}
                            </span>
                            {signal.finalPrice && (
                                <div style={{ fontSize: '12px', marginTop: '5px', color: '#a0a0a0' }}>
                                    PreÃ§o final: {formatBRL(signal.finalPrice)}
                                </div>
                            )}
                        </div>
                    )}
                    
                    <div className="signal-actions">
                        <button className="btn btn-primary" onClick={() => onCopy && onCopy(signal)}>
                            ðŸ“‹ Copiar
                        </button>
                        <button className="btn btn-secondary" onClick={() => onDismiss && onDismiss(signal.id)}>
                            âŒ Dispensar
                        </button>
                    </div>
                </div>
            );
        }

        function RobotView({ orderExecutor, formatBRL, maxPositions, setMaxPositions }) {
            const [logs, setLogs] = useState([]);
            const [positions, setPositions] = useState([]);
            const [history, setHistory] = useState([]);

            useEffect(() => {
                if (!orderExecutor) return;

                const updateData = () => {
                    setLogs(orderExecutor.getSystemLogs().slice(-50).reverse());
                    setPositions(orderExecutor.getActivePositions());
                    setHistory(orderExecutor.getExecutionHistory().slice(-20).reverse());
                };

                updateData();
                const interval = setInterval(updateData, 2000);
                return () => clearInterval(interval);
            }, [orderExecutor]);

            if (!orderExecutor) {
                return (
                    <div className="card">
                        <h3>â³ Carregando...</h3>
                        <p>Inicializando sistema de execuÃ§Ã£o...</p>
                    </div>
                );
            }

            return (
                <div>
                    <div className="warning-box">
                        âš ï¸ <strong>Painel do RobÃ´:</strong> Este Ã© um sistema de execuÃ§Ã£o automÃ¡tica para conta DEMO. 
                        Todas as ordens sÃ£o executadas em ambiente de testes com dinheiro virtual.
                    </div>

                    <div className="grid">
                        <div className="card">
                            <h3>ðŸ’° Status Financeiro</h3>
                            <div className="metric-card">
                                <div className="metric-value">
                                    {formatBRL(orderExecutor.getVirtualBalance())}
                                </div>
                                <div className="metric-label">Saldo Virtual DisponÃ­vel</div>
                            </div>
                        </div>

                        <div className="card">
                            <h3>âš™ï¸ ConfiguraÃ§Ãµes de Risco</h3>
                            <div className="form-group">
                                <label className="form-label">
                                    MÃ¡ximo de PosiÃ§Ãµes: {maxPositions}
                                </label>
                                <input 
                                    type="range"
                                    min="1"
                                    max="10"
                                    value={maxPositions}
                                    onChange={(e) => {
                                        const val = Number(e.target.value);
                                        setMaxPositions(val);
                                        orderExecutor.setMaxPositions(val);
                                    }}
                                    className="form-input"
                                />
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸ“Š PosiÃ§Ãµes Abertas ({positions.length})</h3>
                        {positions.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '20px' }}>
                                Nenhuma posiÃ§Ã£o aberta no momento
                            </div>
                        ) : (
                            positions.map(pos => (
                                <div key={pos.signal.id} className="position-card">
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
                                        <strong>
                                            {pos.signal.direction} {pos.signal.symbol}
                                        </strong>
                                        <span style={{ fontSize: '12px', color: '#a0a0a0' }}>
                                            {new Date(pos.openTime).toLocaleTimeString()}
                                        </span>
                                    </div>
                                    <div style={{ fontSize: '13px' }}>
                                        <div>Entrada: {formatBRL(pos.orderResult.executedPrice)}</div>
                                        <div>Stop: {formatBRL(pos.signal.stopLoss)}</div>
                                        <div>Alvo: {formatBRL(pos.signal.takeProfit)}</div>
                                        <div>Risco: {formatBRL(pos.riskAmount)}</div>
                                        <div>Order ID: {pos.orderResult.orderId}</div>
                                    </div>
                                </div>
                            ))
                        )}
                    </div>

                    <div className="card">
                        <h3>ðŸ“œ HistÃ³rico de ExecuÃ§Ãµes</h3>
                        {history.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '20px' }}>
                                Nenhuma execuÃ§Ã£o ainda
                            </div>
                        ) : (
                            <div>
                                {history.map((exec, idx) => (
                                    <div key={idx} style={{
                                        padding: '10px',
                                        margin: '5px 0',
                                        border: '1px solid rgba(255, 255, 255, 0.1)',
                                        borderRadius: '6px',
                                        fontSize: '12px'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                            <strong>{exec.direction} {exec.symbol}</strong>
                                            <span>{new Date(exec.timestamp).toLocaleString()}</span>
                                        </div>
                                        <div style={{ marginTop: '5px', color: '#a0a0a0' }}>
                                            PreÃ§o: {formatBRL(exec.orderResult.executedPrice)} | 
                                            Order: {exec.orderResult.orderId}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    <div className="card">
                        <h3>ðŸ“‹ Logs do Sistema</h3>
                        <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
                            {logs.length === 0 ? (
                                <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '20px' }}>
                                    Nenhum log ainda
                                </div>
                            ) : (
                                logs.map((log, idx) => (
                                    <div key={idx} className={`log-entry ${log.type}`}>
                                        <span style={{ color: '#00ff88' }}>
                                            {new Date(log.timestamp).toLocaleTimeString()}
                                        </span> {log.message}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function Performance({ alphaEngine, signals, memoryDB, formatBRL }) {
            const [stats, setStats] = useState(null);

            useEffect(() => {
                const loadStats = async () => {
                    if (memoryDB) {
                        const dbStats = await memoryDB.getStatistics();
                        setStats(dbStats);
                    }
                };
                loadStats();
            }, [memoryDB, signals]);

            if (!alphaEngine) return null;

            const performance = alphaEngine.performance || {};

            return (
                <div>
                    <div className="card">
                        <h3>ðŸ“ˆ Performance Geral do Sistema</h3>
                        <div className="metric-grid">
                            <div className="metric-card">
                                <div className="metric-value">{stats?.total || performance.totalSignals || 0}</div>
                                <div className="metric-label">Total de Sinais</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value">{stats?.successful || performance.successfulSignals || 0}</div>
                                <div className="metric-label">Sinais Bem-sucedidos</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value">{(stats?.winRate || performance.winRate || 0).toFixed(1)}%</div>
                                <div className="metric-label">Taxa de Acerto</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value" style={{
                                    color: (stats?.totalPnL || performance.totalPnL || 0) >= 0 ? '#00ff88' : '#ff4757',
                                    fontSize: '24px'
                                }}>
                                    {formatBRL(stats?.totalPnL || performance.totalPnL || 0)}
                                </div>
                                <div className="metric-label">P&L Total</div>
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸŽ¯ HistÃ³rico de Sinais Recentes</h3>
                        {!signals || signals.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '20px' }}>
                                Nenhum sinal gerado ainda
                            </div>
                        ) : (
                            <div>
                                {signals.filter(s => s && s.status !== 'PENDENTE').map(signal => (
                                    <div key={signal.id || Math.random()} style={{ 
                                        padding: '15px', 
                                        margin: '10px 0',
                                        border: '1px solid rgba(255, 255, 255, 0.1)',
                                        borderRadius: '8px',
                                        background: signal.status === 'ACERTO' ? 
                                            'rgba(0, 255, 136, 0.1)' : 'rgba(255, 71, 87, 0.1)'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                            <div>
                                                <strong>{signal.direction || 'N/A'} {signal.symbol || 'N/A'}</strong>
                                                <span style={{ marginLeft: '10px', color: '#a0a0a0', fontSize: '14px' }}>
                                                    Score: {signal.score || 0}%
                                                </span>
                                                <span style={{ 
                                                    marginLeft: '10px',
                                                    padding: '2px 8px',
                                                    borderRadius: '12px',
                                                    fontSize: '10px',
                                                    background: signal.dataSource === 'REAL' ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 165, 0, 0.2)',
                                                    color: signal.dataSource === 'REAL' ? '#00ff88' : '#ffa500'
                                                }}>
                                                    {signal.dataSource}
                                                </span>
                                            </div>
                                            <div style={{ 
                                                color: signal.status === 'ACERTO' ? '#00ff88' : '#ff4757',
                                                fontWeight: 'bold',
                                                fontSize: '16px'
                                            }}>
                                                {signal.status === 'ACERTO' ? 'âœ…' : 'âŒ'} 
                                                {formatBRL(signal.pnl || 0)}
                                            </div>
                                        </div>
                                        {signal.divergence && (
                                            <div style={{ fontSize: '12px', color: '#ffd700', marginTop: '5px' }}>
                                                âš¡ DivergÃªncia {signal.divergence.type || 'N/A'}
                                            </div>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function MLEngine({ alphaEngine, memoryDB }) {
            const [weightsHistory, setWeightsHistory] = useState([]);

            useEffect(() => {
                const loadHistory = async () => {
                    if (memoryDB) {
                        const history = await memoryDB.getWeightsHistory();
                        setWeightsHistory(history);
                    }
                };
                loadHistory();
            }, [memoryDB]);

            if (!alphaEngine) return null;

            const weights = alphaEngine.weights || {};
            const stats = alphaEngine.performance || {};

            return (
                <div>
                    <div className="card">
                        <h3>ðŸ§  Sistema de Pesos Adaptativos</h3>
                        <p>O Alpha-Learner ajusta automaticamente a importÃ¢ncia de cada indicador baseado em resultados REAIS verificados.</p>
                        
                        <div style={{ marginTop: '20px' }}>
                            {Object.entries(weights).map(([indicator, weight]) => (
                                <div key={indicator} className="weight-item">
                                    <div>
                                        <strong>{indicator.replace('_', ' ').toUpperCase()}</strong>
                                        <br />
                                        <small>{((weight || 0) * 100).toFixed(1)}%</small>
                                    </div>
                                    <div className="weight-bar">
                                        <div 
                                            className="weight-fill" 
                                            style={{ width: `${(weight || 0) * 100}%` }}
                                        ></div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸ“Š EstatÃ­sticas de Aprendizado</h3>
                        <div className="metric-grid">
                            <div className="metric-card">
                                <div className="metric-value">{stats.totalSignals || 0}</div>
                                <div className="metric-label">Sinais Processados</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value">{stats.successfulSignals || 0}</div>
                                <div className="metric-label">Aprendizados Positivos</div>
                            </div>
                            <div className="metric-card">
                                <div className="metric-value">{weightsHistory.length}</div>
                                <div className="metric-label">Snapshots Salvos</div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        function ConnectionsView({ apiManager, showNotification }) {
            const [selectedProvider, setSelectedProvider] = useState('BINANCE');
            const [apiKey, setApiKey] = useState('');
            const [secretKey, setSecretKey] = useState('');
            const [testing, setTesting] = useState(false);
            const [testResult, setTestResult] = useState(null);

            if (!apiManager) {
                return (
                    <div className="card">
                        <h3>â³ Carregando...</h3>
                        <p>Inicializando gerenciador de APIs...</p>
                    </div>
                );
            }

            const handleTest = async () => {
                if (!apiKey.trim()) {
                    showNotification('Por favor, insira a API Key');
                    return;
                }

                const provider = API_PROVIDERS[selectedProvider];
                if (provider.requiresSecret && !secretKey.trim()) {
                    showNotification('Este provedor requer Secret Key');
                    return;
                }

                setTesting(true);
                setTestResult(null);

                try {
                    const result = await testAPIConnection(selectedProvider, apiKey, secretKey || null);
                    setTestResult(result);
                    
                    if (result.success) {
                        apiManager.addConnection(selectedProvider, apiKey, secretKey || null);
                        apiManager.updateStatus(selectedProvider, 'connected');
                        apiManager.setActive(selectedProvider);
                        showNotification('âœ… ConexÃ£o estabelecida com sucesso!');
                    } else {
                        showNotification(`âŒ ${result.message}`);
                    }
                } catch (error) {
                    setTestResult({ 
                        success: false, 
                        message: `Erro: ${error.message}` 
                    });
                } finally {
                    setTesting(false);
                }
            };

            const handleDisconnect = (provider) => {
                apiManager.removeConnection(provider);
                showNotification('ConexÃ£o removida');
                
                if (provider === selectedProvider) {
                    setApiKey('');
                    setSecretKey('');
                    setTestResult(null);
                }
            };

            const connectedProviders = [];
            if (apiManager.connections) {
                apiManager.connections.forEach((conn, provider) => {
                    if (conn.status === 'connected') {
                        connectedProviders.push(provider);
                    }
                });
            }

            return (
                <div>
                    <div className="warning-box">
                        âš ï¸ <strong>Testnet Binance:</strong> Use chaves da Testnet (testnet.binance.vision) para testes sem risco.
                        Nunca use chaves da conta real neste sistema.
                    </div>

                    <div className="card">
                        <h3>ðŸ”— Configurar Nova ConexÃ£o</h3>
                        
                        <div className="form-group">
                            <label className="form-label">Provedor de Dados</label>
                            <select 
                                className="form-select"
                                value={selectedProvider}
                                onChange={(e) => {
                                    setSelectedProvider(e.target.value);
                                    setTestResult(null);
                                }}
                            >
                                {Object.entries(API_PROVIDERS).map(([key, provider]) => (
                                    <option key={key} value={key}>
                                        {provider.icon} {provider.name}
                                    </option>
                                ))}
                            </select>
                            <small style={{ color: '#a0a0a0', fontSize: '12px', marginTop: '5px', display: 'block' }}>
                                {API_PROVIDERS[selectedProvider].description}
                            </small>
                        </div>

                        <div className="form-group">
                            <label className="form-label">API Key</label>
                            <input 
                                type="password"
                                className="form-input"
                                value={apiKey}
                                onChange={(e) => setApiKey(e.target.value)}
                                placeholder="Insira sua chave de API"
                            />
                        </div>

                        {API_PROVIDERS[selectedProvider].requiresSecret && (
                            <div className="form-group">
                                <label className="form-label">Secret Key</label>
                                <input 
                                    type="password"
                                    className="form-input"
                                    value={secretKey}
                                    onChange={(e) => setSecretKey(e.target.value)}
                                    placeholder="Insira sua chave secreta"
                                />
                            </div>
                        )}

                        <button 
                            className="btn btn-primary" 
                            onClick={handleTest}
                            disabled={testing}
                            style={{ width: '100%' }}
                        >
                            {testing ? 'ðŸ”„ Testando...' : 'ðŸ”— Salvar e Testar'}
                        </button>

                        {testResult && (
                            <div className={testResult.success ? 'success-box' : 'error-box'} style={{ marginTop: '15px' }}>
                                {testResult.message}
                            </div>
                        )}
                    </div>

                    <div className="card">
                        <h3>ðŸ“Š ConexÃµes Ativas</h3>
                        
                        {connectedProviders.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#a0a0a0', padding: '40px' }}>
                                Nenhuma conexÃ£o ativa
                            </div>
                        ) : (
                            <div>
                                {connectedProviders.map(provider => {
                                    const providerInfo = API_PROVIDERS[provider];
                                    const conn = apiManager.connections.get(provider);
                                    const isActive = apiManager.activeProvider === provider;
                                    
                                    return (
                                        <div key={provider} className={`api-provider-card ${isActive ? 'connected' : ''}`}>
                                            <div style={{ display: 'flex', alignItems: 'center', marginBottom: '15px' }}>
                                                <div style={{ flex: 1 }}>
                                                    <h4 style={{ color: '#00ff88', margin: 0 }}>
                                                        {providerInfo.icon} {providerInfo.name}
                                                    </h4>
                                                    <small style={{ color: '#a0a0a0' }}>
                                                        {isActive && 'ðŸŸ¢ Ativo'}
                                                    </small>
                                                </div>
                                                <div className="api-status-badge api-status-connected">
                                                    âœ… Conectado
                                                </div>
                                            </div>

                                            <div style={{ display: 'flex', gap: '10px' }}>
                                                {!isActive && (
                                                    <button 
                                                        className="btn btn-primary"
                                                        onClick={() => {
                                                            apiManager.setActive(provider);
                                                            showNotification(`${providerInfo.name} ativado`);
                                                        }}
                                                    >
                                                        âš¡ Ativar
                                                    </button>
                                                )}
                                                <button 
                                                    className="btn btn-danger"
                                                    onClick={() => handleDisconnect(provider)}
                                                >
                                                    ðŸ—‘ï¸ Remover
                                                </button>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function Settings({ minScore, setMinScore }) {
            return (
                <div>
                    <div className="card">
                        <h3>âš™ï¸ ConfiguraÃ§Ãµes Gerais</h3>
                        <div className="form-group">
                            <label className="form-label">Score MÃ­nimo: {minScore}%</label>
                            <input 
                                type="range"
                                min="50"
                                max="95"
                                value={minScore}
                                onChange={(e) => setMinScore(Number(e.target.value))}
                                className="form-input"
                            />
                        </div>
                    </div>

                    <div className="card">
                        <h3>ðŸ“š Sobre o Alpha-Learner v2.2</h3>
                        <p style={{ lineHeight: '1.6', color: '#c0c0c0' }}>
                            Plataforma de trading algorÃ­tmico com Machine Learning adaptativo, 
                            execuÃ§Ã£o automÃ¡tica protegida e integraÃ§Ã£o com APIs em tempo real.
                        </p>
                        <div style={{ marginTop: '15px', fontSize: '14px', color: '#00ff88' }}>
                            VersÃ£o: 2.2.0 | Build: 2024.004 | RobÃ´ Protegido
                        </div>
                    </div>
                </div>
            );
        }

        // Renderizar aplicaÃ§Ã£o
        try {
            const rootElement = document.getElementById('root');
            if (rootElement) {
                ReactDOM.render(<App />, rootElement);
            }
        } catch (error) {
            console.error('Erro ao renderizar:', error);
        }
    </script>
</body>
</html>

</script>
</body>
</html>
</artifact>

